{"y": "use vstd::math::abs;\nuse vstd::prelude::*;\nuse vstd::slice::*;\n\nverus! {\n\n/// Because Verus doesn't support floating point, we need to use integers instead.\nfn has_close_elements(numbers: &[i64], threshold: i64) -> (result: bool)\n    ensures\n        result == exists|i: int, j: int|\n            0 <= i < j < numbers@.len() && abs(numbers[i] - numbers[j]) < threshold,\n{\n    // If `threshold <= 0`, there can't be any elements closer than `threshold`, so we can\n    // just return `false`.\n    if threshold <= 0 {\n        assert(forall|i: int, j: int|\n            0 <= i < j < numbers@.len() ==> abs(numbers[i] - numbers[j]) >= 0 >= threshold);\n        return false;\n    }\n    // Now that we know `threshold > 0`, we can safely compute `i64::MAX - threshold` without\n    // risk of overflow. (Subtracting a negative threshold would overflow.)\n\n    let max_minus_threshold: i64 = i64::MAX - threshold;\n    let numbers_len: usize = numbers.len();\n    for x in 0..numbers_len\n        invariant\n            max_minus_threshold == i64::MAX - threshold,\n            numbers_len == numbers@.len(),\n            forall|i: int, j: int|\n                0 <= i < j < numbers@.len() && i < x ==> abs(numbers[i] - numbers[j]) >= threshold,\n    {\n        let numbers_x: i64 = *slice_index_get(numbers, x);  // Verus doesn't yet support `numbers[x]` in exec mode.\n        for y in x + 1..numbers_len\n            invariant\n                max_minus_threshold == i64::MAX - threshold,\n                numbers_len == numbers@.len(),\n                x < numbers@.len(),\n                numbers_x == numbers[x as int],\n                forall|i: int, j: int|\n                    0 <= i < j < numbers@.len() && i < x ==> abs(numbers[i] - numbers[j])\n                        >= threshold,\n                forall|j: int| x < j < y ==> abs(numbers_x - numbers[j]) >= threshold,\n        {\n            let numbers_y = *slice_index_get(numbers, y);  // Verus doesn't yet support `numbers[y]` in exec mode.\n            if numbers_x > numbers_y {\n                // We have to be careful to avoid overflow. For instance, we\n                // can't just check whether `numbers_x - numbers_y < threshold`\n                // because `numbers_x - numbers_y` might overflow an `i64`.\n                if numbers_y > max_minus_threshold {\n                    return true;\n                }\n                if numbers_x < numbers_y + threshold {\n                    return true;\n                }\n            } else {\n                if numbers_x > max_minus_threshold {\n                    return true;\n                }\n                if numbers_y < numbers_x + threshold {\n                    return true;\n                }\n            }\n        }\n    }\n    false\n}\n\n} // verus!\n", "x": "use vstd::math::abs;\nuse vstd::prelude::*;\nuse vstd::slice::*;\n\nverus! {\n\n/// Because Verus doesn't support floating point, we need to use integers instead.\nfn has_close_elements(numbers: &[i64], threshold: i64) -> (result: bool)\n    ensures\n        result == exists|i: int, j: int|\n            0 <= i < j < numbers@.len() && abs(numbers[i] - numbers[j]) < threshold,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n/// This function computes the net nesting level at the end of a particular `input`,\n/// where a left parenthesis increments the net nesting level and a right parenthesis\n/// decrements it.\npub open spec fn nesting_level(input: Seq<char>) -> int\n    decreases input.len(),\n{\n    if input.len() == 0 {\n        0\n    } else {\n        let prev_nesting_level = nesting_level(input.drop_last());\n        let c = input.last();\n        if c == '(' {\n            prev_nesting_level + 1\n        } else if c == ')' {\n            prev_nesting_level - 1\n        } else {\n            prev_nesting_level\n        }\n    }\n}\n\npub open spec fn is_paren_char(c: char) -> bool {\n    c == '(' || c == ')'\n}\n\n/// A sequence of characters is a balanced group of parentheses if\n/// it's non-empty, it only consists of parentheses, its nesting level\n/// is zero, and any nonempty strict prefix has a positive nesting\n/// level.\npub open spec fn is_balanced_group(input: Seq<char>) -> bool {\n    &&& input.len() > 0\n    &&& nesting_level(input) == 0\n    &&& forall|i| 0 <= i < input.len() ==> is_paren_char(#[trigger] input[i])\n    &&& forall|i| 0 < i < input.len() ==> nesting_level(#[trigger] input.take(i)) > 0\n}\n\n/// A sequence of characters is a sequence of balanced groups of\n/// parentheses if its nesting level is zero and any prefix has\n/// a non-negative nesting level.\npub open spec fn is_sequence_of_balanced_groups(input: Seq<char>) -> bool {\n    &&& nesting_level(input) == 0\n    &&& forall|i| 0 < i < input.len() ==> nesting_level(#[trigger] input.take(i)) >= 0\n}\n\npub open spec fn vecs_to_seqs<T>(s: Seq<Vec<T>>) -> Seq<Seq<T>> {\n    s.map(|_i, ss: Vec<T>| ss@)\n}\n\npub open spec fn remove_nonparens(s: Seq<char>) -> Seq<char> {\n    s.filter(|c| is_paren_char(c))\n}\n\n/// This proof specifies the relationship between `remove_nonparens(s.take(pos + 1))`\n/// and `remove_nonparens(s.take(pos))`.\nproof fn lemma_remove_nonparens_maintained_by_push(s: Seq<char>, pos: int)\n    requires\n        0 <= pos < s.len(),\n    ensures\n        ({\n            let s1 = remove_nonparens(s.take(pos as int));\n            let s2 = remove_nonparens(s.take((pos + 1) as int));\n            if is_paren_char(s[pos]) {\n                s2 == s1.push(s[pos])\n            } else {\n                s2 == s1\n            }\n        }),\n    decreases pos,\n{\n    reveal(Seq::filter);\n    assert(s.take((pos + 1) as int).drop_last() =~= s.take(pos as int));\n    if pos != 0 {\n        lemma_remove_nonparens_maintained_by_push(s, pos - 1);\n    }\n}\n\n/// This is the function specified at the top of the file.\nfn separate_paren_groups(input: &Vec<char>) -> (groups: Vec<Vec<char>>)\n    requires\n        is_sequence_of_balanced_groups(input@),\n    ensures\n// All groups in the result are balanced and non-nested\n\n        forall|i: int|\n            #![trigger groups[i]]\n            0 <= i < groups.len() ==> is_balanced_group(groups[i]@),\n        // The concatenation of all groups in the result equals the input string without spaces\n        vecs_to_seqs(groups@).flatten() == remove_nonparens(input@),\n{\n    // Loop through the input one character at a time, keeping track of:\n    //\n    // `groups`: A vector of complete balanced groups found so far.\n    // `current_group`: The current, incomplete balanced group found since then.\n    let mut groups: Vec<Vec<char>> = Vec::new();\n    let mut current_group: Vec<char> = Vec::new();\n    let input_len = input.len();\n    // For proof purposes, we also keep track of some ghost state that\n    // lets us more readily reason about\n    // `vecs_to_seqs(groups@)`. Specifically, we'll maintain\n    // the invariant that `ghost_groups == vecs_to_seqs(groups@)`.\n    let ghost mut ghost_groups: Seq<Seq<char>> = Seq::empty();\n    proof {\n        assert(vecs_to_seqs(groups@) =~= ghost_groups);\n        assert(remove_nonparens(input@.take(0)) =~= Seq::<char>::empty());\n        assert(ghost_groups.flatten() + current_group@ =~= Seq::<char>::empty());\n    }\n    let mut current_nesting_level: usize = 0;\n    for pos in 0..input_len\n        invariant\n            input_len == input.len(),\n            ghost_groups == vecs_to_seqs(groups@),\n            ghost_groups.flatten() + current_group@ == remove_nonparens(input@.take(pos as int)),\n            forall|i: int|\n                #![trigger groups[i]]\n                0 <= i < ghost_groups.len() ==> is_balanced_group(ghost_groups[i]),\n            current_nesting_level == nesting_level(input@.take(pos as int)),\n            current_nesting_level == nesting_level(current_group@),\n            current_nesting_level <= pos,  // this bound lets us prove that increments can't overflow a `usize`\n            current_group@.len() == 0 <==> current_nesting_level == 0,\n            forall|i| 0 <= i < current_group@.len() ==> is_paren_char(#[trigger] current_group@[i]),\n            forall|i|\n                0 < i < current_group@.len() ==> nesting_level(#[trigger] current_group@.take(i))\n                    > 0,\n            is_sequence_of_balanced_groups(input@),\n    {\n        let ghost prev_group = current_group@;\n        let ghost prev_groups = ghost_groups;\n        let c = input[pos];\n        proof {\n            assert(input@.take((pos + 1) as int) == input@.take(pos as int).push(c));\n            assert(input@.take((pos + 1) as int).drop_last() == input@.take(pos as int));\n            lemma_remove_nonparens_maintained_by_push(input@, pos as int);\n        }\n        if c == '(' {\n            current_nesting_level = current_nesting_level + 1;\n            current_group.push('(');\n            assert(current_group@.drop_last() == prev_group);\n            assert(ghost_groups.flatten() + current_group@ =~= (ghost_groups.flatten()\n                + prev_group).push('('));\n            assert(forall|i|\n                0 < i < prev_group.len() ==> #[trigger] current_group@.take(i) == prev_group.take(\n                    i,\n                ));\n        } else if c == ')' {\n            current_nesting_level = current_nesting_level - 1;\n            current_group.push(')');\n            assert(current_group@.drop_last() == prev_group);\n            assert(ghost_groups.flatten() + current_group@ =~= (ghost_groups.flatten()\n                + prev_group).push(')'));\n            assert(forall|i|\n                0 < i < prev_group.len() ==> #[trigger] current_group@.take(i) == prev_group.take(\n                    i,\n                ));\n            // We can tell whether the current group we just assembled is balanced\n            // by checking whether `current_nesting_level` is zero. In that case,\n            // it's done and we can add it to `groups`.\n            if current_nesting_level == 0 {\n                proof {\n                    ghost_groups = ghost_groups.push(current_group@);\n                    assert(vecs_to_seqs(groups@.push(current_group)) =~= vecs_to_seqs(groups@).push(\n                        current_group@,\n                    ));\n                    assert(ghost_groups.drop_last() == prev_groups);\n                    assert(ghost_groups.flatten() =~= prev_groups.flatten() + current_group@) by {\n                        prev_groups.lemma_flatten_and_flatten_alt_are_equivalent();\n                        ghost_groups.lemma_flatten_and_flatten_alt_are_equivalent();\n                    }\n                }\n                groups.push(current_group);\n                current_group = Vec::<char>::new();\n                assert(ghost_groups.flatten() + current_group@ =~= remove_nonparens(\n                    input@.take((pos + 1) as int),\n                ));\n            }\n        }\n    }\n    assert(input@.take(input_len as int) =~= input@);\n    assert(ghost_groups.flatten() + current_group@ == ghost_groups.flatten());\n    groups\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n/// This function computes the net nesting level at the end of a particular `input`,\n/// where a left parenthesis increments the net nesting level and a right parenthesis\n/// decrements it.\npub open spec fn nesting_level(input: Seq<char>) -> int\n    decreases input.len(),\n{\n    if input.len() == 0 {\n        0\n    } else {\n        let prev_nesting_level = nesting_level(input.drop_last());\n        let c = input.last();\n        if c == '(' {\n            prev_nesting_level + 1\n        } else if c == ')' {\n            prev_nesting_level - 1\n        } else {\n            prev_nesting_level\n        }\n    }\n}\n\npub open spec fn is_paren_char(c: char) -> bool {\n    c == '(' || c == ')'\n}\n\n/// A sequence of characters is a balanced group of parentheses if\n/// it's non-empty, it only consists of parentheses, its nesting level\n/// is zero, and any nonempty strict prefix has a positive nesting\n/// level.\npub open spec fn is_balanced_group(input: Seq<char>) -> bool {\n    &&& input.len() > 0\n    &&& nesting_level(input) == 0\n    &&& forall|i| 0 <= i < input.len() ==> is_paren_char(#[trigger] input[i])\n    &&& forall|i| 0 < i < input.len() ==> nesting_level(#[trigger] input.take(i)) > 0\n}\n\n/// A sequence of characters is a sequence of balanced groups of\n/// parentheses if its nesting level is zero and any prefix has\n/// a non-negative nesting level.\npub open spec fn is_sequence_of_balanced_groups(input: Seq<char>) -> bool {\n    &&& nesting_level(input) == 0\n    &&& forall|i| 0 < i < input.len() ==> nesting_level(#[trigger] input.take(i)) >= 0\n}\n\npub open spec fn vecs_to_seqs<T>(s: Seq<Vec<T>>) -> Seq<Seq<T>> {\n    s.map(|_i, ss: Vec<T>| ss@)\n}\n\npub open spec fn remove_nonparens(s: Seq<char>) -> Seq<char> {\n    s.filter(|c| is_paren_char(c))\n}\n\n/// This proof specifies the relationship between `remove_nonparens(s.take(pos + 1))`\n/// and `remove_nonparens(s.take(pos))`.\nproof fn lemma_remove_nonparens_maintained_by_push(s: Seq<char>, pos: int)\n    requires\n        0 <= pos < s.len(),\n    ensures\n        ({\n            let s1 = remove_nonparens(s.take(pos as int));\n            let s2 = remove_nonparens(s.take((pos + 1) as int));\n            if is_paren_char(s[pos]) {\n                s2 == s1.push(s[pos])\n            } else {\n                s2 == s1\n            }\n        }),\n    decreases pos,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n/// This function computes the net nesting level at the end of a particular `input`,\n/// where a left parenthesis increments the net nesting level and a right parenthesis\n/// decrements it.\npub open spec fn nesting_level(input: Seq<char>) -> int\n    decreases input.len(),\n{\n    if input.len() == 0 {\n        0\n    } else {\n        let prev_nesting_level = nesting_level(input.drop_last());\n        let c = input.last();\n        if c == '(' {\n            prev_nesting_level + 1\n        } else if c == ')' {\n            prev_nesting_level - 1\n        } else {\n            prev_nesting_level\n        }\n    }\n}\n\npub open spec fn is_paren_char(c: char) -> bool {\n    c == '(' || c == ')'\n}\n\n/// A sequence of characters is a balanced group of parentheses if\n/// it's non-empty, it only consists of parentheses, its nesting level\n/// is zero, and any nonempty strict prefix has a positive nesting\n/// level.\npub open spec fn is_balanced_group(input: Seq<char>) -> bool {\n    &&& input.len() > 0\n    &&& nesting_level(input) == 0\n    &&& forall|i| 0 <= i < input.len() ==> is_paren_char(#[trigger] input[i])\n    &&& forall|i| 0 < i < input.len() ==> nesting_level(#[trigger] input.take(i)) > 0\n}\n\n/// A sequence of characters is a sequence of balanced groups of\n/// parentheses if its nesting level is zero and any prefix has\n/// a non-negative nesting level.\npub open spec fn is_sequence_of_balanced_groups(input: Seq<char>) -> bool {\n    &&& nesting_level(input) == 0\n    &&& forall|i| 0 < i < input.len() ==> nesting_level(#[trigger] input.take(i)) >= 0\n}\n\npub open spec fn vecs_to_seqs<T>(s: Seq<Vec<T>>) -> Seq<Seq<T>> {\n    s.map(|_i, ss: Vec<T>| ss@)\n}\n\npub open spec fn remove_nonparens(s: Seq<char>) -> Seq<char> {\n    s.filter(|c| is_paren_char(c))\n}\n\n/// This proof specifies the relationship between `remove_nonparens(s.take(pos + 1))`\n/// and `remove_nonparens(s.take(pos))`.\nproof fn lemma_remove_nonparens_maintained_by_push(s: Seq<char>, pos: int)\n    requires\n        0 <= pos < s.len(),\n    ensures\n        ({\n            let s1 = remove_nonparens(s.take(pos as int));\n            let s2 = remove_nonparens(s.take((pos + 1) as int));\n            if is_paren_char(s[pos]) {\n                s2 == s1.push(s[pos])\n            } else {\n                s2 == s1\n            }\n        }),\n    decreases pos,\n{\n    reveal(Seq::filter);\n    assert(s.take((pos + 1) as int).drop_last() =~= s.take(pos as int));\n    if pos != 0 {\n        lemma_remove_nonparens_maintained_by_push(s, pos - 1);\n    }\n}\n\n/// This is the function specified at the top of the file.\nfn separate_paren_groups(input: &Vec<char>) -> (groups: Vec<Vec<char>>)\n    requires\n        is_sequence_of_balanced_groups(input@),\n    ensures\n// All groups in the result are balanced and non-nested\n\n        forall|i: int|\n            #![trigger groups[i]]\n            0 <= i < groups.len() ==> is_balanced_group(groups[i]@),\n        // The concatenation of all groups in the result equals the input string without spaces\n        vecs_to_seqs(groups@).flatten() == remove_nonparens(input@),\n{\n    // Loop through the input one character at a time, keeping track of:\n    //\n    // `groups`: A vector of complete balanced groups found so far.\n    // `current_group`: The current, incomplete balanced group found since then.\n    let mut groups: Vec<Vec<char>> = Vec::new();\n    let mut current_group: Vec<char> = Vec::new();\n    let input_len = input.len();\n    // For proof purposes, we also keep track of some ghost state that\n    // lets us more readily reason about\n    // `vecs_to_seqs(groups@)`. Specifically, we'll maintain\n    // the invariant that `ghost_groups == vecs_to_seqs(groups@)`.\n    let ghost mut ghost_groups: Seq<Seq<char>> = Seq::empty();\n    proof {\n        assert(vecs_to_seqs(groups@) =~= ghost_groups);\n        assert(remove_nonparens(input@.take(0)) =~= Seq::<char>::empty());\n        assert(ghost_groups.flatten() + current_group@ =~= Seq::<char>::empty());\n    }\n    let mut current_nesting_level: usize = 0;\n    for pos in 0..input_len\n        invariant\n            input_len == input.len(),\n            ghost_groups == vecs_to_seqs(groups@),\n            ghost_groups.flatten() + current_group@ == remove_nonparens(input@.take(pos as int)),\n            forall|i: int|\n                #![trigger groups[i]]\n                0 <= i < ghost_groups.len() ==> is_balanced_group(ghost_groups[i]),\n            current_nesting_level == nesting_level(input@.take(pos as int)),\n            current_nesting_level == nesting_level(current_group@),\n            current_nesting_level <= pos,  // this bound lets us prove that increments can't overflow a `usize`\n            current_group@.len() == 0 <==> current_nesting_level == 0,\n            forall|i| 0 <= i < current_group@.len() ==> is_paren_char(#[trigger] current_group@[i]),\n            forall|i|\n                0 < i < current_group@.len() ==> nesting_level(#[trigger] current_group@.take(i))\n                    > 0,\n            is_sequence_of_balanced_groups(input@),\n    {\n        let ghost prev_group = current_group@;\n        let ghost prev_groups = ghost_groups;\n        let c = input[pos];\n        proof {\n            assert(input@.take((pos + 1) as int) == input@.take(pos as int).push(c));\n            assert(input@.take((pos + 1) as int).drop_last() == input@.take(pos as int));\n            lemma_remove_nonparens_maintained_by_push(input@, pos as int);\n        }\n        if c == '(' {\n            current_nesting_level = current_nesting_level + 1;\n            current_group.push('(');\n            assert(current_group@.drop_last() == prev_group);\n            assert(ghost_groups.flatten() + current_group@ =~= (ghost_groups.flatten()\n                + prev_group).push('('));\n            assert(forall|i|\n                0 < i < prev_group.len() ==> #[trigger] current_group@.take(i) == prev_group.take(\n                    i,\n                ));\n        } else if c == ')' {\n            current_nesting_level = current_nesting_level - 1;\n            current_group.push(')');\n            assert(current_group@.drop_last() == prev_group);\n            assert(ghost_groups.flatten() + current_group@ =~= (ghost_groups.flatten()\n                + prev_group).push(')'));\n            assert(forall|i|\n                0 < i < prev_group.len() ==> #[trigger] current_group@.take(i) == prev_group.take(\n                    i,\n                ));\n            // We can tell whether the current group we just assembled is balanced\n            // by checking whether `current_nesting_level` is zero. In that case,\n            // it's done and we can add it to `groups`.\n            if current_nesting_level == 0 {\n                proof {\n                    ghost_groups = ghost_groups.push(current_group@);\n                    assert(vecs_to_seqs(groups@.push(current_group)) =~= vecs_to_seqs(groups@).push(\n                        current_group@,\n                    ));\n                    assert(ghost_groups.drop_last() == prev_groups);\n                    assert(ghost_groups.flatten() =~= prev_groups.flatten() + current_group@) by {\n                        prev_groups.lemma_flatten_and_flatten_alt_are_equivalent();\n                        ghost_groups.lemma_flatten_and_flatten_alt_are_equivalent();\n                    }\n                }\n                groups.push(current_group);\n                current_group = Vec::<char>::new();\n                assert(ghost_groups.flatten() + current_group@ =~= remove_nonparens(\n                    input@.take((pos + 1) as int),\n                ));\n            }\n        }\n    }\n    assert(input@.take(input_len as int) =~= input@);\n    assert(ghost_groups.flatten() + current_group@ == ghost_groups.flatten());\n    groups\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n/// This function computes the net nesting level at the end of a particular `input`,\n/// where a left parenthesis increments the net nesting level and a right parenthesis\n/// decrements it.\npub open spec fn nesting_level(input: Seq<char>) -> int\n    decreases input.len(),\n{\n    if input.len() == 0 {\n        0\n    } else {\n        let prev_nesting_level = nesting_level(input.drop_last());\n        let c = input.last();\n        if c == '(' {\n            prev_nesting_level + 1\n        } else if c == ')' {\n            prev_nesting_level - 1\n        } else {\n            prev_nesting_level\n        }\n    }\n}\n\npub open spec fn is_paren_char(c: char) -> bool {\n    c == '(' || c == ')'\n}\n\n/// A sequence of characters is a balanced group of parentheses if\n/// it's non-empty, it only consists of parentheses, its nesting level\n/// is zero, and any nonempty strict prefix has a positive nesting\n/// level.\npub open spec fn is_balanced_group(input: Seq<char>) -> bool {\n    &&& input.len() > 0\n    &&& nesting_level(input) == 0\n    &&& forall|i| 0 <= i < input.len() ==> is_paren_char(#[trigger] input[i])\n    &&& forall|i| 0 < i < input.len() ==> nesting_level(#[trigger] input.take(i)) > 0\n}\n\n/// A sequence of characters is a sequence of balanced groups of\n/// parentheses if its nesting level is zero and any prefix has\n/// a non-negative nesting level.\npub open spec fn is_sequence_of_balanced_groups(input: Seq<char>) -> bool {\n    &&& nesting_level(input) == 0\n    &&& forall|i| 0 < i < input.len() ==> nesting_level(#[trigger] input.take(i)) >= 0\n}\n\npub open spec fn vecs_to_seqs<T>(s: Seq<Vec<T>>) -> Seq<Seq<T>> {\n    s.map(|_i, ss: Vec<T>| ss@)\n}\n\npub open spec fn remove_nonparens(s: Seq<char>) -> Seq<char> {\n    s.filter(|c| is_paren_char(c))\n}\n\n/// This proof specifies the relationship between `remove_nonparens(s.take(pos + 1))`\n/// and `remove_nonparens(s.take(pos))`.\nproof fn lemma_remove_nonparens_maintained_by_push(s: Seq<char>, pos: int)\n    requires\n        0 <= pos < s.len(),\n    ensures\n        ({\n            let s1 = remove_nonparens(s.take(pos as int));\n            let s2 = remove_nonparens(s.take((pos + 1) as int));\n            if is_paren_char(s[pos]) {\n                s2 == s1.push(s[pos])\n            } else {\n                s2 == s1\n            }\n        }),\n    decreases pos,\n{\n    reveal(Seq::filter);\n    assert(s.take((pos + 1) as int).drop_last() =~= s.take(pos as int));\n    if pos != 0 {\n        lemma_remove_nonparens_maintained_by_push(s, pos - 1);\n    }\n}\n\n/// This is the function specified at the top of the file.\nfn separate_paren_groups(input: &Vec<char>) -> (groups: Vec<Vec<char>>)\n    requires\n        is_sequence_of_balanced_groups(input@),\n    ensures\n// All groups in the result are balanced and non-nested\n\n        forall|i: int|\n            #![trigger groups[i]]\n            0 <= i < groups.len() ==> is_balanced_group(groups[i]@),\n        // The concatenation of all groups in the result equals the input string without spaces\n        vecs_to_seqs(groups@).flatten() == remove_nonparens(input@),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// This function is part of the specification\npub open spec fn sum(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.skip(1))\n    }\n}\n\n// This function is used by the proof\npub open spec fn sum_other_way(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[s.len() - 1] + sum_other_way(s.take(s.len() - 1))\n    }\n}\n\nproof fn lemma_sum_equals_sum_other_way(s: Seq<int>)\n    ensures\n        sum(s) == sum_other_way(s),\n    decreases s.len(),\n{\n    if s.len() == 1 {\n        assert(sum(s.skip(1)) == 0);\n        assert(sum_other_way(s.take(s.len() - 1)) == 0);\n    } else if s.len() > 1 {\n        let ss = s.skip(1);\n        lemma_sum_equals_sum_other_way(ss);\n        assert(sum_other_way(ss) == ss[ss.len() - 1] + sum_other_way(ss.take(ss.len() - 1)));\n        lemma_sum_equals_sum_other_way(ss.take(ss.len() - 1));\n        assert(ss.take(ss.len() - 1) == s.take(s.len() - 1).skip(1));\n        lemma_sum_equals_sum_other_way(s.take(s.len() - 1));\n    }\n}\n\nfn below_zero(operations: Vec<i32>) -> (result: bool)\n    requires\n        forall|i: int|\n            0 <= i <= operations@.len() ==> sum(operations@.take(i).map(|_idx, j: i32| j as int))\n                <= i32::MAX,\n    ensures\n        result <==> exists|i: int|\n            0 <= i <= operations@.len() && sum(operations@.take(i).map(|_idx, j: i32| j as int))\n                < 0,\n{\n    let mut s = 0i32;\n    for k in 0..operations.len()\n        invariant\n            s == sum(operations@.take(k as int).map(|_idx, j: i32| j as int)),\n            forall|i: int|\n                0 <= i <= operations@.len() ==> sum(\n                    operations@.take(i).map(|_idx, j: i32| j as int),\n                ) <= i32::MAX,\n            forall|i: int|\n                0 <= i <= k ==> sum(operations@.take(i).map(|_idx, j: i32| j as int)) >= 0,\n    {\n        assert(s + operations@[k as int] == sum(\n            operations@.take(k + 1).map(|_idx, j: i32| j as int),\n        )) by {\n            let q1 = operations@.take(k as int).map(|_idx, j: i32| j as int);\n            let q2 = operations@.take(k + 1).map(|_idx, j: i32| j as int);\n            assert(q2[q2.len() - 1] == operations@[k as int] as int);\n            assert(q2.take(q2.len() - 1) == q1);\n            lemma_sum_equals_sum_other_way(q1);\n            lemma_sum_equals_sum_other_way(q2);\n        }\n        s = s + operations[k];\n        if s < 0 {\n            return true;\n        }\n    }\n    false\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// This function is part of the specification\npub open spec fn sum(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.skip(1))\n    }\n}\n\n// This function is used by the proof\npub open spec fn sum_other_way(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[s.len() - 1] + sum_other_way(s.take(s.len() - 1))\n    }\n}\n\nproof fn lemma_sum_equals_sum_other_way(s: Seq<int>)\n    ensures\n        sum(s) == sum_other_way(s),\n    decreases s.len(),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// This function is part of the specification\npub open spec fn sum(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.skip(1))\n    }\n}\n\n// This function is used by the proof\npub open spec fn sum_other_way(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[s.len() - 1] + sum_other_way(s.take(s.len() - 1))\n    }\n}\n\nproof fn lemma_sum_equals_sum_other_way(s: Seq<int>)\n    ensures\n        sum(s) == sum_other_way(s),\n    decreases s.len(),\n{\n    if s.len() == 1 {\n        assert(sum(s.skip(1)) == 0);\n        assert(sum_other_way(s.take(s.len() - 1)) == 0);\n    } else if s.len() > 1 {\n        let ss = s.skip(1);\n        lemma_sum_equals_sum_other_way(ss);\n        assert(sum_other_way(ss) == ss[ss.len() - 1] + sum_other_way(ss.take(ss.len() - 1)));\n        lemma_sum_equals_sum_other_way(ss.take(ss.len() - 1));\n        assert(ss.take(ss.len() - 1) == s.take(s.len() - 1).skip(1));\n        lemma_sum_equals_sum_other_way(s.take(s.len() - 1));\n    }\n}\n\nfn below_zero(operations: Vec<i32>) -> (result: bool)\n    requires\n        forall|i: int|\n            0 <= i <= operations@.len() ==> sum(operations@.take(i).map(|_idx, j: i32| j as int))\n                <= i32::MAX,\n    ensures\n        result <==> exists|i: int|\n            0 <= i <= operations@.len() && sum(operations@.take(i).map(|_idx, j: i32| j as int))\n                < 0,\n{\n    let mut s = 0i32;\n    for k in 0..operations.len()\n        invariant\n            s == sum(operations@.take(k as int).map(|_idx, j: i32| j as int)),\n            forall|i: int|\n                0 <= i <= operations@.len() ==> sum(\n                    operations@.take(i).map(|_idx, j: i32| j as int),\n                ) <= i32::MAX,\n            forall|i: int|\n                0 <= i <= k ==> sum(operations@.take(i).map(|_idx, j: i32| j as int)) >= 0,\n    {\n        assert(s + operations@[k as int] == sum(\n            operations@.take(k + 1).map(|_idx, j: i32| j as int),\n        )) by {\n            let q1 = operations@.take(k as int).map(|_idx, j: i32| j as int);\n            let q2 = operations@.take(k + 1).map(|_idx, j: i32| j as int);\n            assert(q2[q2.len() - 1] == operations@[k as int] as int);\n            assert(q2.take(q2.len() - 1) == q1);\n            lemma_sum_equals_sum_other_way(q1);\n            lemma_sum_equals_sum_other_way(q2);\n        }\n        s = s + operations[k];\n        if s < 0 {\n            return true;\n        }\n    }\n    false\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// This function is part of the specification\npub open spec fn sum(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.skip(1))\n    }\n}\n\n// This function is used by the proof\npub open spec fn sum_other_way(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[s.len() - 1] + sum_other_way(s.take(s.len() - 1))\n    }\n}\n\nproof fn lemma_sum_equals_sum_other_way(s: Seq<int>)\n    ensures\n        sum(s) == sum_other_way(s),\n    decreases s.len(),\n{\n    if s.len() == 1 {\n        assert(sum(s.skip(1)) == 0);\n        assert(sum_other_way(s.take(s.len() - 1)) == 0);\n    } else if s.len() > 1 {\n        let ss = s.skip(1);\n        lemma_sum_equals_sum_other_way(ss);\n        assert(sum_other_way(ss) == ss[ss.len() - 1] + sum_other_way(ss.take(ss.len() - 1)));\n        lemma_sum_equals_sum_other_way(ss.take(ss.len() - 1));\n        assert(ss.take(ss.len() - 1) == s.take(s.len() - 1).skip(1));\n        lemma_sum_equals_sum_other_way(s.take(s.len() - 1));\n    }\n}\n\nfn below_zero(operations: Vec<i32>) -> (result: bool)\n    requires\n        forall|i: int|\n            0 <= i <= operations@.len() ==> sum(operations@.take(i).map(|_idx, j: i32| j as int))\n                <= i32::MAX,\n    ensures\n        result <==> exists|i: int|\n            0 <= i <= operations@.len() && sum(operations@.take(i).map(|_idx, j: i32| j as int))\n                < 0,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// This function is part of the specification\npub open spec fn sum(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.skip(1))\n    }\n}\n\n// This function is also part of the specification\npub open spec fn first_n(s: Seq<i32>, n: int) -> Seq<int> {\n    s.take(n).map(|_idx, j: i32| j as int)\n}\n\n// This function is used by the proof\npub open spec fn sum_other_way(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s.last() + sum_other_way(s.drop_last())\n    }\n}\n\nproof fn lemma_sum_equals_sum_other_way(s: Seq<int>)\n    ensures\n        sum(s) == sum_other_way(s),\n    decreases s.len(),\n{\n    if s.len() == 1 {\n        assert(sum(s.skip(1)) == 0);\n        assert(sum_other_way(s.drop_last()) == 0);\n    } else if s.len() > 1 {\n        let ss = s.skip(1);\n        lemma_sum_equals_sum_other_way(ss);\n        assert(sum_other_way(ss) == ss.last() + sum_other_way(ss.drop_last()));\n        lemma_sum_equals_sum_other_way(ss.drop_last());\n        assert(ss.drop_last() == s.drop_last().skip(1));\n        lemma_sum_equals_sum_other_way(s.drop_last());\n    }\n}\n\nfn below_zero(operations: Vec<i32>) -> (result: bool)\n    ensures\n        result <==> exists|i: int|\n            0 <= i <= operations@.len() && #[trigger] sum(first_n(operations@, i)) < 0,\n{\n    let mut s = 0i32;\n    let mut num_overflows: usize = 0;\n    let ghost max_plus = i32::MAX + 1;\n    for k in 0..operations.len()\n        invariant\n            num_overflows <= k,\n            max_plus == i32::MAX + 1,\n            s >= 0,\n            s + num_overflows * max_plus == sum(first_n(operations@, k as int)),\n            forall|i: int| 0 <= i <= k ==> #[trigger] sum(first_n(operations@, i)) >= 0,\n    {\n        assert(sum(first_n(operations@, k as int)) + operations@[k as int] == sum(\n            first_n(operations@, k + 1),\n        )) by {\n            let q1 = first_n(operations@, k as int);\n            let q2 = first_n(operations@, k + 1);\n            assert(q2.last() == operations@[k as int] as int);\n            assert(q2.drop_last() == q1);\n            lemma_sum_equals_sum_other_way(q1);\n            lemma_sum_equals_sum_other_way(q2);\n        }\n        let op = operations[k];\n        if op >= 0 {\n            if s > i32::MAX - op {\n                s += op - i32::MAX - 1;\n                num_overflows += 1;\n            } else {\n                s += op;\n            }\n        } else {\n            s += op;\n            if s < 0 {\n                if num_overflows == 0 {\n                    return true;\n                }\n                num_overflows -= 1;\n                s = s + i32::MAX + 1;\n            }\n        }\n    }\n    false\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// This function is part of the specification\npub open spec fn sum(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.skip(1))\n    }\n}\n\n// This function is also part of the specification\npub open spec fn first_n(s: Seq<i32>, n: int) -> Seq<int> {\n    s.take(n).map(|_idx, j: i32| j as int)\n}\n\n// This function is used by the proof\npub open spec fn sum_other_way(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s.last() + sum_other_way(s.drop_last())\n    }\n}\n\nproof fn lemma_sum_equals_sum_other_way(s: Seq<int>)\n    ensures\n        sum(s) == sum_other_way(s),\n    decreases s.len(),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// This function is part of the specification\npub open spec fn sum(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.skip(1))\n    }\n}\n\n// This function is also part of the specification\npub open spec fn first_n(s: Seq<i32>, n: int) -> Seq<int> {\n    s.take(n).map(|_idx, j: i32| j as int)\n}\n\n// This function is used by the proof\npub open spec fn sum_other_way(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s.last() + sum_other_way(s.drop_last())\n    }\n}\n\nproof fn lemma_sum_equals_sum_other_way(s: Seq<int>)\n    ensures\n        sum(s) == sum_other_way(s),\n    decreases s.len(),\n{\n    if s.len() == 1 {\n        assert(sum(s.skip(1)) == 0);\n        assert(sum_other_way(s.drop_last()) == 0);\n    } else if s.len() > 1 {\n        let ss = s.skip(1);\n        lemma_sum_equals_sum_other_way(ss);\n        assert(sum_other_way(ss) == ss.last() + sum_other_way(ss.drop_last()));\n        lemma_sum_equals_sum_other_way(ss.drop_last());\n        assert(ss.drop_last() == s.drop_last().skip(1));\n        lemma_sum_equals_sum_other_way(s.drop_last());\n    }\n}\n\nfn below_zero(operations: Vec<i32>) -> (result: bool)\n    ensures\n        result <==> exists|i: int|\n            0 <= i <= operations@.len() && #[trigger] sum(first_n(operations@, i)) < 0,\n{\n    let mut s = 0i32;\n    let mut num_overflows: usize = 0;\n    let ghost max_plus = i32::MAX + 1;\n    for k in 0..operations.len()\n        invariant\n            num_overflows <= k,\n            max_plus == i32::MAX + 1,\n            s >= 0,\n            s + num_overflows * max_plus == sum(first_n(operations@, k as int)),\n            forall|i: int| 0 <= i <= k ==> #[trigger] sum(first_n(operations@, i)) >= 0,\n    {\n        assert(sum(first_n(operations@, k as int)) + operations@[k as int] == sum(\n            first_n(operations@, k + 1),\n        )) by {\n            let q1 = first_n(operations@, k as int);\n            let q2 = first_n(operations@, k + 1);\n            assert(q2.last() == operations@[k as int] as int);\n            assert(q2.drop_last() == q1);\n            lemma_sum_equals_sum_other_way(q1);\n            lemma_sum_equals_sum_other_way(q2);\n        }\n        let op = operations[k];\n        if op >= 0 {\n            if s > i32::MAX - op {\n                s += op - i32::MAX - 1;\n                num_overflows += 1;\n            } else {\n                s += op;\n            }\n        } else {\n            s += op;\n            if s < 0 {\n                if num_overflows == 0 {\n                    return true;\n                }\n                num_overflows -= 1;\n                s = s + i32::MAX + 1;\n            }\n        }\n    }\n    false\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// This function is part of the specification\npub open spec fn sum(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s[0] + sum(s.skip(1))\n    }\n}\n\n// This function is also part of the specification\npub open spec fn first_n(s: Seq<i32>, n: int) -> Seq<int> {\n    s.take(n).map(|_idx, j: i32| j as int)\n}\n\n// This function is used by the proof\npub open spec fn sum_other_way(s: Seq<int>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s.last() + sum_other_way(s.drop_last())\n    }\n}\n\nproof fn lemma_sum_equals_sum_other_way(s: Seq<int>)\n    ensures\n        sum(s) == sum_other_way(s),\n    decreases s.len(),\n{\n    if s.len() == 1 {\n        assert(sum(s.skip(1)) == 0);\n        assert(sum_other_way(s.drop_last()) == 0);\n    } else if s.len() > 1 {\n        let ss = s.skip(1);\n        lemma_sum_equals_sum_other_way(ss);\n        assert(sum_other_way(ss) == ss.last() + sum_other_way(ss.drop_last()));\n        lemma_sum_equals_sum_other_way(ss.drop_last());\n        assert(ss.drop_last() == s.drop_last().skip(1));\n        lemma_sum_equals_sum_other_way(s.drop_last());\n    }\n}\n\nfn below_zero(operations: Vec<i32>) -> (result: bool)\n    ensures\n        result <==> exists|i: int|\n            0 <= i <= operations@.len() && #[trigger] sum(first_n(operations@, i)) < 0,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(s: Seq<i64>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s.last() + sum(s.drop_last())\n    }\n}\n\nfn below_zero(operation: &[i64]) -> (r: bool)\n    ensures\n        r <==> !(forall|i: int|\n            0 <= i <= operation.len() ==> sum(#[trigger] operation@.subrange(0, i)) >= 0),\n{\n    // We use i128 since it allows us to have sufficiently large numbers without overflowing.\n    let mut s = 0i128;\n    for i in 0usize..operation.len()\n        invariant\n            s == sum(operation@.subrange(0, i as int)),\n            forall|j: int| 0 <= j <= i ==> sum(#[trigger] operation@.subrange(0, j)) >= 0,\n            i64::MIN <= s <= i64::MAX * i,\n    {\n        assert(operation@.subrange(0, i as int) =~= operation@.subrange(\n            0,\n            (i + 1) as int,\n        ).drop_last());\n        s = s + operation[i] as i128;\n        if s < 0 {\n            return true;\n        }\n    }\n    false\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum(s: Seq<i64>) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        s.last() + sum(s.drop_last())\n    }\n}\n\nfn below_zero(operation: &[i64]) -> (r: bool)\n    ensures\n        r <==> !(forall|i: int|\n            0 <= i <= operation.len() ==> sum(#[trigger] operation@.subrange(0, i)) >= 0),\n{"}
{"y": "use vstd::arithmetic::div_mod::{\n    lemma_div_is_ordered, lemma_div_is_ordered_by_denominator, lemma_div_multiples_vanish,\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse,\n};\nuse vstd::arithmetic::mul::{\n    lemma_mul_inequality, lemma_mul_is_distributive_add, lemma_mul_is_distributive_add_other_way,\n    lemma_mul_unary_negation,\n};\nuse vstd::prelude::*;\n\nverus! {\n\n// NOTE: We use i32 rather than float because of lack of support for float in Verus.\n/// Trusted specification functions\n// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<int>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n// Specification for what it means to compute the mean of a sequence of numbers\npub open spec fn mean(values: Seq<int>) -> int\n    recommends\n        values.len() > 0,\n{\n    sum(values) / (values.len() as int)\n}\n\n// Specification for what it means to compute the absolute value of a number\npub open spec fn abs(n: int) -> int {\n    if n >= 0 {\n        n\n    } else {\n        -n\n    }\n}\n\n// Specification for what it means to compute the mean absolute deviation of a sequence of numbers\npub open spec fn spec_mean_absolute_deviation(numbers: Seq<int>) -> int\n    recommends\n        numbers.len() > 0,\n{\n    let avg = mean(numbers);\n    sum(numbers.map(|_index, n: int| abs(n - avg))) / (numbers.len() as int)\n}\n\n/// Lemmas used in proving correctness\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, then their\n// sum is between `numbers.len() * min` and `numbers.len() * max`\n// inclusive.\nproof fn lemma_sum_bound(numbers: Seq<int>, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n    ensures\n        numbers.len() * min <= sum(numbers) <= numbers.len() * max,\n    decreases numbers.len(),\n{\n    if numbers.len() != 0 {\n        lemma_sum_bound(numbers.drop_last(), min, max);\n        lemma_mul_is_distributive_add_other_way(min, numbers.len() - 1, 1);\n        lemma_mul_is_distributive_add_other_way(max, numbers.len() - 1, 1);\n    }\n}\n\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, and if\n// certain other conditions apply, then their sum divided by\n// `denominator` is between `min` and `max` inclusive. Those\n// conditions are that `denominator >= numbers.len()`, `denominator >\n// 0`, `min <= 0`, and `max >= 0`.\nproof fn lemma_sum_ratio_bound(numbers: Seq<int>, denominator: int, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n        denominator >= numbers.len(),\n        denominator > 0,\n        min <= 0,\n        max >= 0,\n    ensures\n        min <= sum(numbers) / denominator <= max,\n{\n    lemma_sum_bound(numbers, min, max);\n    assert(denominator * min <= numbers.len() * min) by {\n        lemma_mul_unary_negation(denominator, -min);\n        lemma_mul_unary_negation(numbers.len() as int, -min);\n        lemma_mul_inequality(numbers.len() as int, denominator, -min);\n    }\n    assert(numbers.len() * max <= denominator * max) by {\n        lemma_mul_inequality(numbers.len() as int, denominator, max);\n    }\n    lemma_div_multiples_vanish(min, denominator);\n    lemma_div_multiples_vanish(max, denominator);\n    lemma_div_is_ordered(denominator * min, sum(numbers), denominator);\n    lemma_div_is_ordered(sum(numbers), denominator * max, denominator);\n}\n\n// This lemma shows that the sum of the first `i + 1` elements of\n// a sequence `s` is equal to the sum of the first `i` elements plus\n// the `i`th element.\nproof fn lemma_how_to_update_running_sum(s: Seq<int>, i: int)\n    requires\n        0 <= i < s.len(),\n    ensures\n        sum(s.take(i + 1)) == sum(s.take(i)) + s[i],\n{\n    let q1 = s.take(i);\n    let q2 = s.take(i + 1);\n    assert(q2.last() == s[i]);\n    assert(q2.drop_last() == q1);\n}\n\n// This lemma describes an algorithm for computing `(x + y) / d` and\n// `(x + y) % d` given five inputs `d`, `x / d`, `x % d`, `y / d`, and\n// `y % d`.\nproof fn lemma_how_to_add_then_divide(x: int, y: int, d: int)\n    requires\n        d > 0,\n    ensures\n        if (x % d) + (y % d) >= d {\n            &&& (x + y) / d == (x / d) + (y / d) + 1\n            &&& (x + y) % d == (x % d) + (y % d) - d\n        } else {\n            &&& (x + y) / d == (x / d) + (y / d)\n            &&& (x + y) % d == (x % d) + (y % d)\n        },\n{\n    lemma_fundamental_div_mod(x, d);\n    lemma_fundamental_div_mod(y, d);\n    lemma_mul_is_distributive_add(d, x / d, y / d);\n    if (x % d) + (y % d) >= d {\n        lemma_mul_is_distributive_add(d, (x / d) + (y / d), 1);\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d) + 1, (x % d) + (y % d) - d);\n    } else {\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d), (x % d) + (y % d));\n    }\n}\n\n// This function describes consequences of dividing by 2 or more.\n// Specifically, it says that if `x > 0`, then `x / d < x`. And if `x\n// < 0` then `x / d < 0`.\nproof fn lemma_effect_of_dividing_by_two_or_more(x: int, d: int)\n    requires\n        d >= 2,\n    ensures\n        x > 0 ==> x / d < x,\n        x < 0 ==> x / d < 0,\n{\n    lemma_fundamental_div_mod(x, d);\n    if x > 0 {\n        lemma_div_is_ordered_by_denominator(x, 2, d);\n    }\n}\n\n/// Subroutines used by target function\n// This function divides an `i32` by a `u32` and returns the quotient\n// and remainder. You need this because Verus doesn't support using\n// the `/` and `%` operator on negative numbers. And even if it did,\n// the Rust versions of `/` of `%` produce \"wrong\" results for\n// negative numbers. That is, Rust rounds towards zero rather than\n// computing mathematical quotient and remainder.\nfn divide_i32_by_u32(x: i32, d: u32) -> (qr: (i32, u32))\n    requires\n        d > 0,\n    ensures\n        ({\n            let (q, r) = qr;\n            q == x as int / d as int && r == x as int % d as int\n        }),\n{\n    // The easy case is when `x` is non-negative.\n    if x >= 0 {\n        return ((x as u32 / d) as i32, x as u32 % d);\n    }\n    // When `x` is negative, compute `-x` as a `u32`. This is a bit\n    // tricky because of the special case `i32::MIN`.\n\n    let neg_x: u32;\n    if x == i32::MIN {\n        if d == 1 {\n            // If `x == i32::MIN` and `d == 1`, the algorithm below\n            // won't work, so we special-case it here.\n            return (x, 0);\n        } else {\n            // For the special case `x == i32::MIN`, we can't negate\n            // it (because `-i32::MIN` isn't a valid `i32`). But we\n            // can just directly assign the constant value of\n            // `-i32::MIN` to a `u32`.\n            neg_x = 0x80000000u32;\n        }\n    } else {\n        neg_x = (-x) as u32;\n    }\n    assert(neg_x == -x);\n\n    // Compute `(-x) / d` and `(-x) % d`. We can do this because `-x`\n    // is non-negative and Verus supports dividing non-negative\n    // numbers.\n\n    let neg_x_div_d = neg_x / d;\n    let neg_x_mod_d = neg_x % d;\n\n    // Prove some useful things about `(-x) / d` and `(-x) % d`.\n\n    assert(neg_x == d * neg_x_div_d + neg_x_mod_d) by {\n        lemma_fundamental_div_mod(neg_x as int, d as int);\n    }\n    assert(neg_x_div_d <= i32::MAX) by {\n        if x == i32::MIN {\n            lemma_mul_inequality(2, d as int, neg_x_div_d as int);\n        }\n    }\n    // There are two cases to consider. Case 1 is when `(-x) % d ==\n    // 0`. Case 2 is when it's positive.\n\n    if neg_x_mod_d == 0 {\n        proof {\n            lemma_mul_unary_negation(d as int, neg_x_div_d as int);\n            assert(x == d * -neg_x_div_d);\n            lemma_fundamental_div_mod_converse(x as int, d as int, -(neg_x_div_d as int), 0int);\n        }\n        (-(neg_x_div_d as i32), 0u32)\n    } else {\n        proof {\n            lemma_mul_unary_negation(d as int, (neg_x_div_d + 1) as int);\n            lemma_mul_is_distributive_add(d as int, neg_x_div_d as int, 1);\n            assert(x == d as int * (-neg_x_div_d - 1) + (d - neg_x_mod_d) as int);\n            lemma_fundamental_div_mod_converse(\n                x as int,\n                d as int,\n                -(neg_x_div_d as int) - 1,\n                (d - neg_x_mod_d) as int,\n            );\n        }\n        (-(neg_x_div_d as i32) - 1, d - neg_x_mod_d)\n    }\n}\n\n// This function divides an `i32` by a `usize` and returns the\n// quotient and remainder. You need this because Verus doesn't support\n// using the `/` and `%` operator on negative numbers. And even if it\n// did, the Rust versions of `/` of `%` produce \"wrong\" results for\n// negative numbers. That is, Rust rounds towards zero rather than\n// computing mathematical quotient and remainder.\nfn divide_i32_by_usize(x: i32, d: usize) -> (qr: (i32, usize))\n    requires\n        d > 0,\n    ensures\n        ({\n            let (q, r) = qr;\n            q == x as int / d as int && r == x as int % d as int\n        }),\n{\n    // There are three cases to consider:\n    //\n    // (1) `d <= u32::MAX`, so we can compute it by calling\n    // `divide_i32_by_u32`.\n    //\n    // (2) `d > u32::MAX` and `x >= 0`, so we know that the\n    // quotient and remainder are just `0` and `x`.\n    //\n    // (3) `d > u32::MAX` and `x < 0`, so we know that the\n    // quotient and remainder are `-1` and `d + x`.\n    if d <= u32::MAX as usize {\n        let (q, r) = divide_i32_by_u32(x, d as u32);\n        (q, r as usize)\n    } else if x >= 0 {\n        assert(0 == x as int / d as int && x == x as int % d as int) by {\n            lemma_fundamental_div_mod_converse(x as int, d as int, 0, x as int);\n        }\n        (0, x as usize)\n    } else {\n        assert(-1 == x as int / d as int && d + x == x as int % d as int) by {\n            lemma_fundamental_div_mod_converse(x as int, d as int, -1, d + x);\n        }\n        // The remainder is `d + x`, but we can't directly add those\n        // two values because we can't cast them to the same type. So instead\n        // we compute `-x` then use subtraction to compute `d - (-x)`.\n\n        let neg_x: usize = if x == i32::MIN {\n            0x80000000usize\n        } else {\n            (-x) as usize\n        };\n        (-1, d - neg_x)\n    }\n}\n\n// This function computes the mean of a slice of `i32`s.\nfn compute_mean_of_i32s(numbers: &[i32]) -> (result: i32)\n    requires\n        numbers.len() > 0,\n    ensures\n        result == mean(numbers@.map(|_index, n: i32| n as int)),\n{\n    // The natural way to compute the mean is to first compute the sum\n    // and then divide by the length. But this won't be verifiable\n    // because we can't prove the absence of overflow when summing the\n    // array. So instead we use the following algorithm.\n    //\n    // We iterate through the elements of the slice, keeping track of\n    // the running sum of the first elements indirectly. That is, we\n    // don't store that running sum `s` in a variable but rather we\n    // keep track of `s / numbers.len()` and `s % numbers.len()`. The\n    // former is guaranteed to fit in an `i32` and the latter is\n    // guaranteed to fit in a `usize`. We store these in the variables\n    // `quotient` and `remainder`. At the end of the loop, we return\n    // `quotient` since it's the overall sum divided by the length of\n    // the slice.\n    let ghost nums = numbers@.map(|_index, n: i32| n as int);\n    let mut quotient: i32 = 0;\n    let mut remainder: usize = 0;\n    let numbers_len: usize = numbers.len();\n    for i in 0..numbers_len\n        invariant\n            quotient == sum(nums.take(i as int)) / numbers_len as int,\n            remainder == sum(nums.take(i as int)) % numbers_len as int,\n            numbers_len == numbers.len(),\n            nums == numbers@.map(|_index, n: i32| n as int),\n    {\n        let n = numbers[i];\n\n        // Prove that:\n        //\n        // (1) We can go from the running sum of the first `i`\n        // elements to the sum of the first `i + 1` elements by adding\n        // the `i`the element.\n        //\n        // (2) The running sum divided by `numbers.len()` is bounded\n        // between `i32::MIN` and `i32::MAX`, so the running quotient\n        // can be stored in an `i32`.\n        //\n        // (3) We can update the running quotient and remainder using\n        // an algorithm that doesn't need the running sum as input.\n        // It just needs the old running quotient and remainder.\n\n        proof {\n            lemma_how_to_update_running_sum(nums, i as int);\n            lemma_sum_ratio_bound(\n                nums.take(i + 1),\n                numbers_len as int,\n                i32::MIN as int,\n                i32::MAX as int,\n            );\n            lemma_how_to_add_then_divide(sum(nums.take(i as int)), n as int, numbers_len as int);\n        }\n\n        let (q, r) = divide_i32_by_usize(n, numbers_len);\n\n        if r >= numbers_len - remainder {\n            // Prove that we won't overflow by adding one to `q`. This\n            // follows from the facts that `q == n / numbers_len`,\n            // `numbers_len >= 2`, and `q <= i32::MAX`.\n            assert(q < i32::MAX) by {\n                lemma_effect_of_dividing_by_two_or_more(n as int, numbers_len as int);\n            }\n            remainder -= (numbers_len - r);\n            quotient += (q + 1);\n        } else {\n            remainder += r;\n            quotient += q;\n        }\n    }\n    assert(nums == nums.take(nums.len() as int));\n    quotient\n}\n\n// This function computes the absolute difference between two `i32`s as a `u32`.\nfn compute_absolute_difference(x: i32, y: i32) -> (z: u32)\n    ensures\n        z == abs(x - y),\n{\n    if x >= y {\n        if y >= 0 || x < 0 {\n            (x - y) as u32\n        } else {\n            let neg_y: u32 = if y == i32::MIN {\n                0x80000000u32\n            } else {\n                (-y) as u32\n            };\n            x as u32 + neg_y\n        }\n    } else {\n        if x >= 0 || y < 0 {\n            (y - x) as u32\n        } else {\n            let neg_x: u32 = if x == i32::MIN {\n                0x80000000u32\n            } else {\n                (-x) as u32\n            };\n            y as u32 + neg_x\n        }\n    }\n}\n\n/// Target function\npub fn mean_absolute_deviation(numbers: &[i32]) -> (result: u32)\n    requires\n        numbers.len() > 0,\n    ensures\n        result == spec_mean_absolute_deviation(numbers@.map(|_index, n: i32| n as int)),\n{\n    let numbers_mean: i32 = compute_mean_of_i32s(numbers);\n    let ghost deviations = numbers@.map(|_index, n: i32| n as int).map(\n        |_index, n: int| abs(n - numbers_mean),\n    );\n\n    // The natural way to compute the mean absolute deviation is to\n    // first compute the sum and then divide by the length. But this\n    // won't be verifiable because we can't prove the absence of\n    // overflow when summing the deviations. So instead we use the\n    // following algorithm.\n    //\n    // We iterate through the elements of the slice, keeping track of\n    // the running sum of the first deviations indirectly. That is, we\n    // don't store that running sum `s` in a variable but rather we\n    // keep track of `s / numbers.len()` and `s % numbers.len()`. The\n    // former is guaranteed to fit in an `u32` and the latter is\n    // guaranteed to fit in a `usize`. We store these in the variables\n    // `quotient` and `remainder`. At the end of the loop, we return\n    // `quotient` since it's the overall sum divided by the length of\n    // the slice.\n\n    let mut quotient: u32 = 0;\n    let mut remainder: usize = 0;\n    let numbers_len: usize = numbers.len();\n    for i in 0..numbers_len\n        invariant\n            quotient == sum(deviations.take(i as int)) / numbers_len as int,\n            remainder == sum(deviations.take(i as int)) % numbers_len as int,\n            numbers_len == numbers.len(),\n            numbers_mean == mean(numbers@.map(|_index, n: i32| n as int)),\n            deviations == numbers@.map(|_index, n: i32| n as int).map(\n                |_index, n: int| abs(n - numbers_mean),\n            ),\n    {\n        let n: u32 = compute_absolute_difference(numbers[i], numbers_mean);\n\n        // Prove that:\n        //\n        // (1) We can go from the running sum of the first `i`\n        // elements to the sum of the first `i + 1` elements by adding\n        // the `i`the element.\n        //\n        // (2) The running sum divided by `numbers.len()` is bounded\n        // between `u32::MIN` and `u32::MAX`, so the running quotient\n        // can be stored in an `u32`.\n        //\n        // (3) We can update the running quotient and remainder using\n        // an algorithm that doesn't need the running sum as input.\n        // It just needs the old running quotient and remainder.\n\n        proof {\n            lemma_how_to_update_running_sum(deviations, i as int);\n            lemma_sum_ratio_bound(\n                deviations.take(i + 1),\n                numbers_len as int,\n                u32::MIN as int,\n                u32::MAX as int,\n            );\n            lemma_how_to_add_then_divide(\n                sum(deviations.take(i as int)),\n                n as int,\n                numbers_len as int,\n            );\n        }\n\n        let q: u32 = (n as usize / numbers_len) as u32;\n        let r: usize = n as usize % numbers_len;\n\n        if r >= numbers_len - remainder {\n            // Prove that we won't overflow by adding one to `q`. This\n            // follows from the facts that `q == n / numbers_len`,\n            // `numbers_len >= 2`, and `q <= u32::MAX`.\n            assert(q < u32::MAX) by {\n                lemma_effect_of_dividing_by_two_or_more(n as int, numbers_len as int);\n            }\n            remainder -= (numbers_len - r);\n            quotient += (q + 1);\n        } else {\n            remainder += r;\n            quotient += q;\n        }\n    }\n    assert(deviations == deviations.take(deviations.len() as int));\n    quotient\n}\n\n} // verus!\n", "x": "use vstd::arithmetic::div_mod::{\n    lemma_div_is_ordered, lemma_div_is_ordered_by_denominator, lemma_div_multiples_vanish,\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse,\n};\nuse vstd::arithmetic::mul::{\n    lemma_mul_inequality, lemma_mul_is_distributive_add, lemma_mul_is_distributive_add_other_way,\n    lemma_mul_unary_negation,\n};\nuse vstd::prelude::*;\n\nverus! {\n\n// NOTE: We use i32 rather than float because of lack of support for float in Verus.\n/// Trusted specification functions\n// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<int>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n// Specification for what it means to compute the mean of a sequence of numbers\npub open spec fn mean(values: Seq<int>) -> int\n    recommends\n        values.len() > 0,\n{\n    sum(values) / (values.len() as int)\n}\n\n// Specification for what it means to compute the absolute value of a number\npub open spec fn abs(n: int) -> int {\n    if n >= 0 {\n        n\n    } else {\n        -n\n    }\n}\n\n// Specification for what it means to compute the mean absolute deviation of a sequence of numbers\npub open spec fn spec_mean_absolute_deviation(numbers: Seq<int>) -> int\n    recommends\n        numbers.len() > 0,\n{\n    let avg = mean(numbers);\n    sum(numbers.map(|_index, n: int| abs(n - avg))) / (numbers.len() as int)\n}\n\n/// Lemmas used in proving correctness\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, then their\n// sum is between `numbers.len() * min` and `numbers.len() * max`\n// inclusive.\nproof fn lemma_sum_bound(numbers: Seq<int>, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n    ensures\n        numbers.len() * min <= sum(numbers) <= numbers.len() * max,\n    decreases numbers.len(),\n{"}
{"y": "use vstd::arithmetic::div_mod::{\n    lemma_div_is_ordered, lemma_div_is_ordered_by_denominator, lemma_div_multiples_vanish,\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse,\n};\nuse vstd::arithmetic::mul::{\n    lemma_mul_inequality, lemma_mul_is_distributive_add, lemma_mul_is_distributive_add_other_way,\n    lemma_mul_unary_negation,\n};\nuse vstd::prelude::*;\n\nverus! {\n\n// NOTE: We use i32 rather than float because of lack of support for float in Verus.\n/// Trusted specification functions\n// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<int>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n// Specification for what it means to compute the mean of a sequence of numbers\npub open spec fn mean(values: Seq<int>) -> int\n    recommends\n        values.len() > 0,\n{\n    sum(values) / (values.len() as int)\n}\n\n// Specification for what it means to compute the absolute value of a number\npub open spec fn abs(n: int) -> int {\n    if n >= 0 {\n        n\n    } else {\n        -n\n    }\n}\n\n// Specification for what it means to compute the mean absolute deviation of a sequence of numbers\npub open spec fn spec_mean_absolute_deviation(numbers: Seq<int>) -> int\n    recommends\n        numbers.len() > 0,\n{\n    let avg = mean(numbers);\n    sum(numbers.map(|_index, n: int| abs(n - avg))) / (numbers.len() as int)\n}\n\n/// Lemmas used in proving correctness\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, then their\n// sum is between `numbers.len() * min` and `numbers.len() * max`\n// inclusive.\nproof fn lemma_sum_bound(numbers: Seq<int>, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n    ensures\n        numbers.len() * min <= sum(numbers) <= numbers.len() * max,\n    decreases numbers.len(),\n{\n    if numbers.len() != 0 {\n        lemma_sum_bound(numbers.drop_last(), min, max);\n        lemma_mul_is_distributive_add_other_way(min, numbers.len() - 1, 1);\n        lemma_mul_is_distributive_add_other_way(max, numbers.len() - 1, 1);\n    }\n}\n\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, and if\n// certain other conditions apply, then their sum divided by\n// `denominator` is between `min` and `max` inclusive. Those\n// conditions are that `denominator >= numbers.len()`, `denominator >\n// 0`, `min <= 0`, and `max >= 0`.\nproof fn lemma_sum_ratio_bound(numbers: Seq<int>, denominator: int, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n        denominator >= numbers.len(),\n        denominator > 0,\n        min <= 0,\n        max >= 0,\n    ensures\n        min <= sum(numbers) / denominator <= max,\n{\n    lemma_sum_bound(numbers, min, max);\n    assert(denominator * min <= numbers.len() * min) by {\n        lemma_mul_unary_negation(denominator, -min);\n        lemma_mul_unary_negation(numbers.len() as int, -min);\n        lemma_mul_inequality(numbers.len() as int, denominator, -min);\n    }\n    assert(numbers.len() * max <= denominator * max) by {\n        lemma_mul_inequality(numbers.len() as int, denominator, max);\n    }\n    lemma_div_multiples_vanish(min, denominator);\n    lemma_div_multiples_vanish(max, denominator);\n    lemma_div_is_ordered(denominator * min, sum(numbers), denominator);\n    lemma_div_is_ordered(sum(numbers), denominator * max, denominator);\n}\n\n// This lemma shows that the sum of the first `i + 1` elements of\n// a sequence `s` is equal to the sum of the first `i` elements plus\n// the `i`th element.\nproof fn lemma_how_to_update_running_sum(s: Seq<int>, i: int)\n    requires\n        0 <= i < s.len(),\n    ensures\n        sum(s.take(i + 1)) == sum(s.take(i)) + s[i],\n{\n    let q1 = s.take(i);\n    let q2 = s.take(i + 1);\n    assert(q2.last() == s[i]);\n    assert(q2.drop_last() == q1);\n}\n\n// This lemma describes an algorithm for computing `(x + y) / d` and\n// `(x + y) % d` given five inputs `d`, `x / d`, `x % d`, `y / d`, and\n// `y % d`.\nproof fn lemma_how_to_add_then_divide(x: int, y: int, d: int)\n    requires\n        d > 0,\n    ensures\n        if (x % d) + (y % d) >= d {\n            &&& (x + y) / d == (x / d) + (y / d) + 1\n            &&& (x + y) % d == (x % d) + (y % d) - d\n        } else {\n            &&& (x + y) / d == (x / d) + (y / d)\n            &&& (x + y) % d == (x % d) + (y % d)\n        },\n{\n    lemma_fundamental_div_mod(x, d);\n    lemma_fundamental_div_mod(y, d);\n    lemma_mul_is_distributive_add(d, x / d, y / d);\n    if (x % d) + (y % d) >= d {\n        lemma_mul_is_distributive_add(d, (x / d) + (y / d), 1);\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d) + 1, (x % d) + (y % d) - d);\n    } else {\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d), (x % d) + (y % d));\n    }\n}\n\n// This function describes consequences of dividing by 2 or more.\n// Specifically, it says that if `x > 0`, then `x / d < x`. And if `x\n// < 0` then `x / d < 0`.\nproof fn lemma_effect_of_dividing_by_two_or_more(x: int, d: int)\n    requires\n        d >= 2,\n    ensures\n        x > 0 ==> x / d < x,\n        x < 0 ==> x / d < 0,\n{\n    lemma_fundamental_div_mod(x, d);\n    if x > 0 {\n        lemma_div_is_ordered_by_denominator(x, 2, d);\n    }\n}\n\n/// Subroutines used by target function\n// This function divides an `i32` by a `u32` and returns the quotient\n// and remainder. You need this because Verus doesn't support using\n// the `/` and `%` operator on negative numbers. And even if it did,\n// the Rust versions of `/` of `%` produce \"wrong\" results for\n// negative numbers. That is, Rust rounds towards zero rather than\n// computing mathematical quotient and remainder.\nfn divide_i32_by_u32(x: i32, d: u32) -> (qr: (i32, u32))\n    requires\n        d > 0,\n    ensures\n        ({\n            let (q, r) = qr;\n            q == x as int / d as int && r == x as int % d as int\n        }),\n{\n    // The easy case is when `x` is non-negative.\n    if x >= 0 {\n        return ((x as u32 / d) as i32, x as u32 % d);\n    }\n    // When `x` is negative, compute `-x` as a `u32`. This is a bit\n    // tricky because of the special case `i32::MIN`.\n\n    let neg_x: u32;\n    if x == i32::MIN {\n        if d == 1 {\n            // If `x == i32::MIN` and `d == 1`, the algorithm below\n            // won't work, so we special-case it here.\n            return (x, 0);\n        } else {\n            // For the special case `x == i32::MIN`, we can't negate\n            // it (because `-i32::MIN` isn't a valid `i32`). But we\n            // can just directly assign the constant value of\n            // `-i32::MIN` to a `u32`.\n            neg_x = 0x80000000u32;\n        }\n    } else {\n        neg_x = (-x) as u32;\n    }\n    assert(neg_x == -x);\n\n    // Compute `(-x) / d` and `(-x) % d`. We can do this because `-x`\n    // is non-negative and Verus supports dividing non-negative\n    // numbers.\n\n    let neg_x_div_d = neg_x / d;\n    let neg_x_mod_d = neg_x % d;\n\n    // Prove some useful things about `(-x) / d` and `(-x) % d`.\n\n    assert(neg_x == d * neg_x_div_d + neg_x_mod_d) by {\n        lemma_fundamental_div_mod(neg_x as int, d as int);\n    }\n    assert(neg_x_div_d <= i32::MAX) by {\n        if x == i32::MIN {\n            lemma_mul_inequality(2, d as int, neg_x_div_d as int);\n        }\n    }\n    // There are two cases to consider. Case 1 is when `(-x) % d ==\n    // 0`. Case 2 is when it's positive.\n\n    if neg_x_mod_d == 0 {\n        proof {\n            lemma_mul_unary_negation(d as int, neg_x_div_d as int);\n            assert(x == d * -neg_x_div_d);\n            lemma_fundamental_div_mod_converse(x as int, d as int, -(neg_x_div_d as int), 0int);\n        }\n        (-(neg_x_div_d as i32), 0u32)\n    } else {\n        proof {\n            lemma_mul_unary_negation(d as int, (neg_x_div_d + 1) as int);\n            lemma_mul_is_distributive_add(d as int, neg_x_div_d as int, 1);\n            assert(x == d as int * (-neg_x_div_d - 1) + (d - neg_x_mod_d) as int);\n            lemma_fundamental_div_mod_converse(\n                x as int,\n                d as int,\n                -(neg_x_div_d as int) - 1,\n                (d - neg_x_mod_d) as int,\n            );\n        }\n        (-(neg_x_div_d as i32) - 1, d - neg_x_mod_d)\n    }\n}\n\n// This function divides an `i32` by a `usize` and returns the\n// quotient and remainder. You need this because Verus doesn't support\n// using the `/` and `%` operator on negative numbers. And even if it\n// did, the Rust versions of `/` of `%` produce \"wrong\" results for\n// negative numbers. That is, Rust rounds towards zero rather than\n// computing mathematical quotient and remainder.\nfn divide_i32_by_usize(x: i32, d: usize) -> (qr: (i32, usize))\n    requires\n        d > 0,\n    ensures\n        ({\n            let (q, r) = qr;\n            q == x as int / d as int && r == x as int % d as int\n        }),\n{\n    // There are three cases to consider:\n    //\n    // (1) `d <= u32::MAX`, so we can compute it by calling\n    // `divide_i32_by_u32`.\n    //\n    // (2) `d > u32::MAX` and `x >= 0`, so we know that the\n    // quotient and remainder are just `0` and `x`.\n    //\n    // (3) `d > u32::MAX` and `x < 0`, so we know that the\n    // quotient and remainder are `-1` and `d + x`.\n    if d <= u32::MAX as usize {\n        let (q, r) = divide_i32_by_u32(x, d as u32);\n        (q, r as usize)\n    } else if x >= 0 {\n        assert(0 == x as int / d as int && x == x as int % d as int) by {\n            lemma_fundamental_div_mod_converse(x as int, d as int, 0, x as int);\n        }\n        (0, x as usize)\n    } else {\n        assert(-1 == x as int / d as int && d + x == x as int % d as int) by {\n            lemma_fundamental_div_mod_converse(x as int, d as int, -1, d + x);\n        }\n        // The remainder is `d + x`, but we can't directly add those\n        // two values because we can't cast them to the same type. So instead\n        // we compute `-x` then use subtraction to compute `d - (-x)`.\n\n        let neg_x: usize = if x == i32::MIN {\n            0x80000000usize\n        } else {\n            (-x) as usize\n        };\n        (-1, d - neg_x)\n    }\n}\n\n// This function computes the mean of a slice of `i32`s.\nfn compute_mean_of_i32s(numbers: &[i32]) -> (result: i32)\n    requires\n        numbers.len() > 0,\n    ensures\n        result == mean(numbers@.map(|_index, n: i32| n as int)),\n{\n    // The natural way to compute the mean is to first compute the sum\n    // and then divide by the length. But this won't be verifiable\n    // because we can't prove the absence of overflow when summing the\n    // array. So instead we use the following algorithm.\n    //\n    // We iterate through the elements of the slice, keeping track of\n    // the running sum of the first elements indirectly. That is, we\n    // don't store that running sum `s` in a variable but rather we\n    // keep track of `s / numbers.len()` and `s % numbers.len()`. The\n    // former is guaranteed to fit in an `i32` and the latter is\n    // guaranteed to fit in a `usize`. We store these in the variables\n    // `quotient` and `remainder`. At the end of the loop, we return\n    // `quotient` since it's the overall sum divided by the length of\n    // the slice.\n    let ghost nums = numbers@.map(|_index, n: i32| n as int);\n    let mut quotient: i32 = 0;\n    let mut remainder: usize = 0;\n    let numbers_len: usize = numbers.len();\n    for i in 0..numbers_len\n        invariant\n            quotient == sum(nums.take(i as int)) / numbers_len as int,\n            remainder == sum(nums.take(i as int)) % numbers_len as int,\n            numbers_len == numbers.len(),\n            nums == numbers@.map(|_index, n: i32| n as int),\n    {\n        let n = numbers[i];\n\n        // Prove that:\n        //\n        // (1) We can go from the running sum of the first `i`\n        // elements to the sum of the first `i + 1` elements by adding\n        // the `i`the element.\n        //\n        // (2) The running sum divided by `numbers.len()` is bounded\n        // between `i32::MIN` and `i32::MAX`, so the running quotient\n        // can be stored in an `i32`.\n        //\n        // (3) We can update the running quotient and remainder using\n        // an algorithm that doesn't need the running sum as input.\n        // It just needs the old running quotient and remainder.\n\n        proof {\n            lemma_how_to_update_running_sum(nums, i as int);\n            lemma_sum_ratio_bound(\n                nums.take(i + 1),\n                numbers_len as int,\n                i32::MIN as int,\n                i32::MAX as int,\n            );\n            lemma_how_to_add_then_divide(sum(nums.take(i as int)), n as int, numbers_len as int);\n        }\n\n        let (q, r) = divide_i32_by_usize(n, numbers_len);\n\n        if r >= numbers_len - remainder {\n            // Prove that we won't overflow by adding one to `q`. This\n            // follows from the facts that `q == n / numbers_len`,\n            // `numbers_len >= 2`, and `q <= i32::MAX`.\n            assert(q < i32::MAX) by {\n                lemma_effect_of_dividing_by_two_or_more(n as int, numbers_len as int);\n            }\n            remainder -= (numbers_len - r);\n            quotient += (q + 1);\n        } else {\n            remainder += r;\n            quotient += q;\n        }\n    }\n    assert(nums == nums.take(nums.len() as int));\n    quotient\n}\n\n// This function computes the absolute difference between two `i32`s as a `u32`.\nfn compute_absolute_difference(x: i32, y: i32) -> (z: u32)\n    ensures\n        z == abs(x - y),\n{\n    if x >= y {\n        if y >= 0 || x < 0 {\n            (x - y) as u32\n        } else {\n            let neg_y: u32 = if y == i32::MIN {\n                0x80000000u32\n            } else {\n                (-y) as u32\n            };\n            x as u32 + neg_y\n        }\n    } else {\n        if x >= 0 || y < 0 {\n            (y - x) as u32\n        } else {\n            let neg_x: u32 = if x == i32::MIN {\n                0x80000000u32\n            } else {\n                (-x) as u32\n            };\n            y as u32 + neg_x\n        }\n    }\n}\n\n/// Target function\npub fn mean_absolute_deviation(numbers: &[i32]) -> (result: u32)\n    requires\n        numbers.len() > 0,\n    ensures\n        result == spec_mean_absolute_deviation(numbers@.map(|_index, n: i32| n as int)),\n{\n    let numbers_mean: i32 = compute_mean_of_i32s(numbers);\n    let ghost deviations = numbers@.map(|_index, n: i32| n as int).map(\n        |_index, n: int| abs(n - numbers_mean),\n    );\n\n    // The natural way to compute the mean absolute deviation is to\n    // first compute the sum and then divide by the length. But this\n    // won't be verifiable because we can't prove the absence of\n    // overflow when summing the deviations. So instead we use the\n    // following algorithm.\n    //\n    // We iterate through the elements of the slice, keeping track of\n    // the running sum of the first deviations indirectly. That is, we\n    // don't store that running sum `s` in a variable but rather we\n    // keep track of `s / numbers.len()` and `s % numbers.len()`. The\n    // former is guaranteed to fit in an `u32` and the latter is\n    // guaranteed to fit in a `usize`. We store these in the variables\n    // `quotient` and `remainder`. At the end of the loop, we return\n    // `quotient` since it's the overall sum divided by the length of\n    // the slice.\n\n    let mut quotient: u32 = 0;\n    let mut remainder: usize = 0;\n    let numbers_len: usize = numbers.len();\n    for i in 0..numbers_len\n        invariant\n            quotient == sum(deviations.take(i as int)) / numbers_len as int,\n            remainder == sum(deviations.take(i as int)) % numbers_len as int,\n            numbers_len == numbers.len(),\n            numbers_mean == mean(numbers@.map(|_index, n: i32| n as int)),\n            deviations == numbers@.map(|_index, n: i32| n as int).map(\n                |_index, n: int| abs(n - numbers_mean),\n            ),\n    {\n        let n: u32 = compute_absolute_difference(numbers[i], numbers_mean);\n\n        // Prove that:\n        //\n        // (1) We can go from the running sum of the first `i`\n        // elements to the sum of the first `i + 1` elements by adding\n        // the `i`the element.\n        //\n        // (2) The running sum divided by `numbers.len()` is bounded\n        // between `u32::MIN` and `u32::MAX`, so the running quotient\n        // can be stored in an `u32`.\n        //\n        // (3) We can update the running quotient and remainder using\n        // an algorithm that doesn't need the running sum as input.\n        // It just needs the old running quotient and remainder.\n\n        proof {\n            lemma_how_to_update_running_sum(deviations, i as int);\n            lemma_sum_ratio_bound(\n                deviations.take(i + 1),\n                numbers_len as int,\n                u32::MIN as int,\n                u32::MAX as int,\n            );\n            lemma_how_to_add_then_divide(\n                sum(deviations.take(i as int)),\n                n as int,\n                numbers_len as int,\n            );\n        }\n\n        let q: u32 = (n as usize / numbers_len) as u32;\n        let r: usize = n as usize % numbers_len;\n\n        if r >= numbers_len - remainder {\n            // Prove that we won't overflow by adding one to `q`. This\n            // follows from the facts that `q == n / numbers_len`,\n            // `numbers_len >= 2`, and `q <= u32::MAX`.\n            assert(q < u32::MAX) by {\n                lemma_effect_of_dividing_by_two_or_more(n as int, numbers_len as int);\n            }\n            remainder -= (numbers_len - r);\n            quotient += (q + 1);\n        } else {\n            remainder += r;\n            quotient += q;\n        }\n    }\n    assert(deviations == deviations.take(deviations.len() as int));\n    quotient\n}\n\n} // verus!\n", "x": "use vstd::arithmetic::div_mod::{\n    lemma_div_is_ordered, lemma_div_is_ordered_by_denominator, lemma_div_multiples_vanish,\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse,\n};\nuse vstd::arithmetic::mul::{\n    lemma_mul_inequality, lemma_mul_is_distributive_add, lemma_mul_is_distributive_add_other_way,\n    lemma_mul_unary_negation,\n};\nuse vstd::prelude::*;\n\nverus! {\n\n// NOTE: We use i32 rather than float because of lack of support for float in Verus.\n/// Trusted specification functions\n// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<int>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n// Specification for what it means to compute the mean of a sequence of numbers\npub open spec fn mean(values: Seq<int>) -> int\n    recommends\n        values.len() > 0,\n{\n    sum(values) / (values.len() as int)\n}\n\n// Specification for what it means to compute the absolute value of a number\npub open spec fn abs(n: int) -> int {\n    if n >= 0 {\n        n\n    } else {\n        -n\n    }\n}\n\n// Specification for what it means to compute the mean absolute deviation of a sequence of numbers\npub open spec fn spec_mean_absolute_deviation(numbers: Seq<int>) -> int\n    recommends\n        numbers.len() > 0,\n{\n    let avg = mean(numbers);\n    sum(numbers.map(|_index, n: int| abs(n - avg))) / (numbers.len() as int)\n}\n\n/// Lemmas used in proving correctness\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, then their\n// sum is between `numbers.len() * min` and `numbers.len() * max`\n// inclusive.\nproof fn lemma_sum_bound(numbers: Seq<int>, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n    ensures\n        numbers.len() * min <= sum(numbers) <= numbers.len() * max,\n    decreases numbers.len(),\n{\n    if numbers.len() != 0 {\n        lemma_sum_bound(numbers.drop_last(), min, max);\n        lemma_mul_is_distributive_add_other_way(min, numbers.len() - 1, 1);\n        lemma_mul_is_distributive_add_other_way(max, numbers.len() - 1, 1);\n    }\n}\n\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, and if\n// certain other conditions apply, then their sum divided by\n// `denominator` is between `min` and `max` inclusive. Those\n// conditions are that `denominator >= numbers.len()`, `denominator >\n// 0`, `min <= 0`, and `max >= 0`.\nproof fn lemma_sum_ratio_bound(numbers: Seq<int>, denominator: int, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n        denominator >= numbers.len(),\n        denominator > 0,\n        min <= 0,\n        max >= 0,\n    ensures\n        min <= sum(numbers) / denominator <= max,\n{"}
{"y": "use vstd::arithmetic::div_mod::{\n    lemma_div_is_ordered, lemma_div_is_ordered_by_denominator, lemma_div_multiples_vanish,\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse,\n};\nuse vstd::arithmetic::mul::{\n    lemma_mul_inequality, lemma_mul_is_distributive_add, lemma_mul_is_distributive_add_other_way,\n    lemma_mul_unary_negation,\n};\nuse vstd::prelude::*;\n\nverus! {\n\n// NOTE: We use i32 rather than float because of lack of support for float in Verus.\n/// Trusted specification functions\n// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<int>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n// Specification for what it means to compute the mean of a sequence of numbers\npub open spec fn mean(values: Seq<int>) -> int\n    recommends\n        values.len() > 0,\n{\n    sum(values) / (values.len() as int)\n}\n\n// Specification for what it means to compute the absolute value of a number\npub open spec fn abs(n: int) -> int {\n    if n >= 0 {\n        n\n    } else {\n        -n\n    }\n}\n\n// Specification for what it means to compute the mean absolute deviation of a sequence of numbers\npub open spec fn spec_mean_absolute_deviation(numbers: Seq<int>) -> int\n    recommends\n        numbers.len() > 0,\n{\n    let avg = mean(numbers);\n    sum(numbers.map(|_index, n: int| abs(n - avg))) / (numbers.len() as int)\n}\n\n/// Lemmas used in proving correctness\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, then their\n// sum is between `numbers.len() * min` and `numbers.len() * max`\n// inclusive.\nproof fn lemma_sum_bound(numbers: Seq<int>, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n    ensures\n        numbers.len() * min <= sum(numbers) <= numbers.len() * max,\n    decreases numbers.len(),\n{\n    if numbers.len() != 0 {\n        lemma_sum_bound(numbers.drop_last(), min, max);\n        lemma_mul_is_distributive_add_other_way(min, numbers.len() - 1, 1);\n        lemma_mul_is_distributive_add_other_way(max, numbers.len() - 1, 1);\n    }\n}\n\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, and if\n// certain other conditions apply, then their sum divided by\n// `denominator` is between `min` and `max` inclusive. Those\n// conditions are that `denominator >= numbers.len()`, `denominator >\n// 0`, `min <= 0`, and `max >= 0`.\nproof fn lemma_sum_ratio_bound(numbers: Seq<int>, denominator: int, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n        denominator >= numbers.len(),\n        denominator > 0,\n        min <= 0,\n        max >= 0,\n    ensures\n        min <= sum(numbers) / denominator <= max,\n{\n    lemma_sum_bound(numbers, min, max);\n    assert(denominator * min <= numbers.len() * min) by {\n        lemma_mul_unary_negation(denominator, -min);\n        lemma_mul_unary_negation(numbers.len() as int, -min);\n        lemma_mul_inequality(numbers.len() as int, denominator, -min);\n    }\n    assert(numbers.len() * max <= denominator * max) by {\n        lemma_mul_inequality(numbers.len() as int, denominator, max);\n    }\n    lemma_div_multiples_vanish(min, denominator);\n    lemma_div_multiples_vanish(max, denominator);\n    lemma_div_is_ordered(denominator * min, sum(numbers), denominator);\n    lemma_div_is_ordered(sum(numbers), denominator * max, denominator);\n}\n\n// This lemma shows that the sum of the first `i + 1` elements of\n// a sequence `s` is equal to the sum of the first `i` elements plus\n// the `i`th element.\nproof fn lemma_how_to_update_running_sum(s: Seq<int>, i: int)\n    requires\n        0 <= i < s.len(),\n    ensures\n        sum(s.take(i + 1)) == sum(s.take(i)) + s[i],\n{\n    let q1 = s.take(i);\n    let q2 = s.take(i + 1);\n    assert(q2.last() == s[i]);\n    assert(q2.drop_last() == q1);\n}\n\n// This lemma describes an algorithm for computing `(x + y) / d` and\n// `(x + y) % d` given five inputs `d`, `x / d`, `x % d`, `y / d`, and\n// `y % d`.\nproof fn lemma_how_to_add_then_divide(x: int, y: int, d: int)\n    requires\n        d > 0,\n    ensures\n        if (x % d) + (y % d) >= d {\n            &&& (x + y) / d == (x / d) + (y / d) + 1\n            &&& (x + y) % d == (x % d) + (y % d) - d\n        } else {\n            &&& (x + y) / d == (x / d) + (y / d)\n            &&& (x + y) % d == (x % d) + (y % d)\n        },\n{\n    lemma_fundamental_div_mod(x, d);\n    lemma_fundamental_div_mod(y, d);\n    lemma_mul_is_distributive_add(d, x / d, y / d);\n    if (x % d) + (y % d) >= d {\n        lemma_mul_is_distributive_add(d, (x / d) + (y / d), 1);\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d) + 1, (x % d) + (y % d) - d);\n    } else {\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d), (x % d) + (y % d));\n    }\n}\n\n// This function describes consequences of dividing by 2 or more.\n// Specifically, it says that if `x > 0`, then `x / d < x`. And if `x\n// < 0` then `x / d < 0`.\nproof fn lemma_effect_of_dividing_by_two_or_more(x: int, d: int)\n    requires\n        d >= 2,\n    ensures\n        x > 0 ==> x / d < x,\n        x < 0 ==> x / d < 0,\n{\n    lemma_fundamental_div_mod(x, d);\n    if x > 0 {\n        lemma_div_is_ordered_by_denominator(x, 2, d);\n    }\n}\n\n/// Subroutines used by target function\n// This function divides an `i32` by a `u32` and returns the quotient\n// and remainder. You need this because Verus doesn't support using\n// the `/` and `%` operator on negative numbers. And even if it did,\n// the Rust versions of `/` of `%` produce \"wrong\" results for\n// negative numbers. That is, Rust rounds towards zero rather than\n// computing mathematical quotient and remainder.\nfn divide_i32_by_u32(x: i32, d: u32) -> (qr: (i32, u32))\n    requires\n        d > 0,\n    ensures\n        ({\n            let (q, r) = qr;\n            q == x as int / d as int && r == x as int % d as int\n        }),\n{\n    // The easy case is when `x` is non-negative.\n    if x >= 0 {\n        return ((x as u32 / d) as i32, x as u32 % d);\n    }\n    // When `x` is negative, compute `-x` as a `u32`. This is a bit\n    // tricky because of the special case `i32::MIN`.\n\n    let neg_x: u32;\n    if x == i32::MIN {\n        if d == 1 {\n            // If `x == i32::MIN` and `d == 1`, the algorithm below\n            // won't work, so we special-case it here.\n            return (x, 0);\n        } else {\n            // For the special case `x == i32::MIN`, we can't negate\n            // it (because `-i32::MIN` isn't a valid `i32`). But we\n            // can just directly assign the constant value of\n            // `-i32::MIN` to a `u32`.\n            neg_x = 0x80000000u32;\n        }\n    } else {\n        neg_x = (-x) as u32;\n    }\n    assert(neg_x == -x);\n\n    // Compute `(-x) / d` and `(-x) % d`. We can do this because `-x`\n    // is non-negative and Verus supports dividing non-negative\n    // numbers.\n\n    let neg_x_div_d = neg_x / d;\n    let neg_x_mod_d = neg_x % d;\n\n    // Prove some useful things about `(-x) / d` and `(-x) % d`.\n\n    assert(neg_x == d * neg_x_div_d + neg_x_mod_d) by {\n        lemma_fundamental_div_mod(neg_x as int, d as int);\n    }\n    assert(neg_x_div_d <= i32::MAX) by {\n        if x == i32::MIN {\n            lemma_mul_inequality(2, d as int, neg_x_div_d as int);\n        }\n    }\n    // There are two cases to consider. Case 1 is when `(-x) % d ==\n    // 0`. Case 2 is when it's positive.\n\n    if neg_x_mod_d == 0 {\n        proof {\n            lemma_mul_unary_negation(d as int, neg_x_div_d as int);\n            assert(x == d * -neg_x_div_d);\n            lemma_fundamental_div_mod_converse(x as int, d as int, -(neg_x_div_d as int), 0int);\n        }\n        (-(neg_x_div_d as i32), 0u32)\n    } else {\n        proof {\n            lemma_mul_unary_negation(d as int, (neg_x_div_d + 1) as int);\n            lemma_mul_is_distributive_add(d as int, neg_x_div_d as int, 1);\n            assert(x == d as int * (-neg_x_div_d - 1) + (d - neg_x_mod_d) as int);\n            lemma_fundamental_div_mod_converse(\n                x as int,\n                d as int,\n                -(neg_x_div_d as int) - 1,\n                (d - neg_x_mod_d) as int,\n            );\n        }\n        (-(neg_x_div_d as i32) - 1, d - neg_x_mod_d)\n    }\n}\n\n// This function divides an `i32` by a `usize` and returns the\n// quotient and remainder. You need this because Verus doesn't support\n// using the `/` and `%` operator on negative numbers. And even if it\n// did, the Rust versions of `/` of `%` produce \"wrong\" results for\n// negative numbers. That is, Rust rounds towards zero rather than\n// computing mathematical quotient and remainder.\nfn divide_i32_by_usize(x: i32, d: usize) -> (qr: (i32, usize))\n    requires\n        d > 0,\n    ensures\n        ({\n            let (q, r) = qr;\n            q == x as int / d as int && r == x as int % d as int\n        }),\n{\n    // There are three cases to consider:\n    //\n    // (1) `d <= u32::MAX`, so we can compute it by calling\n    // `divide_i32_by_u32`.\n    //\n    // (2) `d > u32::MAX` and `x >= 0`, so we know that the\n    // quotient and remainder are just `0` and `x`.\n    //\n    // (3) `d > u32::MAX` and `x < 0`, so we know that the\n    // quotient and remainder are `-1` and `d + x`.\n    if d <= u32::MAX as usize {\n        let (q, r) = divide_i32_by_u32(x, d as u32);\n        (q, r as usize)\n    } else if x >= 0 {\n        assert(0 == x as int / d as int && x == x as int % d as int) by {\n            lemma_fundamental_div_mod_converse(x as int, d as int, 0, x as int);\n        }\n        (0, x as usize)\n    } else {\n        assert(-1 == x as int / d as int && d + x == x as int % d as int) by {\n            lemma_fundamental_div_mod_converse(x as int, d as int, -1, d + x);\n        }\n        // The remainder is `d + x`, but we can't directly add those\n        // two values because we can't cast them to the same type. So instead\n        // we compute `-x` then use subtraction to compute `d - (-x)`.\n\n        let neg_x: usize = if x == i32::MIN {\n            0x80000000usize\n        } else {\n            (-x) as usize\n        };\n        (-1, d - neg_x)\n    }\n}\n\n// This function computes the mean of a slice of `i32`s.\nfn compute_mean_of_i32s(numbers: &[i32]) -> (result: i32)\n    requires\n        numbers.len() > 0,\n    ensures\n        result == mean(numbers@.map(|_index, n: i32| n as int)),\n{\n    // The natural way to compute the mean is to first compute the sum\n    // and then divide by the length. But this won't be verifiable\n    // because we can't prove the absence of overflow when summing the\n    // array. So instead we use the following algorithm.\n    //\n    // We iterate through the elements of the slice, keeping track of\n    // the running sum of the first elements indirectly. That is, we\n    // don't store that running sum `s` in a variable but rather we\n    // keep track of `s / numbers.len()` and `s % numbers.len()`. The\n    // former is guaranteed to fit in an `i32` and the latter is\n    // guaranteed to fit in a `usize`. We store these in the variables\n    // `quotient` and `remainder`. At the end of the loop, we return\n    // `quotient` since it's the overall sum divided by the length of\n    // the slice.\n    let ghost nums = numbers@.map(|_index, n: i32| n as int);\n    let mut quotient: i32 = 0;\n    let mut remainder: usize = 0;\n    let numbers_len: usize = numbers.len();\n    for i in 0..numbers_len\n        invariant\n            quotient == sum(nums.take(i as int)) / numbers_len as int,\n            remainder == sum(nums.take(i as int)) % numbers_len as int,\n            numbers_len == numbers.len(),\n            nums == numbers@.map(|_index, n: i32| n as int),\n    {\n        let n = numbers[i];\n\n        // Prove that:\n        //\n        // (1) We can go from the running sum of the first `i`\n        // elements to the sum of the first `i + 1` elements by adding\n        // the `i`the element.\n        //\n        // (2) The running sum divided by `numbers.len()` is bounded\n        // between `i32::MIN` and `i32::MAX`, so the running quotient\n        // can be stored in an `i32`.\n        //\n        // (3) We can update the running quotient and remainder using\n        // an algorithm that doesn't need the running sum as input.\n        // It just needs the old running quotient and remainder.\n\n        proof {\n            lemma_how_to_update_running_sum(nums, i as int);\n            lemma_sum_ratio_bound(\n                nums.take(i + 1),\n                numbers_len as int,\n                i32::MIN as int,\n                i32::MAX as int,\n            );\n            lemma_how_to_add_then_divide(sum(nums.take(i as int)), n as int, numbers_len as int);\n        }\n\n        let (q, r) = divide_i32_by_usize(n, numbers_len);\n\n        if r >= numbers_len - remainder {\n            // Prove that we won't overflow by adding one to `q`. This\n            // follows from the facts that `q == n / numbers_len`,\n            // `numbers_len >= 2`, and `q <= i32::MAX`.\n            assert(q < i32::MAX) by {\n                lemma_effect_of_dividing_by_two_or_more(n as int, numbers_len as int);\n            }\n            remainder -= (numbers_len - r);\n            quotient += (q + 1);\n        } else {\n            remainder += r;\n            quotient += q;\n        }\n    }\n    assert(nums == nums.take(nums.len() as int));\n    quotient\n}\n\n// This function computes the absolute difference between two `i32`s as a `u32`.\nfn compute_absolute_difference(x: i32, y: i32) -> (z: u32)\n    ensures\n        z == abs(x - y),\n{\n    if x >= y {\n        if y >= 0 || x < 0 {\n            (x - y) as u32\n        } else {\n            let neg_y: u32 = if y == i32::MIN {\n                0x80000000u32\n            } else {\n                (-y) as u32\n            };\n            x as u32 + neg_y\n        }\n    } else {\n        if x >= 0 || y < 0 {\n            (y - x) as u32\n        } else {\n            let neg_x: u32 = if x == i32::MIN {\n                0x80000000u32\n            } else {\n                (-x) as u32\n            };\n            y as u32 + neg_x\n        }\n    }\n}\n\n/// Target function\npub fn mean_absolute_deviation(numbers: &[i32]) -> (result: u32)\n    requires\n        numbers.len() > 0,\n    ensures\n        result == spec_mean_absolute_deviation(numbers@.map(|_index, n: i32| n as int)),\n{\n    let numbers_mean: i32 = compute_mean_of_i32s(numbers);\n    let ghost deviations = numbers@.map(|_index, n: i32| n as int).map(\n        |_index, n: int| abs(n - numbers_mean),\n    );\n\n    // The natural way to compute the mean absolute deviation is to\n    // first compute the sum and then divide by the length. But this\n    // won't be verifiable because we can't prove the absence of\n    // overflow when summing the deviations. So instead we use the\n    // following algorithm.\n    //\n    // We iterate through the elements of the slice, keeping track of\n    // the running sum of the first deviations indirectly. That is, we\n    // don't store that running sum `s` in a variable but rather we\n    // keep track of `s / numbers.len()` and `s % numbers.len()`. The\n    // former is guaranteed to fit in an `u32` and the latter is\n    // guaranteed to fit in a `usize`. We store these in the variables\n    // `quotient` and `remainder`. At the end of the loop, we return\n    // `quotient` since it's the overall sum divided by the length of\n    // the slice.\n\n    let mut quotient: u32 = 0;\n    let mut remainder: usize = 0;\n    let numbers_len: usize = numbers.len();\n    for i in 0..numbers_len\n        invariant\n            quotient == sum(deviations.take(i as int)) / numbers_len as int,\n            remainder == sum(deviations.take(i as int)) % numbers_len as int,\n            numbers_len == numbers.len(),\n            numbers_mean == mean(numbers@.map(|_index, n: i32| n as int)),\n            deviations == numbers@.map(|_index, n: i32| n as int).map(\n                |_index, n: int| abs(n - numbers_mean),\n            ),\n    {\n        let n: u32 = compute_absolute_difference(numbers[i], numbers_mean);\n\n        // Prove that:\n        //\n        // (1) We can go from the running sum of the first `i`\n        // elements to the sum of the first `i + 1` elements by adding\n        // the `i`the element.\n        //\n        // (2) The running sum divided by `numbers.len()` is bounded\n        // between `u32::MIN` and `u32::MAX`, so the running quotient\n        // can be stored in an `u32`.\n        //\n        // (3) We can update the running quotient and remainder using\n        // an algorithm that doesn't need the running sum as input.\n        // It just needs the old running quotient and remainder.\n\n        proof {\n            lemma_how_to_update_running_sum(deviations, i as int);\n            lemma_sum_ratio_bound(\n                deviations.take(i + 1),\n                numbers_len as int,\n                u32::MIN as int,\n                u32::MAX as int,\n            );\n            lemma_how_to_add_then_divide(\n                sum(deviations.take(i as int)),\n                n as int,\n                numbers_len as int,\n            );\n        }\n\n        let q: u32 = (n as usize / numbers_len) as u32;\n        let r: usize = n as usize % numbers_len;\n\n        if r >= numbers_len - remainder {\n            // Prove that we won't overflow by adding one to `q`. This\n            // follows from the facts that `q == n / numbers_len`,\n            // `numbers_len >= 2`, and `q <= u32::MAX`.\n            assert(q < u32::MAX) by {\n                lemma_effect_of_dividing_by_two_or_more(n as int, numbers_len as int);\n            }\n            remainder -= (numbers_len - r);\n            quotient += (q + 1);\n        } else {\n            remainder += r;\n            quotient += q;\n        }\n    }\n    assert(deviations == deviations.take(deviations.len() as int));\n    quotient\n}\n\n} // verus!\n", "x": "use vstd::arithmetic::div_mod::{\n    lemma_div_is_ordered, lemma_div_is_ordered_by_denominator, lemma_div_multiples_vanish,\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse,\n};\nuse vstd::arithmetic::mul::{\n    lemma_mul_inequality, lemma_mul_is_distributive_add, lemma_mul_is_distributive_add_other_way,\n    lemma_mul_unary_negation,\n};\nuse vstd::prelude::*;\n\nverus! {\n\n// NOTE: We use i32 rather than float because of lack of support for float in Verus.\n/// Trusted specification functions\n// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<int>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n// Specification for what it means to compute the mean of a sequence of numbers\npub open spec fn mean(values: Seq<int>) -> int\n    recommends\n        values.len() > 0,\n{\n    sum(values) / (values.len() as int)\n}\n\n// Specification for what it means to compute the absolute value of a number\npub open spec fn abs(n: int) -> int {\n    if n >= 0 {\n        n\n    } else {\n        -n\n    }\n}\n\n// Specification for what it means to compute the mean absolute deviation of a sequence of numbers\npub open spec fn spec_mean_absolute_deviation(numbers: Seq<int>) -> int\n    recommends\n        numbers.len() > 0,\n{\n    let avg = mean(numbers);\n    sum(numbers.map(|_index, n: int| abs(n - avg))) / (numbers.len() as int)\n}\n\n/// Lemmas used in proving correctness\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, then their\n// sum is between `numbers.len() * min` and `numbers.len() * max`\n// inclusive.\nproof fn lemma_sum_bound(numbers: Seq<int>, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n    ensures\n        numbers.len() * min <= sum(numbers) <= numbers.len() * max,\n    decreases numbers.len(),\n{\n    if numbers.len() != 0 {\n        lemma_sum_bound(numbers.drop_last(), min, max);\n        lemma_mul_is_distributive_add_other_way(min, numbers.len() - 1, 1);\n        lemma_mul_is_distributive_add_other_way(max, numbers.len() - 1, 1);\n    }\n}\n\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, and if\n// certain other conditions apply, then their sum divided by\n// `denominator` is between `min` and `max` inclusive. Those\n// conditions are that `denominator >= numbers.len()`, `denominator >\n// 0`, `min <= 0`, and `max >= 0`.\nproof fn lemma_sum_ratio_bound(numbers: Seq<int>, denominator: int, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n        denominator >= numbers.len(),\n        denominator > 0,\n        min <= 0,\n        max >= 0,\n    ensures\n        min <= sum(numbers) / denominator <= max,\n{\n    lemma_sum_bound(numbers, min, max);\n    assert(denominator * min <= numbers.len() * min) by {\n        lemma_mul_unary_negation(denominator, -min);\n        lemma_mul_unary_negation(numbers.len() as int, -min);\n        lemma_mul_inequality(numbers.len() as int, denominator, -min);\n    }\n    assert(numbers.len() * max <= denominator * max) by {\n        lemma_mul_inequality(numbers.len() as int, denominator, max);\n    }\n    lemma_div_multiples_vanish(min, denominator);\n    lemma_div_multiples_vanish(max, denominator);\n    lemma_div_is_ordered(denominator * min, sum(numbers), denominator);\n    lemma_div_is_ordered(sum(numbers), denominator * max, denominator);\n}\n\n// This lemma shows that the sum of the first `i + 1` elements of\n// a sequence `s` is equal to the sum of the first `i` elements plus\n// the `i`th element.\nproof fn lemma_how_to_update_running_sum(s: Seq<int>, i: int)\n    requires\n        0 <= i < s.len(),\n    ensures\n        sum(s.take(i + 1)) == sum(s.take(i)) + s[i],\n{"}
{"y": "use vstd::arithmetic::div_mod::{\n    lemma_div_is_ordered, lemma_div_is_ordered_by_denominator, lemma_div_multiples_vanish,\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse,\n};\nuse vstd::arithmetic::mul::{\n    lemma_mul_inequality, lemma_mul_is_distributive_add, lemma_mul_is_distributive_add_other_way,\n    lemma_mul_unary_negation,\n};\nuse vstd::prelude::*;\n\nverus! {\n\n// NOTE: We use i32 rather than float because of lack of support for float in Verus.\n/// Trusted specification functions\n// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<int>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n// Specification for what it means to compute the mean of a sequence of numbers\npub open spec fn mean(values: Seq<int>) -> int\n    recommends\n        values.len() > 0,\n{\n    sum(values) / (values.len() as int)\n}\n\n// Specification for what it means to compute the absolute value of a number\npub open spec fn abs(n: int) -> int {\n    if n >= 0 {\n        n\n    } else {\n        -n\n    }\n}\n\n// Specification for what it means to compute the mean absolute deviation of a sequence of numbers\npub open spec fn spec_mean_absolute_deviation(numbers: Seq<int>) -> int\n    recommends\n        numbers.len() > 0,\n{\n    let avg = mean(numbers);\n    sum(numbers.map(|_index, n: int| abs(n - avg))) / (numbers.len() as int)\n}\n\n/// Lemmas used in proving correctness\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, then their\n// sum is between `numbers.len() * min` and `numbers.len() * max`\n// inclusive.\nproof fn lemma_sum_bound(numbers: Seq<int>, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n    ensures\n        numbers.len() * min <= sum(numbers) <= numbers.len() * max,\n    decreases numbers.len(),\n{\n    if numbers.len() != 0 {\n        lemma_sum_bound(numbers.drop_last(), min, max);\n        lemma_mul_is_distributive_add_other_way(min, numbers.len() - 1, 1);\n        lemma_mul_is_distributive_add_other_way(max, numbers.len() - 1, 1);\n    }\n}\n\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, and if\n// certain other conditions apply, then their sum divided by\n// `denominator` is between `min` and `max` inclusive. Those\n// conditions are that `denominator >= numbers.len()`, `denominator >\n// 0`, `min <= 0`, and `max >= 0`.\nproof fn lemma_sum_ratio_bound(numbers: Seq<int>, denominator: int, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n        denominator >= numbers.len(),\n        denominator > 0,\n        min <= 0,\n        max >= 0,\n    ensures\n        min <= sum(numbers) / denominator <= max,\n{\n    lemma_sum_bound(numbers, min, max);\n    assert(denominator * min <= numbers.len() * min) by {\n        lemma_mul_unary_negation(denominator, -min);\n        lemma_mul_unary_negation(numbers.len() as int, -min);\n        lemma_mul_inequality(numbers.len() as int, denominator, -min);\n    }\n    assert(numbers.len() * max <= denominator * max) by {\n        lemma_mul_inequality(numbers.len() as int, denominator, max);\n    }\n    lemma_div_multiples_vanish(min, denominator);\n    lemma_div_multiples_vanish(max, denominator);\n    lemma_div_is_ordered(denominator * min, sum(numbers), denominator);\n    lemma_div_is_ordered(sum(numbers), denominator * max, denominator);\n}\n\n// This lemma shows that the sum of the first `i + 1` elements of\n// a sequence `s` is equal to the sum of the first `i` elements plus\n// the `i`th element.\nproof fn lemma_how_to_update_running_sum(s: Seq<int>, i: int)\n    requires\n        0 <= i < s.len(),\n    ensures\n        sum(s.take(i + 1)) == sum(s.take(i)) + s[i],\n{\n    let q1 = s.take(i);\n    let q2 = s.take(i + 1);\n    assert(q2.last() == s[i]);\n    assert(q2.drop_last() == q1);\n}\n\n// This lemma describes an algorithm for computing `(x + y) / d` and\n// `(x + y) % d` given five inputs `d`, `x / d`, `x % d`, `y / d`, and\n// `y % d`.\nproof fn lemma_how_to_add_then_divide(x: int, y: int, d: int)\n    requires\n        d > 0,\n    ensures\n        if (x % d) + (y % d) >= d {\n            &&& (x + y) / d == (x / d) + (y / d) + 1\n            &&& (x + y) % d == (x % d) + (y % d) - d\n        } else {\n            &&& (x + y) / d == (x / d) + (y / d)\n            &&& (x + y) % d == (x % d) + (y % d)\n        },\n{\n    lemma_fundamental_div_mod(x, d);\n    lemma_fundamental_div_mod(y, d);\n    lemma_mul_is_distributive_add(d, x / d, y / d);\n    if (x % d) + (y % d) >= d {\n        lemma_mul_is_distributive_add(d, (x / d) + (y / d), 1);\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d) + 1, (x % d) + (y % d) - d);\n    } else {\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d), (x % d) + (y % d));\n    }\n}\n\n// This function describes consequences of dividing by 2 or more.\n// Specifically, it says that if `x > 0`, then `x / d < x`. And if `x\n// < 0` then `x / d < 0`.\nproof fn lemma_effect_of_dividing_by_two_or_more(x: int, d: int)\n    requires\n        d >= 2,\n    ensures\n        x > 0 ==> x / d < x,\n        x < 0 ==> x / d < 0,\n{\n    lemma_fundamental_div_mod(x, d);\n    if x > 0 {\n        lemma_div_is_ordered_by_denominator(x, 2, d);\n    }\n}\n\n/// Subroutines used by target function\n// This function divides an `i32` by a `u32` and returns the quotient\n// and remainder. You need this because Verus doesn't support using\n// the `/` and `%` operator on negative numbers. And even if it did,\n// the Rust versions of `/` of `%` produce \"wrong\" results for\n// negative numbers. That is, Rust rounds towards zero rather than\n// computing mathematical quotient and remainder.\nfn divide_i32_by_u32(x: i32, d: u32) -> (qr: (i32, u32))\n    requires\n        d > 0,\n    ensures\n        ({\n            let (q, r) = qr;\n            q == x as int / d as int && r == x as int % d as int\n        }),\n{\n    // The easy case is when `x` is non-negative.\n    if x >= 0 {\n        return ((x as u32 / d) as i32, x as u32 % d);\n    }\n    // When `x` is negative, compute `-x` as a `u32`. This is a bit\n    // tricky because of the special case `i32::MIN`.\n\n    let neg_x: u32;\n    if x == i32::MIN {\n        if d == 1 {\n            // If `x == i32::MIN` and `d == 1`, the algorithm below\n            // won't work, so we special-case it here.\n            return (x, 0);\n        } else {\n            // For the special case `x == i32::MIN`, we can't negate\n            // it (because `-i32::MIN` isn't a valid `i32`). But we\n            // can just directly assign the constant value of\n            // `-i32::MIN` to a `u32`.\n            neg_x = 0x80000000u32;\n        }\n    } else {\n        neg_x = (-x) as u32;\n    }\n    assert(neg_x == -x);\n\n    // Compute `(-x) / d` and `(-x) % d`. We can do this because `-x`\n    // is non-negative and Verus supports dividing non-negative\n    // numbers.\n\n    let neg_x_div_d = neg_x / d;\n    let neg_x_mod_d = neg_x % d;\n\n    // Prove some useful things about `(-x) / d` and `(-x) % d`.\n\n    assert(neg_x == d * neg_x_div_d + neg_x_mod_d) by {\n        lemma_fundamental_div_mod(neg_x as int, d as int);\n    }\n    assert(neg_x_div_d <= i32::MAX) by {\n        if x == i32::MIN {\n            lemma_mul_inequality(2, d as int, neg_x_div_d as int);\n        }\n    }\n    // There are two cases to consider. Case 1 is when `(-x) % d ==\n    // 0`. Case 2 is when it's positive.\n\n    if neg_x_mod_d == 0 {\n        proof {\n            lemma_mul_unary_negation(d as int, neg_x_div_d as int);\n            assert(x == d * -neg_x_div_d);\n            lemma_fundamental_div_mod_converse(x as int, d as int, -(neg_x_div_d as int), 0int);\n        }\n        (-(neg_x_div_d as i32), 0u32)\n    } else {\n        proof {\n            lemma_mul_unary_negation(d as int, (neg_x_div_d + 1) as int);\n            lemma_mul_is_distributive_add(d as int, neg_x_div_d as int, 1);\n            assert(x == d as int * (-neg_x_div_d - 1) + (d - neg_x_mod_d) as int);\n            lemma_fundamental_div_mod_converse(\n                x as int,\n                d as int,\n                -(neg_x_div_d as int) - 1,\n                (d - neg_x_mod_d) as int,\n            );\n        }\n        (-(neg_x_div_d as i32) - 1, d - neg_x_mod_d)\n    }\n}\n\n// This function divides an `i32` by a `usize` and returns the\n// quotient and remainder. You need this because Verus doesn't support\n// using the `/` and `%` operator on negative numbers. And even if it\n// did, the Rust versions of `/` of `%` produce \"wrong\" results for\n// negative numbers. That is, Rust rounds towards zero rather than\n// computing mathematical quotient and remainder.\nfn divide_i32_by_usize(x: i32, d: usize) -> (qr: (i32, usize))\n    requires\n        d > 0,\n    ensures\n        ({\n            let (q, r) = qr;\n            q == x as int / d as int && r == x as int % d as int\n        }),\n{\n    // There are three cases to consider:\n    //\n    // (1) `d <= u32::MAX`, so we can compute it by calling\n    // `divide_i32_by_u32`.\n    //\n    // (2) `d > u32::MAX` and `x >= 0`, so we know that the\n    // quotient and remainder are just `0` and `x`.\n    //\n    // (3) `d > u32::MAX` and `x < 0`, so we know that the\n    // quotient and remainder are `-1` and `d + x`.\n    if d <= u32::MAX as usize {\n        let (q, r) = divide_i32_by_u32(x, d as u32);\n        (q, r as usize)\n    } else if x >= 0 {\n        assert(0 == x as int / d as int && x == x as int % d as int) by {\n            lemma_fundamental_div_mod_converse(x as int, d as int, 0, x as int);\n        }\n        (0, x as usize)\n    } else {\n        assert(-1 == x as int / d as int && d + x == x as int % d as int) by {\n            lemma_fundamental_div_mod_converse(x as int, d as int, -1, d + x);\n        }\n        // The remainder is `d + x`, but we can't directly add those\n        // two values because we can't cast them to the same type. So instead\n        // we compute `-x` then use subtraction to compute `d - (-x)`.\n\n        let neg_x: usize = if x == i32::MIN {\n            0x80000000usize\n        } else {\n            (-x) as usize\n        };\n        (-1, d - neg_x)\n    }\n}\n\n// This function computes the mean of a slice of `i32`s.\nfn compute_mean_of_i32s(numbers: &[i32]) -> (result: i32)\n    requires\n        numbers.len() > 0,\n    ensures\n        result == mean(numbers@.map(|_index, n: i32| n as int)),\n{\n    // The natural way to compute the mean is to first compute the sum\n    // and then divide by the length. But this won't be verifiable\n    // because we can't prove the absence of overflow when summing the\n    // array. So instead we use the following algorithm.\n    //\n    // We iterate through the elements of the slice, keeping track of\n    // the running sum of the first elements indirectly. That is, we\n    // don't store that running sum `s` in a variable but rather we\n    // keep track of `s / numbers.len()` and `s % numbers.len()`. The\n    // former is guaranteed to fit in an `i32` and the latter is\n    // guaranteed to fit in a `usize`. We store these in the variables\n    // `quotient` and `remainder`. At the end of the loop, we return\n    // `quotient` since it's the overall sum divided by the length of\n    // the slice.\n    let ghost nums = numbers@.map(|_index, n: i32| n as int);\n    let mut quotient: i32 = 0;\n    let mut remainder: usize = 0;\n    let numbers_len: usize = numbers.len();\n    for i in 0..numbers_len\n        invariant\n            quotient == sum(nums.take(i as int)) / numbers_len as int,\n            remainder == sum(nums.take(i as int)) % numbers_len as int,\n            numbers_len == numbers.len(),\n            nums == numbers@.map(|_index, n: i32| n as int),\n    {\n        let n = numbers[i];\n\n        // Prove that:\n        //\n        // (1) We can go from the running sum of the first `i`\n        // elements to the sum of the first `i + 1` elements by adding\n        // the `i`the element.\n        //\n        // (2) The running sum divided by `numbers.len()` is bounded\n        // between `i32::MIN` and `i32::MAX`, so the running quotient\n        // can be stored in an `i32`.\n        //\n        // (3) We can update the running quotient and remainder using\n        // an algorithm that doesn't need the running sum as input.\n        // It just needs the old running quotient and remainder.\n\n        proof {\n            lemma_how_to_update_running_sum(nums, i as int);\n            lemma_sum_ratio_bound(\n                nums.take(i + 1),\n                numbers_len as int,\n                i32::MIN as int,\n                i32::MAX as int,\n            );\n            lemma_how_to_add_then_divide(sum(nums.take(i as int)), n as int, numbers_len as int);\n        }\n\n        let (q, r) = divide_i32_by_usize(n, numbers_len);\n\n        if r >= numbers_len - remainder {\n            // Prove that we won't overflow by adding one to `q`. This\n            // follows from the facts that `q == n / numbers_len`,\n            // `numbers_len >= 2`, and `q <= i32::MAX`.\n            assert(q < i32::MAX) by {\n                lemma_effect_of_dividing_by_two_or_more(n as int, numbers_len as int);\n            }\n            remainder -= (numbers_len - r);\n            quotient += (q + 1);\n        } else {\n            remainder += r;\n            quotient += q;\n        }\n    }\n    assert(nums == nums.take(nums.len() as int));\n    quotient\n}\n\n// This function computes the absolute difference between two `i32`s as a `u32`.\nfn compute_absolute_difference(x: i32, y: i32) -> (z: u32)\n    ensures\n        z == abs(x - y),\n{\n    if x >= y {\n        if y >= 0 || x < 0 {\n            (x - y) as u32\n        } else {\n            let neg_y: u32 = if y == i32::MIN {\n                0x80000000u32\n            } else {\n                (-y) as u32\n            };\n            x as u32 + neg_y\n        }\n    } else {\n        if x >= 0 || y < 0 {\n            (y - x) as u32\n        } else {\n            let neg_x: u32 = if x == i32::MIN {\n                0x80000000u32\n            } else {\n                (-x) as u32\n            };\n            y as u32 + neg_x\n        }\n    }\n}\n\n/// Target function\npub fn mean_absolute_deviation(numbers: &[i32]) -> (result: u32)\n    requires\n        numbers.len() > 0,\n    ensures\n        result == spec_mean_absolute_deviation(numbers@.map(|_index, n: i32| n as int)),\n{\n    let numbers_mean: i32 = compute_mean_of_i32s(numbers);\n    let ghost deviations = numbers@.map(|_index, n: i32| n as int).map(\n        |_index, n: int| abs(n - numbers_mean),\n    );\n\n    // The natural way to compute the mean absolute deviation is to\n    // first compute the sum and then divide by the length. But this\n    // won't be verifiable because we can't prove the absence of\n    // overflow when summing the deviations. So instead we use the\n    // following algorithm.\n    //\n    // We iterate through the elements of the slice, keeping track of\n    // the running sum of the first deviations indirectly. That is, we\n    // don't store that running sum `s` in a variable but rather we\n    // keep track of `s / numbers.len()` and `s % numbers.len()`. The\n    // former is guaranteed to fit in an `u32` and the latter is\n    // guaranteed to fit in a `usize`. We store these in the variables\n    // `quotient` and `remainder`. At the end of the loop, we return\n    // `quotient` since it's the overall sum divided by the length of\n    // the slice.\n\n    let mut quotient: u32 = 0;\n    let mut remainder: usize = 0;\n    let numbers_len: usize = numbers.len();\n    for i in 0..numbers_len\n        invariant\n            quotient == sum(deviations.take(i as int)) / numbers_len as int,\n            remainder == sum(deviations.take(i as int)) % numbers_len as int,\n            numbers_len == numbers.len(),\n            numbers_mean == mean(numbers@.map(|_index, n: i32| n as int)),\n            deviations == numbers@.map(|_index, n: i32| n as int).map(\n                |_index, n: int| abs(n - numbers_mean),\n            ),\n    {\n        let n: u32 = compute_absolute_difference(numbers[i], numbers_mean);\n\n        // Prove that:\n        //\n        // (1) We can go from the running sum of the first `i`\n        // elements to the sum of the first `i + 1` elements by adding\n        // the `i`the element.\n        //\n        // (2) The running sum divided by `numbers.len()` is bounded\n        // between `u32::MIN` and `u32::MAX`, so the running quotient\n        // can be stored in an `u32`.\n        //\n        // (3) We can update the running quotient and remainder using\n        // an algorithm that doesn't need the running sum as input.\n        // It just needs the old running quotient and remainder.\n\n        proof {\n            lemma_how_to_update_running_sum(deviations, i as int);\n            lemma_sum_ratio_bound(\n                deviations.take(i + 1),\n                numbers_len as int,\n                u32::MIN as int,\n                u32::MAX as int,\n            );\n            lemma_how_to_add_then_divide(\n                sum(deviations.take(i as int)),\n                n as int,\n                numbers_len as int,\n            );\n        }\n\n        let q: u32 = (n as usize / numbers_len) as u32;\n        let r: usize = n as usize % numbers_len;\n\n        if r >= numbers_len - remainder {\n            // Prove that we won't overflow by adding one to `q`. This\n            // follows from the facts that `q == n / numbers_len`,\n            // `numbers_len >= 2`, and `q <= u32::MAX`.\n            assert(q < u32::MAX) by {\n                lemma_effect_of_dividing_by_two_or_more(n as int, numbers_len as int);\n            }\n            remainder -= (numbers_len - r);\n            quotient += (q + 1);\n        } else {\n            remainder += r;\n            quotient += q;\n        }\n    }\n    assert(deviations == deviations.take(deviations.len() as int));\n    quotient\n}\n\n} // verus!\n", "x": "use vstd::arithmetic::div_mod::{\n    lemma_div_is_ordered, lemma_div_is_ordered_by_denominator, lemma_div_multiples_vanish,\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse,\n};\nuse vstd::arithmetic::mul::{\n    lemma_mul_inequality, lemma_mul_is_distributive_add, lemma_mul_is_distributive_add_other_way,\n    lemma_mul_unary_negation,\n};\nuse vstd::prelude::*;\n\nverus! {\n\n// NOTE: We use i32 rather than float because of lack of support for float in Verus.\n/// Trusted specification functions\n// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<int>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n// Specification for what it means to compute the mean of a sequence of numbers\npub open spec fn mean(values: Seq<int>) -> int\n    recommends\n        values.len() > 0,\n{\n    sum(values) / (values.len() as int)\n}\n\n// Specification for what it means to compute the absolute value of a number\npub open spec fn abs(n: int) -> int {\n    if n >= 0 {\n        n\n    } else {\n        -n\n    }\n}\n\n// Specification for what it means to compute the mean absolute deviation of a sequence of numbers\npub open spec fn spec_mean_absolute_deviation(numbers: Seq<int>) -> int\n    recommends\n        numbers.len() > 0,\n{\n    let avg = mean(numbers);\n    sum(numbers.map(|_index, n: int| abs(n - avg))) / (numbers.len() as int)\n}\n\n/// Lemmas used in proving correctness\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, then their\n// sum is between `numbers.len() * min` and `numbers.len() * max`\n// inclusive.\nproof fn lemma_sum_bound(numbers: Seq<int>, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n    ensures\n        numbers.len() * min <= sum(numbers) <= numbers.len() * max,\n    decreases numbers.len(),\n{\n    if numbers.len() != 0 {\n        lemma_sum_bound(numbers.drop_last(), min, max);\n        lemma_mul_is_distributive_add_other_way(min, numbers.len() - 1, 1);\n        lemma_mul_is_distributive_add_other_way(max, numbers.len() - 1, 1);\n    }\n}\n\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, and if\n// certain other conditions apply, then their sum divided by\n// `denominator` is between `min` and `max` inclusive. Those\n// conditions are that `denominator >= numbers.len()`, `denominator >\n// 0`, `min <= 0`, and `max >= 0`.\nproof fn lemma_sum_ratio_bound(numbers: Seq<int>, denominator: int, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n        denominator >= numbers.len(),\n        denominator > 0,\n        min <= 0,\n        max >= 0,\n    ensures\n        min <= sum(numbers) / denominator <= max,\n{\n    lemma_sum_bound(numbers, min, max);\n    assert(denominator * min <= numbers.len() * min) by {\n        lemma_mul_unary_negation(denominator, -min);\n        lemma_mul_unary_negation(numbers.len() as int, -min);\n        lemma_mul_inequality(numbers.len() as int, denominator, -min);\n    }\n    assert(numbers.len() * max <= denominator * max) by {\n        lemma_mul_inequality(numbers.len() as int, denominator, max);\n    }\n    lemma_div_multiples_vanish(min, denominator);\n    lemma_div_multiples_vanish(max, denominator);\n    lemma_div_is_ordered(denominator * min, sum(numbers), denominator);\n    lemma_div_is_ordered(sum(numbers), denominator * max, denominator);\n}\n\n// This lemma shows that the sum of the first `i + 1` elements of\n// a sequence `s` is equal to the sum of the first `i` elements plus\n// the `i`th element.\nproof fn lemma_how_to_update_running_sum(s: Seq<int>, i: int)\n    requires\n        0 <= i < s.len(),\n    ensures\n        sum(s.take(i + 1)) == sum(s.take(i)) + s[i],\n{\n    let q1 = s.take(i);\n    let q2 = s.take(i + 1);\n    assert(q2.last() == s[i]);\n    assert(q2.drop_last() == q1);\n}\n\n// This lemma describes an algorithm for computing `(x + y) / d` and\n// `(x + y) % d` given five inputs `d`, `x / d`, `x % d`, `y / d`, and\n// `y % d`.\nproof fn lemma_how_to_add_then_divide(x: int, y: int, d: int)\n    requires\n        d > 0,\n    ensures\n        if (x % d) + (y % d) >= d {\n            &&& (x + y) / d == (x / d) + (y / d) + 1\n            &&& (x + y) % d == (x % d) + (y % d) - d\n        } else {\n            &&& (x + y) / d == (x / d) + (y / d)\n            &&& (x + y) % d == (x % d) + (y % d)\n        },\n{"}
{"y": "use vstd::arithmetic::div_mod::{\n    lemma_div_is_ordered, lemma_div_is_ordered_by_denominator, lemma_div_multiples_vanish,\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse,\n};\nuse vstd::arithmetic::mul::{\n    lemma_mul_inequality, lemma_mul_is_distributive_add, lemma_mul_is_distributive_add_other_way,\n    lemma_mul_unary_negation,\n};\nuse vstd::prelude::*;\n\nverus! {\n\n// NOTE: We use i32 rather than float because of lack of support for float in Verus.\n/// Trusted specification functions\n// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<int>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n// Specification for what it means to compute the mean of a sequence of numbers\npub open spec fn mean(values: Seq<int>) -> int\n    recommends\n        values.len() > 0,\n{\n    sum(values) / (values.len() as int)\n}\n\n// Specification for what it means to compute the absolute value of a number\npub open spec fn abs(n: int) -> int {\n    if n >= 0 {\n        n\n    } else {\n        -n\n    }\n}\n\n// Specification for what it means to compute the mean absolute deviation of a sequence of numbers\npub open spec fn spec_mean_absolute_deviation(numbers: Seq<int>) -> int\n    recommends\n        numbers.len() > 0,\n{\n    let avg = mean(numbers);\n    sum(numbers.map(|_index, n: int| abs(n - avg))) / (numbers.len() as int)\n}\n\n/// Lemmas used in proving correctness\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, then their\n// sum is between `numbers.len() * min` and `numbers.len() * max`\n// inclusive.\nproof fn lemma_sum_bound(numbers: Seq<int>, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n    ensures\n        numbers.len() * min <= sum(numbers) <= numbers.len() * max,\n    decreases numbers.len(),\n{\n    if numbers.len() != 0 {\n        lemma_sum_bound(numbers.drop_last(), min, max);\n        lemma_mul_is_distributive_add_other_way(min, numbers.len() - 1, 1);\n        lemma_mul_is_distributive_add_other_way(max, numbers.len() - 1, 1);\n    }\n}\n\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, and if\n// certain other conditions apply, then their sum divided by\n// `denominator` is between `min` and `max` inclusive. Those\n// conditions are that `denominator >= numbers.len()`, `denominator >\n// 0`, `min <= 0`, and `max >= 0`.\nproof fn lemma_sum_ratio_bound(numbers: Seq<int>, denominator: int, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n        denominator >= numbers.len(),\n        denominator > 0,\n        min <= 0,\n        max >= 0,\n    ensures\n        min <= sum(numbers) / denominator <= max,\n{\n    lemma_sum_bound(numbers, min, max);\n    assert(denominator * min <= numbers.len() * min) by {\n        lemma_mul_unary_negation(denominator, -min);\n        lemma_mul_unary_negation(numbers.len() as int, -min);\n        lemma_mul_inequality(numbers.len() as int, denominator, -min);\n    }\n    assert(numbers.len() * max <= denominator * max) by {\n        lemma_mul_inequality(numbers.len() as int, denominator, max);\n    }\n    lemma_div_multiples_vanish(min, denominator);\n    lemma_div_multiples_vanish(max, denominator);\n    lemma_div_is_ordered(denominator * min, sum(numbers), denominator);\n    lemma_div_is_ordered(sum(numbers), denominator * max, denominator);\n}\n\n// This lemma shows that the sum of the first `i + 1` elements of\n// a sequence `s` is equal to the sum of the first `i` elements plus\n// the `i`th element.\nproof fn lemma_how_to_update_running_sum(s: Seq<int>, i: int)\n    requires\n        0 <= i < s.len(),\n    ensures\n        sum(s.take(i + 1)) == sum(s.take(i)) + s[i],\n{\n    let q1 = s.take(i);\n    let q2 = s.take(i + 1);\n    assert(q2.last() == s[i]);\n    assert(q2.drop_last() == q1);\n}\n\n// This lemma describes an algorithm for computing `(x + y) / d` and\n// `(x + y) % d` given five inputs `d`, `x / d`, `x % d`, `y / d`, and\n// `y % d`.\nproof fn lemma_how_to_add_then_divide(x: int, y: int, d: int)\n    requires\n        d > 0,\n    ensures\n        if (x % d) + (y % d) >= d {\n            &&& (x + y) / d == (x / d) + (y / d) + 1\n            &&& (x + y) % d == (x % d) + (y % d) - d\n        } else {\n            &&& (x + y) / d == (x / d) + (y / d)\n            &&& (x + y) % d == (x % d) + (y % d)\n        },\n{\n    lemma_fundamental_div_mod(x, d);\n    lemma_fundamental_div_mod(y, d);\n    lemma_mul_is_distributive_add(d, x / d, y / d);\n    if (x % d) + (y % d) >= d {\n        lemma_mul_is_distributive_add(d, (x / d) + (y / d), 1);\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d) + 1, (x % d) + (y % d) - d);\n    } else {\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d), (x % d) + (y % d));\n    }\n}\n\n// This function describes consequences of dividing by 2 or more.\n// Specifically, it says that if `x > 0`, then `x / d < x`. And if `x\n// < 0` then `x / d < 0`.\nproof fn lemma_effect_of_dividing_by_two_or_more(x: int, d: int)\n    requires\n        d >= 2,\n    ensures\n        x > 0 ==> x / d < x,\n        x < 0 ==> x / d < 0,\n{\n    lemma_fundamental_div_mod(x, d);\n    if x > 0 {\n        lemma_div_is_ordered_by_denominator(x, 2, d);\n    }\n}\n\n/// Subroutines used by target function\n// This function divides an `i32` by a `u32` and returns the quotient\n// and remainder. You need this because Verus doesn't support using\n// the `/` and `%` operator on negative numbers. And even if it did,\n// the Rust versions of `/` of `%` produce \"wrong\" results for\n// negative numbers. That is, Rust rounds towards zero rather than\n// computing mathematical quotient and remainder.\nfn divide_i32_by_u32(x: i32, d: u32) -> (qr: (i32, u32))\n    requires\n        d > 0,\n    ensures\n        ({\n            let (q, r) = qr;\n            q == x as int / d as int && r == x as int % d as int\n        }),\n{\n    // The easy case is when `x` is non-negative.\n    if x >= 0 {\n        return ((x as u32 / d) as i32, x as u32 % d);\n    }\n    // When `x` is negative, compute `-x` as a `u32`. This is a bit\n    // tricky because of the special case `i32::MIN`.\n\n    let neg_x: u32;\n    if x == i32::MIN {\n        if d == 1 {\n            // If `x == i32::MIN` and `d == 1`, the algorithm below\n            // won't work, so we special-case it here.\n            return (x, 0);\n        } else {\n            // For the special case `x == i32::MIN`, we can't negate\n            // it (because `-i32::MIN` isn't a valid `i32`). But we\n            // can just directly assign the constant value of\n            // `-i32::MIN` to a `u32`.\n            neg_x = 0x80000000u32;\n        }\n    } else {\n        neg_x = (-x) as u32;\n    }\n    assert(neg_x == -x);\n\n    // Compute `(-x) / d` and `(-x) % d`. We can do this because `-x`\n    // is non-negative and Verus supports dividing non-negative\n    // numbers.\n\n    let neg_x_div_d = neg_x / d;\n    let neg_x_mod_d = neg_x % d;\n\n    // Prove some useful things about `(-x) / d` and `(-x) % d`.\n\n    assert(neg_x == d * neg_x_div_d + neg_x_mod_d) by {\n        lemma_fundamental_div_mod(neg_x as int, d as int);\n    }\n    assert(neg_x_div_d <= i32::MAX) by {\n        if x == i32::MIN {\n            lemma_mul_inequality(2, d as int, neg_x_div_d as int);\n        }\n    }\n    // There are two cases to consider. Case 1 is when `(-x) % d ==\n    // 0`. Case 2 is when it's positive.\n\n    if neg_x_mod_d == 0 {\n        proof {\n            lemma_mul_unary_negation(d as int, neg_x_div_d as int);\n            assert(x == d * -neg_x_div_d);\n            lemma_fundamental_div_mod_converse(x as int, d as int, -(neg_x_div_d as int), 0int);\n        }\n        (-(neg_x_div_d as i32), 0u32)\n    } else {\n        proof {\n            lemma_mul_unary_negation(d as int, (neg_x_div_d + 1) as int);\n            lemma_mul_is_distributive_add(d as int, neg_x_div_d as int, 1);\n            assert(x == d as int * (-neg_x_div_d - 1) + (d - neg_x_mod_d) as int);\n            lemma_fundamental_div_mod_converse(\n                x as int,\n                d as int,\n                -(neg_x_div_d as int) - 1,\n                (d - neg_x_mod_d) as int,\n            );\n        }\n        (-(neg_x_div_d as i32) - 1, d - neg_x_mod_d)\n    }\n}\n\n// This function divides an `i32` by a `usize` and returns the\n// quotient and remainder. You need this because Verus doesn't support\n// using the `/` and `%` operator on negative numbers. And even if it\n// did, the Rust versions of `/` of `%` produce \"wrong\" results for\n// negative numbers. That is, Rust rounds towards zero rather than\n// computing mathematical quotient and remainder.\nfn divide_i32_by_usize(x: i32, d: usize) -> (qr: (i32, usize))\n    requires\n        d > 0,\n    ensures\n        ({\n            let (q, r) = qr;\n            q == x as int / d as int && r == x as int % d as int\n        }),\n{\n    // There are three cases to consider:\n    //\n    // (1) `d <= u32::MAX`, so we can compute it by calling\n    // `divide_i32_by_u32`.\n    //\n    // (2) `d > u32::MAX` and `x >= 0`, so we know that the\n    // quotient and remainder are just `0` and `x`.\n    //\n    // (3) `d > u32::MAX` and `x < 0`, so we know that the\n    // quotient and remainder are `-1` and `d + x`.\n    if d <= u32::MAX as usize {\n        let (q, r) = divide_i32_by_u32(x, d as u32);\n        (q, r as usize)\n    } else if x >= 0 {\n        assert(0 == x as int / d as int && x == x as int % d as int) by {\n            lemma_fundamental_div_mod_converse(x as int, d as int, 0, x as int);\n        }\n        (0, x as usize)\n    } else {\n        assert(-1 == x as int / d as int && d + x == x as int % d as int) by {\n            lemma_fundamental_div_mod_converse(x as int, d as int, -1, d + x);\n        }\n        // The remainder is `d + x`, but we can't directly add those\n        // two values because we can't cast them to the same type. So instead\n        // we compute `-x` then use subtraction to compute `d - (-x)`.\n\n        let neg_x: usize = if x == i32::MIN {\n            0x80000000usize\n        } else {\n            (-x) as usize\n        };\n        (-1, d - neg_x)\n    }\n}\n\n// This function computes the mean of a slice of `i32`s.\nfn compute_mean_of_i32s(numbers: &[i32]) -> (result: i32)\n    requires\n        numbers.len() > 0,\n    ensures\n        result == mean(numbers@.map(|_index, n: i32| n as int)),\n{\n    // The natural way to compute the mean is to first compute the sum\n    // and then divide by the length. But this won't be verifiable\n    // because we can't prove the absence of overflow when summing the\n    // array. So instead we use the following algorithm.\n    //\n    // We iterate through the elements of the slice, keeping track of\n    // the running sum of the first elements indirectly. That is, we\n    // don't store that running sum `s` in a variable but rather we\n    // keep track of `s / numbers.len()` and `s % numbers.len()`. The\n    // former is guaranteed to fit in an `i32` and the latter is\n    // guaranteed to fit in a `usize`. We store these in the variables\n    // `quotient` and `remainder`. At the end of the loop, we return\n    // `quotient` since it's the overall sum divided by the length of\n    // the slice.\n    let ghost nums = numbers@.map(|_index, n: i32| n as int);\n    let mut quotient: i32 = 0;\n    let mut remainder: usize = 0;\n    let numbers_len: usize = numbers.len();\n    for i in 0..numbers_len\n        invariant\n            quotient == sum(nums.take(i as int)) / numbers_len as int,\n            remainder == sum(nums.take(i as int)) % numbers_len as int,\n            numbers_len == numbers.len(),\n            nums == numbers@.map(|_index, n: i32| n as int),\n    {\n        let n = numbers[i];\n\n        // Prove that:\n        //\n        // (1) We can go from the running sum of the first `i`\n        // elements to the sum of the first `i + 1` elements by adding\n        // the `i`the element.\n        //\n        // (2) The running sum divided by `numbers.len()` is bounded\n        // between `i32::MIN` and `i32::MAX`, so the running quotient\n        // can be stored in an `i32`.\n        //\n        // (3) We can update the running quotient and remainder using\n        // an algorithm that doesn't need the running sum as input.\n        // It just needs the old running quotient and remainder.\n\n        proof {\n            lemma_how_to_update_running_sum(nums, i as int);\n            lemma_sum_ratio_bound(\n                nums.take(i + 1),\n                numbers_len as int,\n                i32::MIN as int,\n                i32::MAX as int,\n            );\n            lemma_how_to_add_then_divide(sum(nums.take(i as int)), n as int, numbers_len as int);\n        }\n\n        let (q, r) = divide_i32_by_usize(n, numbers_len);\n\n        if r >= numbers_len - remainder {\n            // Prove that we won't overflow by adding one to `q`. This\n            // follows from the facts that `q == n / numbers_len`,\n            // `numbers_len >= 2`, and `q <= i32::MAX`.\n            assert(q < i32::MAX) by {\n                lemma_effect_of_dividing_by_two_or_more(n as int, numbers_len as int);\n            }\n            remainder -= (numbers_len - r);\n            quotient += (q + 1);\n        } else {\n            remainder += r;\n            quotient += q;\n        }\n    }\n    assert(nums == nums.take(nums.len() as int));\n    quotient\n}\n\n// This function computes the absolute difference between two `i32`s as a `u32`.\nfn compute_absolute_difference(x: i32, y: i32) -> (z: u32)\n    ensures\n        z == abs(x - y),\n{\n    if x >= y {\n        if y >= 0 || x < 0 {\n            (x - y) as u32\n        } else {\n            let neg_y: u32 = if y == i32::MIN {\n                0x80000000u32\n            } else {\n                (-y) as u32\n            };\n            x as u32 + neg_y\n        }\n    } else {\n        if x >= 0 || y < 0 {\n            (y - x) as u32\n        } else {\n            let neg_x: u32 = if x == i32::MIN {\n                0x80000000u32\n            } else {\n                (-x) as u32\n            };\n            y as u32 + neg_x\n        }\n    }\n}\n\n/// Target function\npub fn mean_absolute_deviation(numbers: &[i32]) -> (result: u32)\n    requires\n        numbers.len() > 0,\n    ensures\n        result == spec_mean_absolute_deviation(numbers@.map(|_index, n: i32| n as int)),\n{\n    let numbers_mean: i32 = compute_mean_of_i32s(numbers);\n    let ghost deviations = numbers@.map(|_index, n: i32| n as int).map(\n        |_index, n: int| abs(n - numbers_mean),\n    );\n\n    // The natural way to compute the mean absolute deviation is to\n    // first compute the sum and then divide by the length. But this\n    // won't be verifiable because we can't prove the absence of\n    // overflow when summing the deviations. So instead we use the\n    // following algorithm.\n    //\n    // We iterate through the elements of the slice, keeping track of\n    // the running sum of the first deviations indirectly. That is, we\n    // don't store that running sum `s` in a variable but rather we\n    // keep track of `s / numbers.len()` and `s % numbers.len()`. The\n    // former is guaranteed to fit in an `u32` and the latter is\n    // guaranteed to fit in a `usize`. We store these in the variables\n    // `quotient` and `remainder`. At the end of the loop, we return\n    // `quotient` since it's the overall sum divided by the length of\n    // the slice.\n\n    let mut quotient: u32 = 0;\n    let mut remainder: usize = 0;\n    let numbers_len: usize = numbers.len();\n    for i in 0..numbers_len\n        invariant\n            quotient == sum(deviations.take(i as int)) / numbers_len as int,\n            remainder == sum(deviations.take(i as int)) % numbers_len as int,\n            numbers_len == numbers.len(),\n            numbers_mean == mean(numbers@.map(|_index, n: i32| n as int)),\n            deviations == numbers@.map(|_index, n: i32| n as int).map(\n                |_index, n: int| abs(n - numbers_mean),\n            ),\n    {\n        let n: u32 = compute_absolute_difference(numbers[i], numbers_mean);\n\n        // Prove that:\n        //\n        // (1) We can go from the running sum of the first `i`\n        // elements to the sum of the first `i + 1` elements by adding\n        // the `i`the element.\n        //\n        // (2) The running sum divided by `numbers.len()` is bounded\n        // between `u32::MIN` and `u32::MAX`, so the running quotient\n        // can be stored in an `u32`.\n        //\n        // (3) We can update the running quotient and remainder using\n        // an algorithm that doesn't need the running sum as input.\n        // It just needs the old running quotient and remainder.\n\n        proof {\n            lemma_how_to_update_running_sum(deviations, i as int);\n            lemma_sum_ratio_bound(\n                deviations.take(i + 1),\n                numbers_len as int,\n                u32::MIN as int,\n                u32::MAX as int,\n            );\n            lemma_how_to_add_then_divide(\n                sum(deviations.take(i as int)),\n                n as int,\n                numbers_len as int,\n            );\n        }\n\n        let q: u32 = (n as usize / numbers_len) as u32;\n        let r: usize = n as usize % numbers_len;\n\n        if r >= numbers_len - remainder {\n            // Prove that we won't overflow by adding one to `q`. This\n            // follows from the facts that `q == n / numbers_len`,\n            // `numbers_len >= 2`, and `q <= u32::MAX`.\n            assert(q < u32::MAX) by {\n                lemma_effect_of_dividing_by_two_or_more(n as int, numbers_len as int);\n            }\n            remainder -= (numbers_len - r);\n            quotient += (q + 1);\n        } else {\n            remainder += r;\n            quotient += q;\n        }\n    }\n    assert(deviations == deviations.take(deviations.len() as int));\n    quotient\n}\n\n} // verus!\n", "x": "use vstd::arithmetic::div_mod::{\n    lemma_div_is_ordered, lemma_div_is_ordered_by_denominator, lemma_div_multiples_vanish,\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse,\n};\nuse vstd::arithmetic::mul::{\n    lemma_mul_inequality, lemma_mul_is_distributive_add, lemma_mul_is_distributive_add_other_way,\n    lemma_mul_unary_negation,\n};\nuse vstd::prelude::*;\n\nverus! {\n\n// NOTE: We use i32 rather than float because of lack of support for float in Verus.\n/// Trusted specification functions\n// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<int>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n// Specification for what it means to compute the mean of a sequence of numbers\npub open spec fn mean(values: Seq<int>) -> int\n    recommends\n        values.len() > 0,\n{\n    sum(values) / (values.len() as int)\n}\n\n// Specification for what it means to compute the absolute value of a number\npub open spec fn abs(n: int) -> int {\n    if n >= 0 {\n        n\n    } else {\n        -n\n    }\n}\n\n// Specification for what it means to compute the mean absolute deviation of a sequence of numbers\npub open spec fn spec_mean_absolute_deviation(numbers: Seq<int>) -> int\n    recommends\n        numbers.len() > 0,\n{\n    let avg = mean(numbers);\n    sum(numbers.map(|_index, n: int| abs(n - avg))) / (numbers.len() as int)\n}\n\n/// Lemmas used in proving correctness\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, then their\n// sum is between `numbers.len() * min` and `numbers.len() * max`\n// inclusive.\nproof fn lemma_sum_bound(numbers: Seq<int>, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n    ensures\n        numbers.len() * min <= sum(numbers) <= numbers.len() * max,\n    decreases numbers.len(),\n{\n    if numbers.len() != 0 {\n        lemma_sum_bound(numbers.drop_last(), min, max);\n        lemma_mul_is_distributive_add_other_way(min, numbers.len() - 1, 1);\n        lemma_mul_is_distributive_add_other_way(max, numbers.len() - 1, 1);\n    }\n}\n\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, and if\n// certain other conditions apply, then their sum divided by\n// `denominator` is between `min` and `max` inclusive. Those\n// conditions are that `denominator >= numbers.len()`, `denominator >\n// 0`, `min <= 0`, and `max >= 0`.\nproof fn lemma_sum_ratio_bound(numbers: Seq<int>, denominator: int, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n        denominator >= numbers.len(),\n        denominator > 0,\n        min <= 0,\n        max >= 0,\n    ensures\n        min <= sum(numbers) / denominator <= max,\n{\n    lemma_sum_bound(numbers, min, max);\n    assert(denominator * min <= numbers.len() * min) by {\n        lemma_mul_unary_negation(denominator, -min);\n        lemma_mul_unary_negation(numbers.len() as int, -min);\n        lemma_mul_inequality(numbers.len() as int, denominator, -min);\n    }\n    assert(numbers.len() * max <= denominator * max) by {\n        lemma_mul_inequality(numbers.len() as int, denominator, max);\n    }\n    lemma_div_multiples_vanish(min, denominator);\n    lemma_div_multiples_vanish(max, denominator);\n    lemma_div_is_ordered(denominator * min, sum(numbers), denominator);\n    lemma_div_is_ordered(sum(numbers), denominator * max, denominator);\n}\n\n// This lemma shows that the sum of the first `i + 1` elements of\n// a sequence `s` is equal to the sum of the first `i` elements plus\n// the `i`th element.\nproof fn lemma_how_to_update_running_sum(s: Seq<int>, i: int)\n    requires\n        0 <= i < s.len(),\n    ensures\n        sum(s.take(i + 1)) == sum(s.take(i)) + s[i],\n{\n    let q1 = s.take(i);\n    let q2 = s.take(i + 1);\n    assert(q2.last() == s[i]);\n    assert(q2.drop_last() == q1);\n}\n\n// This lemma describes an algorithm for computing `(x + y) / d` and\n// `(x + y) % d` given five inputs `d`, `x / d`, `x % d`, `y / d`, and\n// `y % d`.\nproof fn lemma_how_to_add_then_divide(x: int, y: int, d: int)\n    requires\n        d > 0,\n    ensures\n        if (x % d) + (y % d) >= d {\n            &&& (x + y) / d == (x / d) + (y / d) + 1\n            &&& (x + y) % d == (x % d) + (y % d) - d\n        } else {\n            &&& (x + y) / d == (x / d) + (y / d)\n            &&& (x + y) % d == (x % d) + (y % d)\n        },\n{\n    lemma_fundamental_div_mod(x, d);\n    lemma_fundamental_div_mod(y, d);\n    lemma_mul_is_distributive_add(d, x / d, y / d);\n    if (x % d) + (y % d) >= d {\n        lemma_mul_is_distributive_add(d, (x / d) + (y / d), 1);\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d) + 1, (x % d) + (y % d) - d);\n    } else {\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d), (x % d) + (y % d));\n    }\n}\n\n// This function describes consequences of dividing by 2 or more.\n// Specifically, it says that if `x > 0`, then `x / d < x`. And if `x\n// < 0` then `x / d < 0`.\nproof fn lemma_effect_of_dividing_by_two_or_more(x: int, d: int)\n    requires\n        d >= 2,\n    ensures\n        x > 0 ==> x / d < x,\n        x < 0 ==> x / d < 0,\n{"}
{"y": "use vstd::arithmetic::div_mod::{\n    lemma_div_is_ordered, lemma_div_is_ordered_by_denominator, lemma_div_multiples_vanish,\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse,\n};\nuse vstd::arithmetic::mul::{\n    lemma_mul_inequality, lemma_mul_is_distributive_add, lemma_mul_is_distributive_add_other_way,\n    lemma_mul_unary_negation,\n};\nuse vstd::prelude::*;\n\nverus! {\n\n// NOTE: We use i32 rather than float because of lack of support for float in Verus.\n/// Trusted specification functions\n// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<int>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n// Specification for what it means to compute the mean of a sequence of numbers\npub open spec fn mean(values: Seq<int>) -> int\n    recommends\n        values.len() > 0,\n{\n    sum(values) / (values.len() as int)\n}\n\n// Specification for what it means to compute the absolute value of a number\npub open spec fn abs(n: int) -> int {\n    if n >= 0 {\n        n\n    } else {\n        -n\n    }\n}\n\n// Specification for what it means to compute the mean absolute deviation of a sequence of numbers\npub open spec fn spec_mean_absolute_deviation(numbers: Seq<int>) -> int\n    recommends\n        numbers.len() > 0,\n{\n    let avg = mean(numbers);\n    sum(numbers.map(|_index, n: int| abs(n - avg))) / (numbers.len() as int)\n}\n\n/// Lemmas used in proving correctness\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, then their\n// sum is between `numbers.len() * min` and `numbers.len() * max`\n// inclusive.\nproof fn lemma_sum_bound(numbers: Seq<int>, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n    ensures\n        numbers.len() * min <= sum(numbers) <= numbers.len() * max,\n    decreases numbers.len(),\n{\n    if numbers.len() != 0 {\n        lemma_sum_bound(numbers.drop_last(), min, max);\n        lemma_mul_is_distributive_add_other_way(min, numbers.len() - 1, 1);\n        lemma_mul_is_distributive_add_other_way(max, numbers.len() - 1, 1);\n    }\n}\n\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, and if\n// certain other conditions apply, then their sum divided by\n// `denominator` is between `min` and `max` inclusive. Those\n// conditions are that `denominator >= numbers.len()`, `denominator >\n// 0`, `min <= 0`, and `max >= 0`.\nproof fn lemma_sum_ratio_bound(numbers: Seq<int>, denominator: int, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n        denominator >= numbers.len(),\n        denominator > 0,\n        min <= 0,\n        max >= 0,\n    ensures\n        min <= sum(numbers) / denominator <= max,\n{\n    lemma_sum_bound(numbers, min, max);\n    assert(denominator * min <= numbers.len() * min) by {\n        lemma_mul_unary_negation(denominator, -min);\n        lemma_mul_unary_negation(numbers.len() as int, -min);\n        lemma_mul_inequality(numbers.len() as int, denominator, -min);\n    }\n    assert(numbers.len() * max <= denominator * max) by {\n        lemma_mul_inequality(numbers.len() as int, denominator, max);\n    }\n    lemma_div_multiples_vanish(min, denominator);\n    lemma_div_multiples_vanish(max, denominator);\n    lemma_div_is_ordered(denominator * min, sum(numbers), denominator);\n    lemma_div_is_ordered(sum(numbers), denominator * max, denominator);\n}\n\n// This lemma shows that the sum of the first `i + 1` elements of\n// a sequence `s` is equal to the sum of the first `i` elements plus\n// the `i`th element.\nproof fn lemma_how_to_update_running_sum(s: Seq<int>, i: int)\n    requires\n        0 <= i < s.len(),\n    ensures\n        sum(s.take(i + 1)) == sum(s.take(i)) + s[i],\n{\n    let q1 = s.take(i);\n    let q2 = s.take(i + 1);\n    assert(q2.last() == s[i]);\n    assert(q2.drop_last() == q1);\n}\n\n// This lemma describes an algorithm for computing `(x + y) / d` and\n// `(x + y) % d` given five inputs `d`, `x / d`, `x % d`, `y / d`, and\n// `y % d`.\nproof fn lemma_how_to_add_then_divide(x: int, y: int, d: int)\n    requires\n        d > 0,\n    ensures\n        if (x % d) + (y % d) >= d {\n            &&& (x + y) / d == (x / d) + (y / d) + 1\n            &&& (x + y) % d == (x % d) + (y % d) - d\n        } else {\n            &&& (x + y) / d == (x / d) + (y / d)\n            &&& (x + y) % d == (x % d) + (y % d)\n        },\n{\n    lemma_fundamental_div_mod(x, d);\n    lemma_fundamental_div_mod(y, d);\n    lemma_mul_is_distributive_add(d, x / d, y / d);\n    if (x % d) + (y % d) >= d {\n        lemma_mul_is_distributive_add(d, (x / d) + (y / d), 1);\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d) + 1, (x % d) + (y % d) - d);\n    } else {\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d), (x % d) + (y % d));\n    }\n}\n\n// This function describes consequences of dividing by 2 or more.\n// Specifically, it says that if `x > 0`, then `x / d < x`. And if `x\n// < 0` then `x / d < 0`.\nproof fn lemma_effect_of_dividing_by_two_or_more(x: int, d: int)\n    requires\n        d >= 2,\n    ensures\n        x > 0 ==> x / d < x,\n        x < 0 ==> x / d < 0,\n{\n    lemma_fundamental_div_mod(x, d);\n    if x > 0 {\n        lemma_div_is_ordered_by_denominator(x, 2, d);\n    }\n}\n\n/// Subroutines used by target function\n// This function divides an `i32` by a `u32` and returns the quotient\n// and remainder. You need this because Verus doesn't support using\n// the `/` and `%` operator on negative numbers. And even if it did,\n// the Rust versions of `/` of `%` produce \"wrong\" results for\n// negative numbers. That is, Rust rounds towards zero rather than\n// computing mathematical quotient and remainder.\nfn divide_i32_by_u32(x: i32, d: u32) -> (qr: (i32, u32))\n    requires\n        d > 0,\n    ensures\n        ({\n            let (q, r) = qr;\n            q == x as int / d as int && r == x as int % d as int\n        }),\n{\n    // The easy case is when `x` is non-negative.\n    if x >= 0 {\n        return ((x as u32 / d) as i32, x as u32 % d);\n    }\n    // When `x` is negative, compute `-x` as a `u32`. This is a bit\n    // tricky because of the special case `i32::MIN`.\n\n    let neg_x: u32;\n    if x == i32::MIN {\n        if d == 1 {\n            // If `x == i32::MIN` and `d == 1`, the algorithm below\n            // won't work, so we special-case it here.\n            return (x, 0);\n        } else {\n            // For the special case `x == i32::MIN`, we can't negate\n            // it (because `-i32::MIN` isn't a valid `i32`). But we\n            // can just directly assign the constant value of\n            // `-i32::MIN` to a `u32`.\n            neg_x = 0x80000000u32;\n        }\n    } else {\n        neg_x = (-x) as u32;\n    }\n    assert(neg_x == -x);\n\n    // Compute `(-x) / d` and `(-x) % d`. We can do this because `-x`\n    // is non-negative and Verus supports dividing non-negative\n    // numbers.\n\n    let neg_x_div_d = neg_x / d;\n    let neg_x_mod_d = neg_x % d;\n\n    // Prove some useful things about `(-x) / d` and `(-x) % d`.\n\n    assert(neg_x == d * neg_x_div_d + neg_x_mod_d) by {\n        lemma_fundamental_div_mod(neg_x as int, d as int);\n    }\n    assert(neg_x_div_d <= i32::MAX) by {\n        if x == i32::MIN {\n            lemma_mul_inequality(2, d as int, neg_x_div_d as int);\n        }\n    }\n    // There are two cases to consider. Case 1 is when `(-x) % d ==\n    // 0`. Case 2 is when it's positive.\n\n    if neg_x_mod_d == 0 {\n        proof {\n            lemma_mul_unary_negation(d as int, neg_x_div_d as int);\n            assert(x == d * -neg_x_div_d);\n            lemma_fundamental_div_mod_converse(x as int, d as int, -(neg_x_div_d as int), 0int);\n        }\n        (-(neg_x_div_d as i32), 0u32)\n    } else {\n        proof {\n            lemma_mul_unary_negation(d as int, (neg_x_div_d + 1) as int);\n            lemma_mul_is_distributive_add(d as int, neg_x_div_d as int, 1);\n            assert(x == d as int * (-neg_x_div_d - 1) + (d - neg_x_mod_d) as int);\n            lemma_fundamental_div_mod_converse(\n                x as int,\n                d as int,\n                -(neg_x_div_d as int) - 1,\n                (d - neg_x_mod_d) as int,\n            );\n        }\n        (-(neg_x_div_d as i32) - 1, d - neg_x_mod_d)\n    }\n}\n\n// This function divides an `i32` by a `usize` and returns the\n// quotient and remainder. You need this because Verus doesn't support\n// using the `/` and `%` operator on negative numbers. And even if it\n// did, the Rust versions of `/` of `%` produce \"wrong\" results for\n// negative numbers. That is, Rust rounds towards zero rather than\n// computing mathematical quotient and remainder.\nfn divide_i32_by_usize(x: i32, d: usize) -> (qr: (i32, usize))\n    requires\n        d > 0,\n    ensures\n        ({\n            let (q, r) = qr;\n            q == x as int / d as int && r == x as int % d as int\n        }),\n{\n    // There are three cases to consider:\n    //\n    // (1) `d <= u32::MAX`, so we can compute it by calling\n    // `divide_i32_by_u32`.\n    //\n    // (2) `d > u32::MAX` and `x >= 0`, so we know that the\n    // quotient and remainder are just `0` and `x`.\n    //\n    // (3) `d > u32::MAX` and `x < 0`, so we know that the\n    // quotient and remainder are `-1` and `d + x`.\n    if d <= u32::MAX as usize {\n        let (q, r) = divide_i32_by_u32(x, d as u32);\n        (q, r as usize)\n    } else if x >= 0 {\n        assert(0 == x as int / d as int && x == x as int % d as int) by {\n            lemma_fundamental_div_mod_converse(x as int, d as int, 0, x as int);\n        }\n        (0, x as usize)\n    } else {\n        assert(-1 == x as int / d as int && d + x == x as int % d as int) by {\n            lemma_fundamental_div_mod_converse(x as int, d as int, -1, d + x);\n        }\n        // The remainder is `d + x`, but we can't directly add those\n        // two values because we can't cast them to the same type. So instead\n        // we compute `-x` then use subtraction to compute `d - (-x)`.\n\n        let neg_x: usize = if x == i32::MIN {\n            0x80000000usize\n        } else {\n            (-x) as usize\n        };\n        (-1, d - neg_x)\n    }\n}\n\n// This function computes the mean of a slice of `i32`s.\nfn compute_mean_of_i32s(numbers: &[i32]) -> (result: i32)\n    requires\n        numbers.len() > 0,\n    ensures\n        result == mean(numbers@.map(|_index, n: i32| n as int)),\n{\n    // The natural way to compute the mean is to first compute the sum\n    // and then divide by the length. But this won't be verifiable\n    // because we can't prove the absence of overflow when summing the\n    // array. So instead we use the following algorithm.\n    //\n    // We iterate through the elements of the slice, keeping track of\n    // the running sum of the first elements indirectly. That is, we\n    // don't store that running sum `s` in a variable but rather we\n    // keep track of `s / numbers.len()` and `s % numbers.len()`. The\n    // former is guaranteed to fit in an `i32` and the latter is\n    // guaranteed to fit in a `usize`. We store these in the variables\n    // `quotient` and `remainder`. At the end of the loop, we return\n    // `quotient` since it's the overall sum divided by the length of\n    // the slice.\n    let ghost nums = numbers@.map(|_index, n: i32| n as int);\n    let mut quotient: i32 = 0;\n    let mut remainder: usize = 0;\n    let numbers_len: usize = numbers.len();\n    for i in 0..numbers_len\n        invariant\n            quotient == sum(nums.take(i as int)) / numbers_len as int,\n            remainder == sum(nums.take(i as int)) % numbers_len as int,\n            numbers_len == numbers.len(),\n            nums == numbers@.map(|_index, n: i32| n as int),\n    {\n        let n = numbers[i];\n\n        // Prove that:\n        //\n        // (1) We can go from the running sum of the first `i`\n        // elements to the sum of the first `i + 1` elements by adding\n        // the `i`the element.\n        //\n        // (2) The running sum divided by `numbers.len()` is bounded\n        // between `i32::MIN` and `i32::MAX`, so the running quotient\n        // can be stored in an `i32`.\n        //\n        // (3) We can update the running quotient and remainder using\n        // an algorithm that doesn't need the running sum as input.\n        // It just needs the old running quotient and remainder.\n\n        proof {\n            lemma_how_to_update_running_sum(nums, i as int);\n            lemma_sum_ratio_bound(\n                nums.take(i + 1),\n                numbers_len as int,\n                i32::MIN as int,\n                i32::MAX as int,\n            );\n            lemma_how_to_add_then_divide(sum(nums.take(i as int)), n as int, numbers_len as int);\n        }\n\n        let (q, r) = divide_i32_by_usize(n, numbers_len);\n\n        if r >= numbers_len - remainder {\n            // Prove that we won't overflow by adding one to `q`. This\n            // follows from the facts that `q == n / numbers_len`,\n            // `numbers_len >= 2`, and `q <= i32::MAX`.\n            assert(q < i32::MAX) by {\n                lemma_effect_of_dividing_by_two_or_more(n as int, numbers_len as int);\n            }\n            remainder -= (numbers_len - r);\n            quotient += (q + 1);\n        } else {\n            remainder += r;\n            quotient += q;\n        }\n    }\n    assert(nums == nums.take(nums.len() as int));\n    quotient\n}\n\n// This function computes the absolute difference between two `i32`s as a `u32`.\nfn compute_absolute_difference(x: i32, y: i32) -> (z: u32)\n    ensures\n        z == abs(x - y),\n{\n    if x >= y {\n        if y >= 0 || x < 0 {\n            (x - y) as u32\n        } else {\n            let neg_y: u32 = if y == i32::MIN {\n                0x80000000u32\n            } else {\n                (-y) as u32\n            };\n            x as u32 + neg_y\n        }\n    } else {\n        if x >= 0 || y < 0 {\n            (y - x) as u32\n        } else {\n            let neg_x: u32 = if x == i32::MIN {\n                0x80000000u32\n            } else {\n                (-x) as u32\n            };\n            y as u32 + neg_x\n        }\n    }\n}\n\n/// Target function\npub fn mean_absolute_deviation(numbers: &[i32]) -> (result: u32)\n    requires\n        numbers.len() > 0,\n    ensures\n        result == spec_mean_absolute_deviation(numbers@.map(|_index, n: i32| n as int)),\n{\n    let numbers_mean: i32 = compute_mean_of_i32s(numbers);\n    let ghost deviations = numbers@.map(|_index, n: i32| n as int).map(\n        |_index, n: int| abs(n - numbers_mean),\n    );\n\n    // The natural way to compute the mean absolute deviation is to\n    // first compute the sum and then divide by the length. But this\n    // won't be verifiable because we can't prove the absence of\n    // overflow when summing the deviations. So instead we use the\n    // following algorithm.\n    //\n    // We iterate through the elements of the slice, keeping track of\n    // the running sum of the first deviations indirectly. That is, we\n    // don't store that running sum `s` in a variable but rather we\n    // keep track of `s / numbers.len()` and `s % numbers.len()`. The\n    // former is guaranteed to fit in an `u32` and the latter is\n    // guaranteed to fit in a `usize`. We store these in the variables\n    // `quotient` and `remainder`. At the end of the loop, we return\n    // `quotient` since it's the overall sum divided by the length of\n    // the slice.\n\n    let mut quotient: u32 = 0;\n    let mut remainder: usize = 0;\n    let numbers_len: usize = numbers.len();\n    for i in 0..numbers_len\n        invariant\n            quotient == sum(deviations.take(i as int)) / numbers_len as int,\n            remainder == sum(deviations.take(i as int)) % numbers_len as int,\n            numbers_len == numbers.len(),\n            numbers_mean == mean(numbers@.map(|_index, n: i32| n as int)),\n            deviations == numbers@.map(|_index, n: i32| n as int).map(\n                |_index, n: int| abs(n - numbers_mean),\n            ),\n    {\n        let n: u32 = compute_absolute_difference(numbers[i], numbers_mean);\n\n        // Prove that:\n        //\n        // (1) We can go from the running sum of the first `i`\n        // elements to the sum of the first `i + 1` elements by adding\n        // the `i`the element.\n        //\n        // (2) The running sum divided by `numbers.len()` is bounded\n        // between `u32::MIN` and `u32::MAX`, so the running quotient\n        // can be stored in an `u32`.\n        //\n        // (3) We can update the running quotient and remainder using\n        // an algorithm that doesn't need the running sum as input.\n        // It just needs the old running quotient and remainder.\n\n        proof {\n            lemma_how_to_update_running_sum(deviations, i as int);\n            lemma_sum_ratio_bound(\n                deviations.take(i + 1),\n                numbers_len as int,\n                u32::MIN as int,\n                u32::MAX as int,\n            );\n            lemma_how_to_add_then_divide(\n                sum(deviations.take(i as int)),\n                n as int,\n                numbers_len as int,\n            );\n        }\n\n        let q: u32 = (n as usize / numbers_len) as u32;\n        let r: usize = n as usize % numbers_len;\n\n        if r >= numbers_len - remainder {\n            // Prove that we won't overflow by adding one to `q`. This\n            // follows from the facts that `q == n / numbers_len`,\n            // `numbers_len >= 2`, and `q <= u32::MAX`.\n            assert(q < u32::MAX) by {\n                lemma_effect_of_dividing_by_two_or_more(n as int, numbers_len as int);\n            }\n            remainder -= (numbers_len - r);\n            quotient += (q + 1);\n        } else {\n            remainder += r;\n            quotient += q;\n        }\n    }\n    assert(deviations == deviations.take(deviations.len() as int));\n    quotient\n}\n\n} // verus!\n", "x": "use vstd::arithmetic::div_mod::{\n    lemma_div_is_ordered, lemma_div_is_ordered_by_denominator, lemma_div_multiples_vanish,\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse,\n};\nuse vstd::arithmetic::mul::{\n    lemma_mul_inequality, lemma_mul_is_distributive_add, lemma_mul_is_distributive_add_other_way,\n    lemma_mul_unary_negation,\n};\nuse vstd::prelude::*;\n\nverus! {\n\n// NOTE: We use i32 rather than float because of lack of support for float in Verus.\n/// Trusted specification functions\n// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<int>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n// Specification for what it means to compute the mean of a sequence of numbers\npub open spec fn mean(values: Seq<int>) -> int\n    recommends\n        values.len() > 0,\n{\n    sum(values) / (values.len() as int)\n}\n\n// Specification for what it means to compute the absolute value of a number\npub open spec fn abs(n: int) -> int {\n    if n >= 0 {\n        n\n    } else {\n        -n\n    }\n}\n\n// Specification for what it means to compute the mean absolute deviation of a sequence of numbers\npub open spec fn spec_mean_absolute_deviation(numbers: Seq<int>) -> int\n    recommends\n        numbers.len() > 0,\n{\n    let avg = mean(numbers);\n    sum(numbers.map(|_index, n: int| abs(n - avg))) / (numbers.len() as int)\n}\n\n/// Lemmas used in proving correctness\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, then their\n// sum is between `numbers.len() * min` and `numbers.len() * max`\n// inclusive.\nproof fn lemma_sum_bound(numbers: Seq<int>, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n    ensures\n        numbers.len() * min <= sum(numbers) <= numbers.len() * max,\n    decreases numbers.len(),\n{\n    if numbers.len() != 0 {\n        lemma_sum_bound(numbers.drop_last(), min, max);\n        lemma_mul_is_distributive_add_other_way(min, numbers.len() - 1, 1);\n        lemma_mul_is_distributive_add_other_way(max, numbers.len() - 1, 1);\n    }\n}\n\n// This lemma establishes that if every element of a sequence of\n// numbers `numbers` is between `min` and `max` inclusive, and if\n// certain other conditions apply, then their sum divided by\n// `denominator` is between `min` and `max` inclusive. Those\n// conditions are that `denominator >= numbers.len()`, `denominator >\n// 0`, `min <= 0`, and `max >= 0`.\nproof fn lemma_sum_ratio_bound(numbers: Seq<int>, denominator: int, min: int, max: int)\n    requires\n        forall|i| 0 <= i < numbers.len() ==> min <= #[trigger] numbers[i] <= max,\n        denominator >= numbers.len(),\n        denominator > 0,\n        min <= 0,\n        max >= 0,\n    ensures\n        min <= sum(numbers) / denominator <= max,\n{\n    lemma_sum_bound(numbers, min, max);\n    assert(denominator * min <= numbers.len() * min) by {\n        lemma_mul_unary_negation(denominator, -min);\n        lemma_mul_unary_negation(numbers.len() as int, -min);\n        lemma_mul_inequality(numbers.len() as int, denominator, -min);\n    }\n    assert(numbers.len() * max <= denominator * max) by {\n        lemma_mul_inequality(numbers.len() as int, denominator, max);\n    }\n    lemma_div_multiples_vanish(min, denominator);\n    lemma_div_multiples_vanish(max, denominator);\n    lemma_div_is_ordered(denominator * min, sum(numbers), denominator);\n    lemma_div_is_ordered(sum(numbers), denominator * max, denominator);\n}\n\n// This lemma shows that the sum of the first `i + 1` elements of\n// a sequence `s` is equal to the sum of the first `i` elements plus\n// the `i`th element.\nproof fn lemma_how_to_update_running_sum(s: Seq<int>, i: int)\n    requires\n        0 <= i < s.len(),\n    ensures\n        sum(s.take(i + 1)) == sum(s.take(i)) + s[i],\n{\n    let q1 = s.take(i);\n    let q2 = s.take(i + 1);\n    assert(q2.last() == s[i]);\n    assert(q2.drop_last() == q1);\n}\n\n// This lemma describes an algorithm for computing `(x + y) / d` and\n// `(x + y) % d` given five inputs `d`, `x / d`, `x % d`, `y / d`, and\n// `y % d`.\nproof fn lemma_how_to_add_then_divide(x: int, y: int, d: int)\n    requires\n        d > 0,\n    ensures\n        if (x % d) + (y % d) >= d {\n            &&& (x + y) / d == (x / d) + (y / d) + 1\n            &&& (x + y) % d == (x % d) + (y % d) - d\n        } else {\n            &&& (x + y) / d == (x / d) + (y / d)\n            &&& (x + y) % d == (x % d) + (y % d)\n        },\n{\n    lemma_fundamental_div_mod(x, d);\n    lemma_fundamental_div_mod(y, d);\n    lemma_mul_is_distributive_add(d, x / d, y / d);\n    if (x % d) + (y % d) >= d {\n        lemma_mul_is_distributive_add(d, (x / d) + (y / d), 1);\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d) + 1, (x % d) + (y % d) - d);\n    } else {\n        lemma_fundamental_div_mod_converse(x + y, d, (x / d) + (y / d), (x % d) + (y % d));\n    }\n}\n\n// This function describes consequences of dividing by 2 or more.\n// Specifically, it says that if `x > 0`, then `x / d < x`. And if `x\n// < 0` then `x / d < 0`.\nproof fn lemma_effect_of_dividing_by_two_or_more(x: int, d: int)\n    requires\n        d >= 2,\n    ensures\n        x > 0 ==> x / d < x,\n        x < 0 ==> x / d < 0,\n{\n    lemma_fundamental_div_mod(x, d);\n    if x > 0 {\n        lemma_div_is_ordered_by_denominator(x, 2, d);\n    }\n}\n\n/// Subroutines used by target function\n// This function divides an `i32` by a `u32` and returns the quotient\n// and remainder. You need this because Verus doesn't support using\n// the `/` and `%` operator on negative numbers. And even if it did,\n// the Rust versions of `/` of `%` produce \"wrong\" results for\n// negative numbers. That is, Rust rounds towards zero rather than\n// computing mathematical quotient and remainder.\nfn divide_i32_by_u32(x: i32, d: u32) -> (qr: (i32, u32))\n    requires\n        d > 0,\n    ensures\n        ({\n            let (q, r) = qr;\n            q == x as int / d as int && r == x as int % d as int\n        }),\n{"}
{"y": "use vstd::assert_seqs_equal;\nuse vstd::prelude::*;\n\nverus! {\n\n/// Specification for inserting a number 'delimiter' between every two consecutive elements\n/// of input sequence `numbers'\npub open spec fn intersperse_spec(numbers: Seq<u64>, delimiter: u64) -> Seq<u64>\n    decreases numbers.len(),\n{\n    if numbers.len() <= 1 {\n        numbers\n    } else {\n        intersperse_spec(numbers.drop_last(), delimiter) + seq![delimiter, numbers.last()]\n    }\n}\n\n// We use these two functions to provide valid triggers for the quantifiers in intersperse_quantified\nspec fn even(i: int) -> int {\n    2 * i\n}\n\nspec fn odd(i: int) -> int {\n    2 * i + 1\n}\n\n// This quantified formulation of intersperse is easier to reason about in the implementation's loop\nspec fn intersperse_quantified(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>) -> bool {\n    (if numbers.len() == 0 {\n        interspersed.len() == 0\n    } else {\n        interspersed.len() == 2 * numbers.len() - 1\n    }) && (forall|i: int| 0 <= i < numbers.len() ==> #[trigger] interspersed[even(i)] == numbers[i])\n        && (forall|i: int|\n        0 <= i < numbers.len() - 1 ==> #[trigger] interspersed[odd(i)] == delimiter)\n}\n\nproof fn intersperse_spec_len(numbers: Seq<u64>, delimiter: u64)\n    ensures\n        numbers.len() > 0 ==> intersperse_spec(numbers, delimiter).len() == 2 * numbers.len() - 1,\n    decreases numbers.len(),\n{\n    if numbers.len() > 0 {\n        intersperse_spec_len(numbers.drop_last(), delimiter);\n    }\n}\n\n// Show that the two descriptions of intersperse are equivalent\nproof fn intersperse_quantified_is_spec(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>)\n    requires\n        intersperse_quantified(numbers, delimiter, interspersed),\n    ensures\n        interspersed == intersperse_spec(numbers, delimiter),\n    decreases numbers.len(),\n{\n    let is = intersperse_spec(numbers, delimiter);\n    if numbers.len() == 0 {\n    } else if numbers.len() == 1 {\n        assert(interspersed.len() == 1);\n        assert(interspersed[even(0)] == numbers[0]);\n    } else {\n        intersperse_quantified_is_spec(\n            numbers.drop_last(),\n            delimiter,\n            interspersed.take(interspersed.len() - 2),\n        );\n        intersperse_spec_len(numbers, delimiter);\n        assert_seqs_equal!(is == interspersed, i => {\n            if i < is.len() - 2 {\n            } else {\n                if i % 2 == 0 {\n                    assert(is[i] == numbers.last());\n                    assert(interspersed[even(i/2)] == numbers[i / 2]);\n                    assert(i / 2 == numbers.len() - 1);\n                } else {\n                    assert(is[i] == delimiter);\n                    assert(interspersed[odd((i-1)/2)] == delimiter);\n                }\n            }\n        });\n    }\n    assert(interspersed =~= intersperse_spec(numbers, delimiter));\n}\n\n/// Implementation of intersperse\npub fn intersperse(numbers: Vec<u64>, delimiter: u64) -> (result: Vec<u64>)\n    ensures\n        result@ == intersperse_spec(numbers@, delimiter),\n{\n    if numbers.len() <= 1 {\n        numbers\n    } else {\n        let mut result = Vec::new();\n        let mut index = 0;\n        while index < numbers.len() - 1\n            invariant\n                numbers.len() > 1,\n                0 <= index < numbers.len(),\n                result.len() == 2 * index,\n                forall|i: int| 0 <= i < index ==> #[trigger] result[even(i)] == numbers[i],\n                forall|i: int| 0 <= i < index ==> #[trigger] result[odd(i)] == delimiter,\n        {\n            result.push(numbers[index]);\n            result.push(delimiter);\n            index += 1;\n            //assert(numbers@.subrange(0, index as int).drop_last() =~= numbers@.subrange(0, index as int - 1));\n        }\n        result.push(numbers[numbers.len() - 1]);\n        proof {\n            intersperse_quantified_is_spec(numbers@, delimiter, result@);\n        }\n        result\n    }\n}\n\n} // verus!\n", "x": "use vstd::assert_seqs_equal;\nuse vstd::prelude::*;\n\nverus! {\n\n/// Specification for inserting a number 'delimiter' between every two consecutive elements\n/// of input sequence `numbers'\npub open spec fn intersperse_spec(numbers: Seq<u64>, delimiter: u64) -> Seq<u64>\n    decreases numbers.len(),\n{\n    if numbers.len() <= 1 {\n        numbers\n    } else {\n        intersperse_spec(numbers.drop_last(), delimiter) + seq![delimiter, numbers.last()]\n    }\n}\n\n// We use these two functions to provide valid triggers for the quantifiers in intersperse_quantified\nspec fn even(i: int) -> int {\n    2 * i\n}\n\nspec fn odd(i: int) -> int {\n    2 * i + 1\n}\n\n// This quantified formulation of intersperse is easier to reason about in the implementation's loop\nspec fn intersperse_quantified(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>) -> bool {\n    (if numbers.len() == 0 {\n        interspersed.len() == 0\n    } else {\n        interspersed.len() == 2 * numbers.len() - 1\n    }) && (forall|i: int| 0 <= i < numbers.len() ==> #[trigger] interspersed[even(i)] == numbers[i])\n        && (forall|i: int|\n        0 <= i < numbers.len() - 1 ==> #[trigger] interspersed[odd(i)] == delimiter)\n}\n\nproof fn intersperse_spec_len(numbers: Seq<u64>, delimiter: u64)\n    ensures\n        numbers.len() > 0 ==> intersperse_spec(numbers, delimiter).len() == 2 * numbers.len() - 1,\n    decreases numbers.len(),\n{"}
{"y": "use vstd::assert_seqs_equal;\nuse vstd::prelude::*;\n\nverus! {\n\n/// Specification for inserting a number 'delimiter' between every two consecutive elements\n/// of input sequence `numbers'\npub open spec fn intersperse_spec(numbers: Seq<u64>, delimiter: u64) -> Seq<u64>\n    decreases numbers.len(),\n{\n    if numbers.len() <= 1 {\n        numbers\n    } else {\n        intersperse_spec(numbers.drop_last(), delimiter) + seq![delimiter, numbers.last()]\n    }\n}\n\n// We use these two functions to provide valid triggers for the quantifiers in intersperse_quantified\nspec fn even(i: int) -> int {\n    2 * i\n}\n\nspec fn odd(i: int) -> int {\n    2 * i + 1\n}\n\n// This quantified formulation of intersperse is easier to reason about in the implementation's loop\nspec fn intersperse_quantified(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>) -> bool {\n    (if numbers.len() == 0 {\n        interspersed.len() == 0\n    } else {\n        interspersed.len() == 2 * numbers.len() - 1\n    }) && (forall|i: int| 0 <= i < numbers.len() ==> #[trigger] interspersed[even(i)] == numbers[i])\n        && (forall|i: int|\n        0 <= i < numbers.len() - 1 ==> #[trigger] interspersed[odd(i)] == delimiter)\n}\n\nproof fn intersperse_spec_len(numbers: Seq<u64>, delimiter: u64)\n    ensures\n        numbers.len() > 0 ==> intersperse_spec(numbers, delimiter).len() == 2 * numbers.len() - 1,\n    decreases numbers.len(),\n{\n    if numbers.len() > 0 {\n        intersperse_spec_len(numbers.drop_last(), delimiter);\n    }\n}\n\n// Show that the two descriptions of intersperse are equivalent\nproof fn intersperse_quantified_is_spec(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>)\n    requires\n        intersperse_quantified(numbers, delimiter, interspersed),\n    ensures\n        interspersed == intersperse_spec(numbers, delimiter),\n    decreases numbers.len(),\n{\n    let is = intersperse_spec(numbers, delimiter);\n    if numbers.len() == 0 {\n    } else if numbers.len() == 1 {\n        assert(interspersed.len() == 1);\n        assert(interspersed[even(0)] == numbers[0]);\n    } else {\n        intersperse_quantified_is_spec(\n            numbers.drop_last(),\n            delimiter,\n            interspersed.take(interspersed.len() - 2),\n        );\n        intersperse_spec_len(numbers, delimiter);\n        assert_seqs_equal!(is == interspersed, i => {\n            if i < is.len() - 2 {\n            } else {\n                if i % 2 == 0 {\n                    assert(is[i] == numbers.last());\n                    assert(interspersed[even(i/2)] == numbers[i / 2]);\n                    assert(i / 2 == numbers.len() - 1);\n                } else {\n                    assert(is[i] == delimiter);\n                    assert(interspersed[odd((i-1)/2)] == delimiter);\n                }\n            }\n        });\n    }\n    assert(interspersed =~= intersperse_spec(numbers, delimiter));\n}\n\n/// Implementation of intersperse\npub fn intersperse(numbers: Vec<u64>, delimiter: u64) -> (result: Vec<u64>)\n    ensures\n        result@ == intersperse_spec(numbers@, delimiter),\n{\n    if numbers.len() <= 1 {\n        numbers\n    } else {\n        let mut result = Vec::new();\n        let mut index = 0;\n        while index < numbers.len() - 1\n            invariant\n                numbers.len() > 1,\n                0 <= index < numbers.len(),\n                result.len() == 2 * index,\n                forall|i: int| 0 <= i < index ==> #[trigger] result[even(i)] == numbers[i],\n                forall|i: int| 0 <= i < index ==> #[trigger] result[odd(i)] == delimiter,\n        {\n            result.push(numbers[index]);\n            result.push(delimiter);\n            index += 1;\n            //assert(numbers@.subrange(0, index as int).drop_last() =~= numbers@.subrange(0, index as int - 1));\n        }\n        result.push(numbers[numbers.len() - 1]);\n        proof {\n            intersperse_quantified_is_spec(numbers@, delimiter, result@);\n        }\n        result\n    }\n}\n\n} // verus!\n", "x": "use vstd::assert_seqs_equal;\nuse vstd::prelude::*;\n\nverus! {\n\n/// Specification for inserting a number 'delimiter' between every two consecutive elements\n/// of input sequence `numbers'\npub open spec fn intersperse_spec(numbers: Seq<u64>, delimiter: u64) -> Seq<u64>\n    decreases numbers.len(),\n{\n    if numbers.len() <= 1 {\n        numbers\n    } else {\n        intersperse_spec(numbers.drop_last(), delimiter) + seq![delimiter, numbers.last()]\n    }\n}\n\n// We use these two functions to provide valid triggers for the quantifiers in intersperse_quantified\nspec fn even(i: int) -> int {\n    2 * i\n}\n\nspec fn odd(i: int) -> int {\n    2 * i + 1\n}\n\n// This quantified formulation of intersperse is easier to reason about in the implementation's loop\nspec fn intersperse_quantified(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>) -> bool {\n    (if numbers.len() == 0 {\n        interspersed.len() == 0\n    } else {\n        interspersed.len() == 2 * numbers.len() - 1\n    }) && (forall|i: int| 0 <= i < numbers.len() ==> #[trigger] interspersed[even(i)] == numbers[i])\n        && (forall|i: int|\n        0 <= i < numbers.len() - 1 ==> #[trigger] interspersed[odd(i)] == delimiter)\n}\n\nproof fn intersperse_spec_len(numbers: Seq<u64>, delimiter: u64)\n    ensures\n        numbers.len() > 0 ==> intersperse_spec(numbers, delimiter).len() == 2 * numbers.len() - 1,\n    decreases numbers.len(),\n{\n    if numbers.len() > 0 {\n        intersperse_spec_len(numbers.drop_last(), delimiter);\n    }\n}\n\n// Show that the two descriptions of intersperse are equivalent\nproof fn intersperse_quantified_is_spec(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>)\n    requires\n        intersperse_quantified(numbers, delimiter, interspersed),\n    ensures\n        interspersed == intersperse_spec(numbers, delimiter),\n    decreases numbers.len(),\n{"}
{"y": "use vstd::assert_seqs_equal;\nuse vstd::prelude::*;\n\nverus! {\n\n/// Specification for inserting a number 'delimiter' between every two consecutive elements\n/// of input sequence `numbers'\npub open spec fn intersperse_spec(numbers: Seq<u64>, delimiter: u64) -> Seq<u64>\n    decreases numbers.len(),\n{\n    if numbers.len() <= 1 {\n        numbers\n    } else {\n        intersperse_spec(numbers.drop_last(), delimiter) + seq![delimiter, numbers.last()]\n    }\n}\n\n// We use these two functions to provide valid triggers for the quantifiers in intersperse_quantified\nspec fn even(i: int) -> int {\n    2 * i\n}\n\nspec fn odd(i: int) -> int {\n    2 * i + 1\n}\n\n// This quantified formulation of intersperse is easier to reason about in the implementation's loop\nspec fn intersperse_quantified(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>) -> bool {\n    (if numbers.len() == 0 {\n        interspersed.len() == 0\n    } else {\n        interspersed.len() == 2 * numbers.len() - 1\n    }) && (forall|i: int| 0 <= i < numbers.len() ==> #[trigger] interspersed[even(i)] == numbers[i])\n        && (forall|i: int|\n        0 <= i < numbers.len() - 1 ==> #[trigger] interspersed[odd(i)] == delimiter)\n}\n\nproof fn intersperse_spec_len(numbers: Seq<u64>, delimiter: u64)\n    ensures\n        numbers.len() > 0 ==> intersperse_spec(numbers, delimiter).len() == 2 * numbers.len() - 1,\n    decreases numbers.len(),\n{\n    if numbers.len() > 0 {\n        intersperse_spec_len(numbers.drop_last(), delimiter);\n    }\n}\n\n// Show that the two descriptions of intersperse are equivalent\nproof fn intersperse_quantified_is_spec(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>)\n    requires\n        intersperse_quantified(numbers, delimiter, interspersed),\n    ensures\n        interspersed == intersperse_spec(numbers, delimiter),\n    decreases numbers.len(),\n{\n    let is = intersperse_spec(numbers, delimiter);\n    if numbers.len() == 0 {\n    } else if numbers.len() == 1 {\n        assert(interspersed.len() == 1);\n        assert(interspersed[even(0)] == numbers[0]);\n    } else {\n        intersperse_quantified_is_spec(\n            numbers.drop_last(),\n            delimiter,\n            interspersed.take(interspersed.len() - 2),\n        );\n        intersperse_spec_len(numbers, delimiter);\n        assert_seqs_equal!(is == interspersed, i => {\n            if i < is.len() - 2 {\n            } else {\n                if i % 2 == 0 {\n                    assert(is[i] == numbers.last());\n                    assert(interspersed[even(i/2)] == numbers[i / 2]);\n                    assert(i / 2 == numbers.len() - 1);\n                } else {\n                    assert(is[i] == delimiter);\n                    assert(interspersed[odd((i-1)/2)] == delimiter);\n                }\n            }\n        });\n    }\n    assert(interspersed =~= intersperse_spec(numbers, delimiter));\n}\n\n/// Implementation of intersperse\npub fn intersperse(numbers: Vec<u64>, delimiter: u64) -> (result: Vec<u64>)\n    ensures\n        result@ == intersperse_spec(numbers@, delimiter),\n{\n    if numbers.len() <= 1 {\n        numbers\n    } else {\n        let mut result = Vec::new();\n        let mut index = 0;\n        while index < numbers.len() - 1\n            invariant\n                numbers.len() > 1,\n                0 <= index < numbers.len(),\n                result.len() == 2 * index,\n                forall|i: int| 0 <= i < index ==> #[trigger] result[even(i)] == numbers[i],\n                forall|i: int| 0 <= i < index ==> #[trigger] result[odd(i)] == delimiter,\n        {\n            result.push(numbers[index]);\n            result.push(delimiter);\n            index += 1;\n            //assert(numbers@.subrange(0, index as int).drop_last() =~= numbers@.subrange(0, index as int - 1));\n        }\n        result.push(numbers[numbers.len() - 1]);\n        proof {\n            intersperse_quantified_is_spec(numbers@, delimiter, result@);\n        }\n        result\n    }\n}\n\n} // verus!\n", "x": "use vstd::assert_seqs_equal;\nuse vstd::prelude::*;\n\nverus! {\n\n/// Specification for inserting a number 'delimiter' between every two consecutive elements\n/// of input sequence `numbers'\npub open spec fn intersperse_spec(numbers: Seq<u64>, delimiter: u64) -> Seq<u64>\n    decreases numbers.len(),\n{\n    if numbers.len() <= 1 {\n        numbers\n    } else {\n        intersperse_spec(numbers.drop_last(), delimiter) + seq![delimiter, numbers.last()]\n    }\n}\n\n// We use these two functions to provide valid triggers for the quantifiers in intersperse_quantified\nspec fn even(i: int) -> int {\n    2 * i\n}\n\nspec fn odd(i: int) -> int {\n    2 * i + 1\n}\n\n// This quantified formulation of intersperse is easier to reason about in the implementation's loop\nspec fn intersperse_quantified(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>) -> bool {\n    (if numbers.len() == 0 {\n        interspersed.len() == 0\n    } else {\n        interspersed.len() == 2 * numbers.len() - 1\n    }) && (forall|i: int| 0 <= i < numbers.len() ==> #[trigger] interspersed[even(i)] == numbers[i])\n        && (forall|i: int|\n        0 <= i < numbers.len() - 1 ==> #[trigger] interspersed[odd(i)] == delimiter)\n}\n\nproof fn intersperse_spec_len(numbers: Seq<u64>, delimiter: u64)\n    ensures\n        numbers.len() > 0 ==> intersperse_spec(numbers, delimiter).len() == 2 * numbers.len() - 1,\n    decreases numbers.len(),\n{\n    if numbers.len() > 0 {\n        intersperse_spec_len(numbers.drop_last(), delimiter);\n    }\n}\n\n// Show that the two descriptions of intersperse are equivalent\nproof fn intersperse_quantified_is_spec(numbers: Seq<u64>, delimiter: u64, interspersed: Seq<u64>)\n    requires\n        intersperse_quantified(numbers, delimiter, interspersed),\n    ensures\n        interspersed == intersperse_spec(numbers, delimiter),\n    decreases numbers.len(),\n{\n    let is = intersperse_spec(numbers, delimiter);\n    if numbers.len() == 0 {\n    } else if numbers.len() == 1 {\n        assert(interspersed.len() == 1);\n        assert(interspersed[even(0)] == numbers[0]);\n    } else {\n        intersperse_quantified_is_spec(\n            numbers.drop_last(),\n            delimiter,\n            interspersed.take(interspersed.len() - 2),\n        );\n        intersperse_spec_len(numbers, delimiter);\n        assert_seqs_equal!(is == interspersed, i => {\n            if i < is.len() - 2 {\n            } else {\n                if i % 2 == 0 {\n                    assert(is[i] == numbers.last());\n                    assert(interspersed[even(i/2)] == numbers[i / 2]);\n                    assert(i / 2 == numbers.len() - 1);\n                } else {\n                    assert(is[i] == delimiter);\n                    assert(interspersed[odd((i-1)/2)] == delimiter);\n                }\n            }\n        });\n    }\n    assert(interspersed =~= intersperse_spec(numbers, delimiter));\n}\n\n/// Implementation of intersperse\npub fn intersperse(numbers: Vec<u64>, delimiter: u64) -> (result: Vec<u64>)\n    ensures\n        result@ == intersperse_spec(numbers@, delimiter),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n/// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<u32>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n/// Specification for taking the product of a sequence of numbers\npub open spec fn product(numbers: Seq<u32>) -> int {\n    numbers.fold_left(1, |acc: int, x| acc * x)\n}\n\n/// Show that the sum won't grow too large\nproof fn sum_bound(numbers: Seq<u32>)\n    ensures\n        sum(numbers) <= numbers.len() * u32::MAX,\n    decreases numbers.len(),\n{\n    if numbers.len() == 0 {\n    } else {\n        sum_bound(numbers.drop_last());\n    }\n}\n\n/// Implementation.  We leave the consequences of an intermediate\n/// overflow during the product calculation underspecified.\nfn sum_product(numbers: Vec<u32>) -> (result: (u64, Option<u32>))\n    requires\n        numbers.len() < u32::MAX,\n    ensures\n        result.0 == sum(numbers@),\n        match result.1 {\n            None =>   // Computing the product overflowed at some point\n            exists|i|\n                #![auto]\n                0 <= i < numbers.len() && product(numbers@.subrange(0, i)) * numbers[i] as int\n                    > u32::MAX,\n            Some(v) => v == product(numbers@),\n        },\n{\n    let mut sum_value: u64 = 0;\n    let mut prod_value: Option<u32> = Some(1);\n    for index in 0..numbers.len()\n        invariant\n            numbers.len() < u32::MAX,\n            sum_value == sum(numbers@.take(index as int)),\n            prod_value matches Some(v) ==> v == product(numbers@.take(index as int)),\n            match prod_value {\n                None =>   // Computing the product overflowed at some point\n                exists|i|\n                    #![auto]\n                    0 <= i < index && product(numbers@.subrange(0, i)) * numbers[i] as int\n                        > u32::MAX,\n                Some(v) => v == product(numbers@.take(index as int)),\n            },\n            index <= numbers.len(),\n            index >= 0,\n    {\n        proof {\n            sum_bound(numbers@.take(index as int));\n            assert(sum_value <= index * u32::MAX);\n        }\n        assert(numbers@.take(index as int + 1).drop_last() =~= numbers@.take(index as int));\n        assert(numbers[index as int] == numbers@.take(index as int + 1).last());\n        sum_value += numbers[index] as u64;\n        prod_value =\n        match prod_value {\n            Some(v) => v.checked_mul(numbers[index]),\n            None => None,\n        };\n    }\n    assert(numbers@.take(numbers@.len() as int) =~= numbers@);\n    (sum_value, prod_value)\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n/// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<u32>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n/// Specification for taking the product of a sequence of numbers\npub open spec fn product(numbers: Seq<u32>) -> int {\n    numbers.fold_left(1, |acc: int, x| acc * x)\n}\n\n/// Show that the sum won't grow too large\nproof fn sum_bound(numbers: Seq<u32>)\n    ensures\n        sum(numbers) <= numbers.len() * u32::MAX,\n    decreases numbers.len(),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n/// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<u32>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n/// Specification for taking the product of a sequence of numbers\npub open spec fn product(numbers: Seq<u32>) -> int {\n    numbers.fold_left(1, |acc: int, x| acc * x)\n}\n\n/// Show that the sum won't grow too large\nproof fn sum_bound(numbers: Seq<u32>)\n    ensures\n        sum(numbers) <= numbers.len() * u32::MAX,\n    decreases numbers.len(),\n{\n    if numbers.len() == 0 {\n    } else {\n        sum_bound(numbers.drop_last());\n    }\n}\n\n/// Implementation.  We leave the consequences of an intermediate\n/// overflow during the product calculation underspecified.\nfn sum_product(numbers: Vec<u32>) -> (result: (u64, Option<u32>))\n    requires\n        numbers.len() < u32::MAX,\n    ensures\n        result.0 == sum(numbers@),\n        match result.1 {\n            None =>   // Computing the product overflowed at some point\n            exists|i|\n                #![auto]\n                0 <= i < numbers.len() && product(numbers@.subrange(0, i)) * numbers[i] as int\n                    > u32::MAX,\n            Some(v) => v == product(numbers@),\n        },\n{\n    let mut sum_value: u64 = 0;\n    let mut prod_value: Option<u32> = Some(1);\n    for index in 0..numbers.len()\n        invariant\n            numbers.len() < u32::MAX,\n            sum_value == sum(numbers@.take(index as int)),\n            prod_value matches Some(v) ==> v == product(numbers@.take(index as int)),\n            match prod_value {\n                None =>   // Computing the product overflowed at some point\n                exists|i|\n                    #![auto]\n                    0 <= i < index && product(numbers@.subrange(0, i)) * numbers[i] as int\n                        > u32::MAX,\n                Some(v) => v == product(numbers@.take(index as int)),\n            },\n            index <= numbers.len(),\n            index >= 0,\n    {\n        proof {\n            sum_bound(numbers@.take(index as int));\n            assert(sum_value <= index * u32::MAX);\n        }\n        assert(numbers@.take(index as int + 1).drop_last() =~= numbers@.take(index as int));\n        assert(numbers[index as int] == numbers@.take(index as int + 1).last());\n        sum_value += numbers[index] as u64;\n        prod_value =\n        match prod_value {\n            Some(v) => v.checked_mul(numbers[index]),\n            None => None,\n        };\n    }\n    assert(numbers@.take(numbers@.len() as int) =~= numbers@);\n    (sum_value, prod_value)\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n/// Specification for what it means to sum a sequence of numbers\npub open spec fn sum(numbers: Seq<u32>) -> int {\n    numbers.fold_left(0, |acc: int, x| acc + x)\n}\n\n/// Specification for taking the product of a sequence of numbers\npub open spec fn product(numbers: Seq<u32>) -> int {\n    numbers.fold_left(1, |acc: int, x| acc * x)\n}\n\n/// Show that the sum won't grow too large\nproof fn sum_bound(numbers: Seq<u32>)\n    ensures\n        sum(numbers) <= numbers.len() * u32::MAX,\n    decreases numbers.len(),\n{\n    if numbers.len() == 0 {\n    } else {\n        sum_bound(numbers.drop_last());\n    }\n}\n\n/// Implementation.  We leave the consequences of an intermediate\n/// overflow during the product calculation underspecified.\nfn sum_product(numbers: Vec<u32>) -> (result: (u64, Option<u32>))\n    requires\n        numbers.len() < u32::MAX,\n    ensures\n        result.0 == sum(numbers@),\n        match result.1 {\n            None =>   // Computing the product overflowed at some point\n            exists|i|\n                #![auto]\n                0 <= i < numbers.len() && product(numbers@.subrange(0, i)) * numbers[i] as int\n                    > u32::MAX,\n            Some(v) => v == product(numbers@),\n        },\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn seq_max(a: Seq<i32>) -> i32\n    decreases a.len(),\n{\n    if a.len() == 0 {\n        i32::MIN\n    } else if a.last() > seq_max(a.drop_last()) {\n        a.last()\n    } else {\n        seq_max(a.drop_last())\n    }\n}\n\nfn rolling_max(numbers: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == numbers.len(),  // result vector should have the same length as input\n        forall|i: int| 0 <= i < numbers.len() ==> result[i] == seq_max(numbers@.take(i + 1)),\n{\n    let mut max_so_far = i32::MIN;\n    let mut result = Vec::with_capacity(numbers.len());\n    for pos in 0..numbers.len()\n        invariant\n            result.len() == pos,\n            max_so_far == seq_max(numbers@.take(pos as int)),\n            forall|i: int| 0 <= i < pos ==> result[i] == seq_max(numbers@.take(i + 1)),\n    {\n        let number = numbers[pos];\n        if number > max_so_far {\n            max_so_far = number;\n        }\n        result.push(max_so_far);\n        assert(numbers@.take((pos + 1) as int).drop_last() =~= numbers@.take(pos as int));\n    }\n    result\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn seq_max(a: Seq<i32>) -> i32\n    decreases a.len(),\n{\n    if a.len() == 0 {\n        i32::MIN\n    } else if a.last() > seq_max(a.drop_last()) {\n        a.last()\n    } else {\n        seq_max(a.drop_last())\n    }\n}\n\nfn rolling_max(numbers: Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        result.len() == numbers.len(),  // result vector should have the same length as input\n        forall|i: int| 0 <= i < numbers.len() ==> result[i] == seq_max(numbers@.take(i + 1)),\n{"}
{"y": "use vstd::prelude::*;\nuse vstd::slice::*;\n\nverus! {\n\n/// helper function to check if a character is '0' or '1'\nspec fn is_binary_digit(c: char) -> bool {\n    c == '0' || c == '1'\n}\n\n/// helper function to perform XOR on two binary characters\nspec fn xor_char(a: char, b: char) -> (result: char)\n    recommends\n        is_binary_digit(a),\n        is_binary_digit(b),\n{\n    if a == b {\n        '0'\n    } else {\n        '1'\n    }\n}\n\nfn string_xor(a: &[char], b: &[char]) -> (result: Vec<char>)\n    requires\n        a@.len() == b@.len(),  // both strings must be of equal length\n        forall|i: int| 0 <= i < a@.len() as int ==> is_binary_digit(#[trigger] a[i]),\n        forall|i: int| 0 <= i < b@.len() as int ==> is_binary_digit(#[trigger] b[i]),\n    ensures\n        result.len() == a@.len(),\n        forall|i: int|\n            0 <= i < result.len() as int ==> #[trigger] result[i] == xor_char(a[i], b[i]),\n{\n    let a_len = a.len();\n    let mut result = Vec::with_capacity(a_len);\n    #[verifier::loop_isolation(false)]\n    for pos in 0..a_len\n        invariant\n            result.len() == pos,\n            forall|i: int| 0 <= i < pos ==> #[trigger] result[i] == xor_char(a[i], b[i]),\n    {\n        if *slice_index_get(a, pos) == *slice_index_get(b, pos) {\n            result.push('0');\n        } else {\n            result.push('1');\n        }\n    }\n    result\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\nuse vstd::slice::*;\n\nverus! {\n\n/// helper function to check if a character is '0' or '1'\nspec fn is_binary_digit(c: char) -> bool {\n    c == '0' || c == '1'\n}\n\n/// helper function to perform XOR on two binary characters\nspec fn xor_char(a: char, b: char) -> (result: char)\n    recommends\n        is_binary_digit(a),\n        is_binary_digit(b),\n{\n    if a == b {\n        '0'\n    } else {\n        '1'\n    }\n}\n\nfn string_xor(a: &[char], b: &[char]) -> (result: Vec<char>)\n    requires\n        a@.len() == b@.len(),  // both strings must be of equal length\n        forall|i: int| 0 <= i < a@.len() as int ==> is_binary_digit(#[trigger] a[i]),\n        forall|i: int| 0 <= i < b@.len() as int ==> is_binary_digit(#[trigger] b[i]),\n    ensures\n        result.len() == a@.len(),\n        forall|i: int|\n            0 <= i < result.len() as int ==> #[trigger] result[i] == xor_char(a[i], b[i]),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn single_digit_number_to_char(n: nat) -> char {\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub closed spec fn number_to_char(n: nat) -> Seq<char>\n    decreases n,\n{\n    if (n == 0) {\n        seq![]\n    } else {\n        number_to_char(n / 10).add(seq![single_digit_number_to_char(n % 10)])\n    }\n}\n\npub open spec fn string_sequence(n: nat) -> Seq<char>\n    decreases n,\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        string_sequence((n - 1) as nat).add(seq![' '].add(number_to_char(n)))\n    }\n}\n\nproof fn sanity_check() {\n    assert(string_sequence(1) == seq!['0', ' ', '1']) by (compute);\n    assert(string_sequence(3) == seq!['0', ' ', '1', ' ', '2', ' ', '3']) by (compute);\n    assert(string_sequence(12) == seq![\n        '0',\n        ' ',\n        '1',\n        ' ',\n        '2',\n        ' ',\n        '3',\n        ' ',\n        '4',\n        ' ',\n        '5',\n        ' ',\n        '6',\n        ' ',\n        '7',\n        ' ',\n        '8',\n        ' ',\n        '9',\n        ' ',\n        '1',\n        '0',\n        ' ',\n        '1',\n        '1',\n        ' ',\n        '1',\n        '2',\n    ]) by (compute);\n    assert((number_to_char(158) == seq!['1', '5', '8'])) by (compute);\n}\n\n// implementation\nfn single_digit_number_to_char_impl(n: u8) -> (output: char)\n    requires\n        0 <= n <= 9,\n    ensures\n        single_digit_number_to_char(n as nat) == output,\n{\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub fn number_to_char_impl(n: u8) -> (char_vec: Vec<char>)\n    ensures\n        char_vec@ == number_to_char(n as nat),\n{\n    let mut i = n;\n    let mut output = vec![];\n\n    while (i > 0)\n        invariant\n            number_to_char(n as nat) == number_to_char(i as nat).add(output@),\n    {\n        let m = i % 10;\n        let current = single_digit_number_to_char_impl(m);\n        output.insert(0, current);\n        i = i / 10;\n\n        assert(number_to_char(n as nat) == number_to_char(i as nat).add(output@));\n    }\n    return output;\n}\n\nfn string_sequence_impl(n: u8) -> (string_seq: Vec<char>)\n    ensures\n        string_seq@ == string_sequence(n as nat),\n{\n    let mut i = n;\n    let mut output = vec![];\n    while (i > 0)\n        invariant\n            n >= i >= 0,\n            string_sequence(n as nat) == string_sequence(i as nat) + output@,\n        decreases i,\n    {\n        let mut next = number_to_char_impl(i);\n        next.append(&mut output);\n        output = next;\n        output.insert(0, ' ');\n        i = i - 1;\n\n        assert(string_sequence((n) as nat) == string_sequence((i) as nat) + output@);\n    }\n    output.insert(0, '0');\n    assert(string_sequence(n as nat) == output@);\n    return output;\n}\n\n} // verus!\nfn main() {\n    print!(\"{:?}\", string_sequence_impl(0));\n    print!(\"{:?}\", string_sequence_impl(5));\n    print!(\"{:?}\", string_sequence_impl(20));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nstring_sequence\n*/\n\n/*\n### CANONICAL SOLUTION\n    return ' '.join([str(x) for x in range(n + 1)])\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn single_digit_number_to_char(n: nat) -> char {\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub closed spec fn number_to_char(n: nat) -> Seq<char>\n    decreases n,\n{\n    if (n == 0) {\n        seq![]\n    } else {\n        number_to_char(n / 10).add(seq![single_digit_number_to_char(n % 10)])\n    }\n}\n\npub open spec fn string_sequence(n: nat) -> Seq<char>\n    decreases n,\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        string_sequence((n - 1) as nat).add(seq![' '].add(number_to_char(n)))\n    }\n}\n\nproof fn sanity_check() {\n    assert(string_sequence(1) == seq!['0', ' ', '1']) by (compute);\n    assert(string_sequence(3) == seq!['0', ' ', '1', ' ', '2', ' ', '3']) by (compute);\n    assert(string_sequence(12) == seq![\n        '0',\n        ' ',\n        '1',\n        ' ',\n        '2',\n        ' ',\n        '3',\n        ' ',\n        '4',\n        ' ',\n        '5',\n        ' ',\n        '6',\n        ' ',\n        '7',\n        ' ',\n        '8',\n        ' ',\n        '9',\n        ' ',\n        '1',\n        '0',\n        ' ',\n        '1',\n        '1',\n        ' ',\n        '1',\n        '2',\n    ]) by (compute);\n    assert((number_to_char(158) == seq!['1', '5', '8'])) by (compute);\n}\n\n// implementation\nfn single_digit_number_to_char_impl(n: u8) -> (output: char)\n    requires\n        0 <= n <= 9,\n    ensures\n        single_digit_number_to_char(n as nat) == output,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn single_digit_number_to_char(n: nat) -> char {\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub closed spec fn number_to_char(n: nat) -> Seq<char>\n    decreases n,\n{\n    if (n == 0) {\n        seq![]\n    } else {\n        number_to_char(n / 10).add(seq![single_digit_number_to_char(n % 10)])\n    }\n}\n\npub open spec fn string_sequence(n: nat) -> Seq<char>\n    decreases n,\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        string_sequence((n - 1) as nat).add(seq![' '].add(number_to_char(n)))\n    }\n}\n\nproof fn sanity_check() {\n    assert(string_sequence(1) == seq!['0', ' ', '1']) by (compute);\n    assert(string_sequence(3) == seq!['0', ' ', '1', ' ', '2', ' ', '3']) by (compute);\n    assert(string_sequence(12) == seq![\n        '0',\n        ' ',\n        '1',\n        ' ',\n        '2',\n        ' ',\n        '3',\n        ' ',\n        '4',\n        ' ',\n        '5',\n        ' ',\n        '6',\n        ' ',\n        '7',\n        ' ',\n        '8',\n        ' ',\n        '9',\n        ' ',\n        '1',\n        '0',\n        ' ',\n        '1',\n        '1',\n        ' ',\n        '1',\n        '2',\n    ]) by (compute);\n    assert((number_to_char(158) == seq!['1', '5', '8'])) by (compute);\n}\n\n// implementation\nfn single_digit_number_to_char_impl(n: u8) -> (output: char)\n    requires\n        0 <= n <= 9,\n    ensures\n        single_digit_number_to_char(n as nat) == output,\n{\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub fn number_to_char_impl(n: u8) -> (char_vec: Vec<char>)\n    ensures\n        char_vec@ == number_to_char(n as nat),\n{\n    let mut i = n;\n    let mut output = vec![];\n\n    while (i > 0)\n        invariant\n            number_to_char(n as nat) == number_to_char(i as nat).add(output@),\n    {\n        let m = i % 10;\n        let current = single_digit_number_to_char_impl(m);\n        output.insert(0, current);\n        i = i / 10;\n\n        assert(number_to_char(n as nat) == number_to_char(i as nat).add(output@));\n    }\n    return output;\n}\n\nfn string_sequence_impl(n: u8) -> (string_seq: Vec<char>)\n    ensures\n        string_seq@ == string_sequence(n as nat),\n{\n    let mut i = n;\n    let mut output = vec![];\n    while (i > 0)\n        invariant\n            n >= i >= 0,\n            string_sequence(n as nat) == string_sequence(i as nat) + output@,\n        decreases i,\n    {\n        let mut next = number_to_char_impl(i);\n        next.append(&mut output);\n        output = next;\n        output.insert(0, ' ');\n        i = i - 1;\n\n        assert(string_sequence((n) as nat) == string_sequence((i) as nat) + output@);\n    }\n    output.insert(0, '0');\n    assert(string_sequence(n as nat) == output@);\n    return output;\n}\n\n} // verus!\nfn main() {\n    print!(\"{:?}\", string_sequence_impl(0));\n    print!(\"{:?}\", string_sequence_impl(5));\n    print!(\"{:?}\", string_sequence_impl(20));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nstring_sequence\n*/\n\n/*\n### CANONICAL SOLUTION\n    return ' '.join([str(x) for x in range(n + 1)])\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn single_digit_number_to_char(n: nat) -> char {\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub closed spec fn number_to_char(n: nat) -> Seq<char>\n    decreases n,\n{\n    if (n == 0) {\n        seq![]\n    } else {\n        number_to_char(n / 10).add(seq![single_digit_number_to_char(n % 10)])\n    }\n}\n\npub open spec fn string_sequence(n: nat) -> Seq<char>\n    decreases n,\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        string_sequence((n - 1) as nat).add(seq![' '].add(number_to_char(n)))\n    }\n}\n\nproof fn sanity_check() {\n    assert(string_sequence(1) == seq!['0', ' ', '1']) by (compute);\n    assert(string_sequence(3) == seq!['0', ' ', '1', ' ', '2', ' ', '3']) by (compute);\n    assert(string_sequence(12) == seq![\n        '0',\n        ' ',\n        '1',\n        ' ',\n        '2',\n        ' ',\n        '3',\n        ' ',\n        '4',\n        ' ',\n        '5',\n        ' ',\n        '6',\n        ' ',\n        '7',\n        ' ',\n        '8',\n        ' ',\n        '9',\n        ' ',\n        '1',\n        '0',\n        ' ',\n        '1',\n        '1',\n        ' ',\n        '1',\n        '2',\n    ]) by (compute);\n    assert((number_to_char(158) == seq!['1', '5', '8'])) by (compute);\n}\n\n// implementation\nfn single_digit_number_to_char_impl(n: u8) -> (output: char)\n    requires\n        0 <= n <= 9,\n    ensures\n        single_digit_number_to_char(n as nat) == output,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn single_digit_number_to_char(n: nat) -> char {\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub closed spec fn number_to_char(n: nat) -> Seq<char>\n    decreases n,\n{\n    if (n == 0) {\n        seq![]\n    } else {\n        number_to_char(n / 10).add(seq![single_digit_number_to_char(n % 10)])\n    }\n}\n\npub open spec fn string_sequence(n: nat) -> Seq<char>\n    decreases n,\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        string_sequence((n - 1) as nat).add(seq![' '].add(number_to_char(n)))\n    }\n}\n\nproof fn sanity_check() {\n    assert(string_sequence(1) == seq!['0', ' ', '1']) by (compute);\n    assert(string_sequence(3) == seq!['0', ' ', '1', ' ', '2', ' ', '3']) by (compute);\n    assert(string_sequence(12) == seq![\n        '0',\n        ' ',\n        '1',\n        ' ',\n        '2',\n        ' ',\n        '3',\n        ' ',\n        '4',\n        ' ',\n        '5',\n        ' ',\n        '6',\n        ' ',\n        '7',\n        ' ',\n        '8',\n        ' ',\n        '9',\n        ' ',\n        '1',\n        '0',\n        ' ',\n        '1',\n        '1',\n        ' ',\n        '1',\n        '2',\n    ]) by (compute);\n    assert((number_to_char(158) == seq!['1', '5', '8'])) by (compute);\n}\n\n// implementation\nfn single_digit_number_to_char_impl(n: u8) -> (output: char)\n    requires\n        0 <= n <= 9,\n    ensures\n        single_digit_number_to_char(n as nat) == output,\n{\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub fn number_to_char_impl(n: u8) -> (char_vec: Vec<char>)\n    ensures\n        char_vec@ == number_to_char(n as nat),\n{\n    let mut i = n;\n    let mut output = vec![];\n\n    while (i > 0)\n        invariant\n            number_to_char(n as nat) == number_to_char(i as nat).add(output@),\n    {\n        let m = i % 10;\n        let current = single_digit_number_to_char_impl(m);\n        output.insert(0, current);\n        i = i / 10;\n\n        assert(number_to_char(n as nat) == number_to_char(i as nat).add(output@));\n    }\n    return output;\n}\n\nfn string_sequence_impl(n: u8) -> (string_seq: Vec<char>)\n    ensures\n        string_seq@ == string_sequence(n as nat),\n{\n    let mut i = n;\n    let mut output = vec![];\n    while (i > 0)\n        invariant\n            n >= i >= 0,\n            string_sequence(n as nat) == string_sequence(i as nat) + output@,\n        decreases i,\n    {\n        let mut next = number_to_char_impl(i);\n        next.append(&mut output);\n        output = next;\n        output.insert(0, ' ');\n        i = i - 1;\n\n        assert(string_sequence((n) as nat) == string_sequence((i) as nat) + output@);\n    }\n    output.insert(0, '0');\n    assert(string_sequence(n as nat) == output@);\n    return output;\n}\n\n} // verus!\nfn main() {\n    print!(\"{:?}\", string_sequence_impl(0));\n    print!(\"{:?}\", string_sequence_impl(5));\n    print!(\"{:?}\", string_sequence_impl(20));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nstring_sequence\n*/\n\n/*\n### CANONICAL SOLUTION\n    return ' '.join([str(x) for x in range(n + 1)])\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn single_digit_number_to_char(n: nat) -> char {\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub closed spec fn number_to_char(n: nat) -> Seq<char>\n    decreases n,\n{\n    if (n == 0) {\n        seq![]\n    } else {\n        number_to_char(n / 10).add(seq![single_digit_number_to_char(n % 10)])\n    }\n}\n\npub open spec fn string_sequence(n: nat) -> Seq<char>\n    decreases n,\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        string_sequence((n - 1) as nat).add(seq![' '].add(number_to_char(n)))\n    }\n}\n\nproof fn sanity_check() {\n    assert(string_sequence(1) == seq!['0', ' ', '1']) by (compute);\n    assert(string_sequence(3) == seq!['0', ' ', '1', ' ', '2', ' ', '3']) by (compute);\n    assert(string_sequence(12) == seq![\n        '0',\n        ' ',\n        '1',\n        ' ',\n        '2',\n        ' ',\n        '3',\n        ' ',\n        '4',\n        ' ',\n        '5',\n        ' ',\n        '6',\n        ' ',\n        '7',\n        ' ',\n        '8',\n        ' ',\n        '9',\n        ' ',\n        '1',\n        '0',\n        ' ',\n        '1',\n        '1',\n        ' ',\n        '1',\n        '2',\n    ]) by (compute);\n    assert((number_to_char(158) == seq!['1', '5', '8'])) by (compute);\n}\n\n// implementation\nfn single_digit_number_to_char_impl(n: u8) -> (output: char)\n    requires\n        0 <= n <= 9,\n    ensures\n        single_digit_number_to_char(n as nat) == output,\n{\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub fn number_to_char_impl(n: u8) -> (char_vec: Vec<char>)\n    ensures\n        char_vec@ == number_to_char(n as nat),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn single_digit_number_to_char(n: nat) -> char {\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub closed spec fn number_to_char(n: nat) -> Seq<char>\n    decreases n,\n{\n    if (n == 0) {\n        seq![]\n    } else {\n        number_to_char(n / 10).add(seq![single_digit_number_to_char(n % 10)])\n    }\n}\n\npub open spec fn string_sequence(n: nat) -> Seq<char>\n    decreases n,\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        string_sequence((n - 1) as nat).add(seq![' '].add(number_to_char(n)))\n    }\n}\n\nproof fn sanity_check() {\n    assert(string_sequence(1) == seq!['0', ' ', '1']) by (compute);\n    assert(string_sequence(3) == seq!['0', ' ', '1', ' ', '2', ' ', '3']) by (compute);\n    assert(string_sequence(12) == seq![\n        '0',\n        ' ',\n        '1',\n        ' ',\n        '2',\n        ' ',\n        '3',\n        ' ',\n        '4',\n        ' ',\n        '5',\n        ' ',\n        '6',\n        ' ',\n        '7',\n        ' ',\n        '8',\n        ' ',\n        '9',\n        ' ',\n        '1',\n        '0',\n        ' ',\n        '1',\n        '1',\n        ' ',\n        '1',\n        '2',\n    ]) by (compute);\n    assert((number_to_char(158) == seq!['1', '5', '8'])) by (compute);\n}\n\n// implementation\nfn single_digit_number_to_char_impl(n: u8) -> (output: char)\n    requires\n        0 <= n <= 9,\n    ensures\n        single_digit_number_to_char(n as nat) == output,\n{\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub fn number_to_char_impl(n: u8) -> (char_vec: Vec<char>)\n    ensures\n        char_vec@ == number_to_char(n as nat),\n{\n    let mut i = n;\n    let mut output = vec![];\n\n    while (i > 0)\n        invariant\n            number_to_char(n as nat) == number_to_char(i as nat).add(output@),\n    {\n        let m = i % 10;\n        let current = single_digit_number_to_char_impl(m);\n        output.insert(0, current);\n        i = i / 10;\n\n        assert(number_to_char(n as nat) == number_to_char(i as nat).add(output@));\n    }\n    return output;\n}\n\nfn string_sequence_impl(n: u8) -> (string_seq: Vec<char>)\n    ensures\n        string_seq@ == string_sequence(n as nat),\n{\n    let mut i = n;\n    let mut output = vec![];\n    while (i > 0)\n        invariant\n            n >= i >= 0,\n            string_sequence(n as nat) == string_sequence(i as nat) + output@,\n        decreases i,\n    {\n        let mut next = number_to_char_impl(i);\n        next.append(&mut output);\n        output = next;\n        output.insert(0, ' ');\n        i = i - 1;\n\n        assert(string_sequence((n) as nat) == string_sequence((i) as nat) + output@);\n    }\n    output.insert(0, '0');\n    assert(string_sequence(n as nat) == output@);\n    return output;\n}\n\n} // verus!\nfn main() {\n    print!(\"{:?}\", string_sequence_impl(0));\n    print!(\"{:?}\", string_sequence_impl(5));\n    print!(\"{:?}\", string_sequence_impl(20));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nstring_sequence\n*/\n\n/*\n### CANONICAL SOLUTION\n    return ' '.join([str(x) for x in range(n + 1)])\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn single_digit_number_to_char(n: nat) -> char {\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub closed spec fn number_to_char(n: nat) -> Seq<char>\n    decreases n,\n{\n    if (n == 0) {\n        seq![]\n    } else {\n        number_to_char(n / 10).add(seq![single_digit_number_to_char(n % 10)])\n    }\n}\n\npub open spec fn string_sequence(n: nat) -> Seq<char>\n    decreases n,\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        string_sequence((n - 1) as nat).add(seq![' '].add(number_to_char(n)))\n    }\n}\n\nproof fn sanity_check() {\n    assert(string_sequence(1) == seq!['0', ' ', '1']) by (compute);\n    assert(string_sequence(3) == seq!['0', ' ', '1', ' ', '2', ' ', '3']) by (compute);\n    assert(string_sequence(12) == seq![\n        '0',\n        ' ',\n        '1',\n        ' ',\n        '2',\n        ' ',\n        '3',\n        ' ',\n        '4',\n        ' ',\n        '5',\n        ' ',\n        '6',\n        ' ',\n        '7',\n        ' ',\n        '8',\n        ' ',\n        '9',\n        ' ',\n        '1',\n        '0',\n        ' ',\n        '1',\n        '1',\n        ' ',\n        '1',\n        '2',\n    ]) by (compute);\n    assert((number_to_char(158) == seq!['1', '5', '8'])) by (compute);\n}\n\n// implementation\nfn single_digit_number_to_char_impl(n: u8) -> (output: char)\n    requires\n        0 <= n <= 9,\n    ensures\n        single_digit_number_to_char(n as nat) == output,\n{\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub fn number_to_char_impl(n: u8) -> (char_vec: Vec<char>)\n    ensures\n        char_vec@ == number_to_char(n as nat),\n{\n    let mut i = n;\n    let mut output = vec![];\n\n    while (i > 0)\n        invariant\n            number_to_char(n as nat) == number_to_char(i as nat).add(output@),\n    {\n        let m = i % 10;\n        let current = single_digit_number_to_char_impl(m);\n        output.insert(0, current);\n        i = i / 10;\n\n        assert(number_to_char(n as nat) == number_to_char(i as nat).add(output@));\n    }\n    return output;\n}\n\nfn string_sequence_impl(n: u8) -> (string_seq: Vec<char>)\n    ensures\n        string_seq@ == string_sequence(n as nat),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn single_digit_number_to_char(n: nat) -> char {\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub closed spec fn number_to_char(n: nat) -> Seq<char>\n    decreases n,\n{\n    if (n == 0) {\n        seq![]\n    } else {\n        number_to_char(n / 10).add(seq![single_digit_number_to_char(n % 10)])\n    }\n}\n\npub open spec fn string_sequence(n: nat) -> Seq<char>\n    decreases n,\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        string_sequence((n - 1) as nat).add(seq![' '].add(number_to_char(n)))\n    }\n}\n\nproof fn sanity_check() {\n    assert(string_sequence(1) == seq!['0', ' ', '1']) by (compute);\n    assert(string_sequence(3) == seq!['0', ' ', '1', ' ', '2', ' ', '3']) by (compute);\n    assert(string_sequence(12) == seq![\n        '0',\n        ' ',\n        '1',\n        ' ',\n        '2',\n        ' ',\n        '3',\n        ' ',\n        '4',\n        ' ',\n        '5',\n        ' ',\n        '6',\n        ' ',\n        '7',\n        ' ',\n        '8',\n        ' ',\n        '9',\n        ' ',\n        '1',\n        '0',\n        ' ',\n        '1',\n        '1',\n        ' ',\n        '1',\n        '2',\n    ]) by (compute);\n    assert((number_to_char(158) == seq!['1', '5', '8'])) by (compute);\n}\n\n// implementation\nfn single_digit_number_to_char_impl(n: u8) -> (output: char)\n    requires\n        0 <= n <= 9,\n    ensures\n        single_digit_number_to_char(n as nat) == output,\n{\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub fn number_to_char_impl(n: u8) -> (char_vec: Vec<char>)\n    ensures\n        char_vec@ == number_to_char(n as nat),\n{\n    let mut i = n;\n    let mut output = vec![];\n\n    while (i > 0)\n        invariant\n            number_to_char(n as nat) == number_to_char(i as nat).add(output@),\n    {\n        let m = i % 10;\n        let current = single_digit_number_to_char_impl(m);\n        output.insert(0, current);\n        i = i / 10;\n\n        assert(number_to_char(n as nat) == number_to_char(i as nat).add(output@));\n    }\n    return output;\n}\n\nfn string_sequence_impl(n: u8) -> (string_seq: Vec<char>)\n    ensures\n        string_seq@ == string_sequence(n as nat),\n{\n    let mut i = n;\n    let mut output = vec![];\n    while (i > 0)\n        invariant\n            n >= i >= 0,\n            string_sequence(n as nat) == string_sequence(i as nat) + output@,\n        decreases i,\n    {\n        let mut next = number_to_char_impl(i);\n        next.append(&mut output);\n        output = next;\n        output.insert(0, ' ');\n        i = i - 1;\n\n        assert(string_sequence((n) as nat) == string_sequence((i) as nat) + output@);\n    }\n    output.insert(0, '0');\n    assert(string_sequence(n as nat) == output@);\n    return output;\n}\n\n} // verus!\nfn main() {\n    print!(\"{:?}\", string_sequence_impl(0));\n    print!(\"{:?}\", string_sequence_impl(5));\n    print!(\"{:?}\", string_sequence_impl(20));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\n\ndef string_sequence(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nstring_sequence\n*/\n\n/*\n### CANONICAL SOLUTION\n    return ' '.join([str(x) for x in range(n + 1)])\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn single_digit_number_to_char(n: nat) -> char {\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub closed spec fn number_to_char(n: nat) -> Seq<char>\n    decreases n,\n{\n    if (n == 0) {\n        seq![]\n    } else {\n        number_to_char(n / 10).add(seq![single_digit_number_to_char(n % 10)])\n    }\n}\n\npub open spec fn string_sequence(n: nat) -> Seq<char>\n    decreases n,\n{\n    if n == 0 {\n        seq!['0']\n    } else {\n        string_sequence((n - 1) as nat).add(seq![' '].add(number_to_char(n)))\n    }\n}\n\nproof fn sanity_check() {\n    assert(string_sequence(1) == seq!['0', ' ', '1']) by (compute);\n    assert(string_sequence(3) == seq!['0', ' ', '1', ' ', '2', ' ', '3']) by (compute);\n    assert(string_sequence(12) == seq![\n        '0',\n        ' ',\n        '1',\n        ' ',\n        '2',\n        ' ',\n        '3',\n        ' ',\n        '4',\n        ' ',\n        '5',\n        ' ',\n        '6',\n        ' ',\n        '7',\n        ' ',\n        '8',\n        ' ',\n        '9',\n        ' ',\n        '1',\n        '0',\n        ' ',\n        '1',\n        '1',\n        ' ',\n        '1',\n        '2',\n    ]) by (compute);\n    assert((number_to_char(158) == seq!['1', '5', '8'])) by (compute);\n}\n\n// implementation\nfn single_digit_number_to_char_impl(n: u8) -> (output: char)\n    requires\n        0 <= n <= 9,\n    ensures\n        single_digit_number_to_char(n as nat) == output,\n{\n    if n == 0 {\n        '0'\n    } else if n == 1 {\n        '1'\n    } else if n == 2 {\n        '2'\n    } else if n == 3 {\n        '3'\n    } else if n == 4 {\n        '4'\n    } else if n == 5 {\n        '5'\n    } else if n == 6 {\n        '6'\n    } else if n == 7 {\n        '7'\n    } else if n == 8 {\n        '8'\n    } else {\n        '9'\n    }\n}\n\npub fn number_to_char_impl(n: u8) -> (char_vec: Vec<char>)\n    ensures\n        char_vec@ == number_to_char(n as nat),\n{\n    let mut i = n;\n    let mut output = vec![];\n\n    while (i > 0)\n        invariant\n            number_to_char(n as nat) == number_to_char(i as nat).add(output@),\n    {\n        let m = i % 10;\n        let current = single_digit_number_to_char_impl(m);\n        output.insert(0, current);\n        i = i / 10;\n\n        assert(number_to_char(n as nat) == number_to_char(i as nat).add(output@));\n    }\n    return output;\n}\n\nfn string_sequence_impl(n: u8) -> (string_seq: Vec<char>)\n    ensures\n        string_seq@ == string_sequence(n as nat),\n{\n    let mut i = n;\n    let mut output = vec![];\n    while (i > 0)\n        invariant\n            n >= i >= 0,\n            string_sequence(n as nat) == string_sequence(i as nat) + output@,\n        decreases i,\n    {\n        let mut next = number_to_char_impl(i);\n        next.append(&mut output);\n        output = next;\n        output.insert(0, ' ');\n        i = i - 1;\n\n        assert(string_sequence((n) as nat) == string_sequence((i) as nat) + output@);\n    }\n    output.insert(0, '0');\n    assert(string_sequence(n as nat) == output@);\n    return output;\n}\n\n} // verus!\nf"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// spec\npub closed spec fn how_many_times(string: Seq<char>, substring: Seq<char>) -> nat\n    decreases string.len(),\n{\n    if (string.len() == 0) {\n        0\n    } else if substring.is_prefix_of(string) {\n        1 + how_many_times(string.skip(1), substring)\n    } else {\n        how_many_times(string.skip(1), substring)\n    }\n}\n\n// implementation\nproof fn lemma_step_subrange(substring: Seq<char>, string: Seq<char>)\n    requires\n        substring.len() > 0,\n        string.len() >= substring.len(),\n    ensures\n        (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n            =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) ==> (substring\n            =~= string.subrange(0, substring.len() as int)),\n    decreases substring.len(),\n{\n    if (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n        =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) {\n        assert forall|i: int| 0 <= i < substring.len() implies #[trigger] substring[i]\n            == string.subrange(0, substring.len() as int)[i] by {\n            if i == 0 {\n            } else {\n                assert(forall|j: int|\n                    (0 <= #[trigger] (j + 0) < substring.len() - 1) ==> substring.skip(1)[j]\n                        == string.skip(1).subrange(0, substring.skip(1).len() as int)[j]);\n                assert(0 <= #[trigger] (i - 1 + 0) < substring.len() - 1);\n            }\n        }\n    } else {\n    }\n}\n\nfn is_prefix(substring: Vec<char>, string: Vec<char>) -> (b: bool)\n    ensures\n        b == substring@.is_prefix_of(string@),\n{\n    let mut current_substring = substring.clone();\n    let mut current_string = string.clone();\n\n    if substring.len() > string.len() {\n        return false\n    }\n    while (current_substring.len() > 0)\n        invariant\n            0 <= current_substring.len() <= current_string.len(),\n            substring.len() <= string.len(),\n            (substring@ =~= string@.subrange(0, substring@.len() as int)) == (current_substring@\n                =~= current_string@.subrange(0, current_substring@.len() as int)),\n        decreases current_substring.len(),\n    {\n        if (current_substring[0] != current_string[0]) {\n            return false;\n        }\n        let old_substring = current_substring.clone();\n        let old_string = current_string.clone();\n\n        let substring_first = current_substring.remove(0);\n        let string_first = current_string.remove(0);\n        assert((old_substring@ =~= old_string@.subrange(0, old_substring@.len() as int)) <== (\n        old_substring@[0] == old_string@.subrange(0, old_substring@.len() as int)[0] && (\n        old_substring@.skip(1) =~= old_string@.skip(1).subrange(\n            0,\n            old_substring@.skip(1).len() as int,\n        )))) by { lemma_step_subrange(old_substring@, old_string@) };\n    }\n    return true;\n}\n\nproof fn lemma_how_many_times_zero(string: Seq<char>, substring: Seq<char>)\n    requires\n        string.len() < substring.len(),\n    ensures\n        how_many_times(string, substring) == 0,\n    decreases string.len(),\n{\n    if string.len() == 0 {\n    } else {\n        lemma_how_many_times_zero(string.skip(1), substring)\n    }\n}\n\nfn how_many_times_impl(string: Vec<char>, substring: Vec<char>) -> (opt_k: Option<u32>)\n    requires\n        substring.len() >= 1,\n    ensures\n        match opt_k {\n            Some(k) => k as nat == how_many_times(string@, substring@),\n            None => how_many_times(string@, substring@) > u32::MAX,\n        },\n{\n    let mut k = 0u64;\n    let mut current_string = string;\n    while current_string.len() >= substring.len()\n        invariant\n            how_many_times(string@, substring@) == k + how_many_times(current_string@, substring@),\n            k <= u32::MAX as u64,\n            substring.len() >= 1,\n        decreases current_string.len(),\n    {\n        if (is_prefix(substring.clone(), current_string.clone())) {\n            if (k >= u32::MAX as u64) {\n                current_string = current_string.split_off(1);\n                assert(how_many_times(string@, substring@) == k + 1 + how_many_times(\n                    current_string@,\n                    substring@,\n                ));\n                return None;\n            }\n            k = k + 1;\n        }\n        current_string = current_string.split_off(1);\n    }\n    assert(how_many_times(current_string@, substring@) == 0) by {\n        lemma_how_many_times_zero(current_string@, substring@)\n    };\n    return Some(k as u32);\n}\n\n} // verus!\nfn main() {\n    println!(\"{:?}\", how_many_times_impl(vec![], vec!['a']));\n    // 0\n    println!(\"{:?}\", how_many_times_impl(vec!['a', 'a', 'a'], vec!['a']));\n    // 3\n    println!(\n        \"{:?}\",\n        how_many_times_impl(vec!['a', 'a', 'a', 'a'], vec!['a', 'a'])\n    );\n    // 3\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nhow_many_times\n*/\n\n/*\n### CANONICAL SOLUTION\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\n// spec\npub closed spec fn how_many_times(string: Seq<char>, substring: Seq<char>) -> nat\n    decreases string.len(),\n{\n    if (string.len() == 0) {\n        0\n    } else if substring.is_prefix_of(string) {\n        1 + how_many_times(string.skip(1), substring)\n    } else {\n        how_many_times(string.skip(1), substring)\n    }\n}\n\n// implementation\nproof fn lemma_step_subrange(substring: Seq<char>, string: Seq<char>)\n    requires\n        substring.len() > 0,\n        string.len() >= substring.len(),\n    ensures\n        (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n            =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) ==> (substring\n            =~= string.subrange(0, substring.len() as int)),\n    decreases substring.len(),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// spec\npub closed spec fn how_many_times(string: Seq<char>, substring: Seq<char>) -> nat\n    decreases string.len(),\n{\n    if (string.len() == 0) {\n        0\n    } else if substring.is_prefix_of(string) {\n        1 + how_many_times(string.skip(1), substring)\n    } else {\n        how_many_times(string.skip(1), substring)\n    }\n}\n\n// implementation\nproof fn lemma_step_subrange(substring: Seq<char>, string: Seq<char>)\n    requires\n        substring.len() > 0,\n        string.len() >= substring.len(),\n    ensures\n        (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n            =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) ==> (substring\n            =~= string.subrange(0, substring.len() as int)),\n    decreases substring.len(),\n{\n    if (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n        =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) {\n        assert forall|i: int| 0 <= i < substring.len() implies #[trigger] substring[i]\n            == string.subrange(0, substring.len() as int)[i] by {\n            if i == 0 {\n            } else {\n                assert(forall|j: int|\n                    (0 <= #[trigger] (j + 0) < substring.len() - 1) ==> substring.skip(1)[j]\n                        == string.skip(1).subrange(0, substring.skip(1).len() as int)[j]);\n                assert(0 <= #[trigger] (i - 1 + 0) < substring.len() - 1);\n            }\n        }\n    } else {\n    }\n}\n\nfn is_prefix(substring: Vec<char>, string: Vec<char>) -> (b: bool)\n    ensures\n        b == substring@.is_prefix_of(string@),\n{\n    let mut current_substring = substring.clone();\n    let mut current_string = string.clone();\n\n    if substring.len() > string.len() {\n        return false\n    }\n    while (current_substring.len() > 0)\n        invariant\n            0 <= current_substring.len() <= current_string.len(),\n            substring.len() <= string.len(),\n            (substring@ =~= string@.subrange(0, substring@.len() as int)) == (current_substring@\n                =~= current_string@.subrange(0, current_substring@.len() as int)),\n        decreases current_substring.len(),\n    {\n        if (current_substring[0] != current_string[0]) {\n            return false;\n        }\n        let old_substring = current_substring.clone();\n        let old_string = current_string.clone();\n\n        let substring_first = current_substring.remove(0);\n        let string_first = current_string.remove(0);\n        assert((old_substring@ =~= old_string@.subrange(0, old_substring@.len() as int)) <== (\n        old_substring@[0] == old_string@.subrange(0, old_substring@.len() as int)[0] && (\n        old_substring@.skip(1) =~= old_string@.skip(1).subrange(\n            0,\n            old_substring@.skip(1).len() as int,\n        )))) by { lemma_step_subrange(old_substring@, old_string@) };\n    }\n    return true;\n}\n\nproof fn lemma_how_many_times_zero(string: Seq<char>, substring: Seq<char>)\n    requires\n        string.len() < substring.len(),\n    ensures\n        how_many_times(string, substring) == 0,\n    decreases string.len(),\n{\n    if string.len() == 0 {\n    } else {\n        lemma_how_many_times_zero(string.skip(1), substring)\n    }\n}\n\nfn how_many_times_impl(string: Vec<char>, substring: Vec<char>) -> (opt_k: Option<u32>)\n    requires\n        substring.len() >= 1,\n    ensures\n        match opt_k {\n            Some(k) => k as nat == how_many_times(string@, substring@),\n            None => how_many_times(string@, substring@) > u32::MAX,\n        },\n{\n    let mut k = 0u64;\n    let mut current_string = string;\n    while current_string.len() >= substring.len()\n        invariant\n            how_many_times(string@, substring@) == k + how_many_times(current_string@, substring@),\n            k <= u32::MAX as u64,\n            substring.len() >= 1,\n        decreases current_string.len(),\n    {\n        if (is_prefix(substring.clone(), current_string.clone())) {\n            if (k >= u32::MAX as u64) {\n                current_string = current_string.split_off(1);\n                assert(how_many_times(string@, substring@) == k + 1 + how_many_times(\n                    current_string@,\n                    substring@,\n                ));\n                return None;\n            }\n            k = k + 1;\n        }\n        current_string = current_string.split_off(1);\n    }\n    assert(how_many_times(current_string@, substring@) == 0) by {\n        lemma_how_many_times_zero(current_string@, substring@)\n    };\n    return Some(k as u32);\n}\n\n} // verus!\nfn main() {\n    println!(\"{:?}\", how_many_times_impl(vec![], vec!['a']));\n    // 0\n    println!(\"{:?}\", how_many_times_impl(vec!['a', 'a', 'a'], vec!['a']));\n    // 3\n    println!(\n        \"{:?}\",\n        how_many_times_impl(vec!['a', 'a', 'a', 'a'], vec!['a', 'a'])\n    );\n    // 3\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nhow_many_times\n*/\n\n/*\n### CANONICAL SOLUTION\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\n// spec\npub closed spec fn how_many_times(string: Seq<char>, substring: Seq<char>) -> nat\n    decreases string.len(),\n{\n    if (string.len() == 0) {\n        0\n    } else if substring.is_prefix_of(string) {\n        1 + how_many_times(string.skip(1), substring)\n    } else {\n        how_many_times(string.skip(1), substring)\n    }\n}\n\n// implementation\nproof fn lemma_step_subrange(substring: Seq<char>, string: Seq<char>)\n    requires\n        substring.len() > 0,\n        string.len() >= substring.len(),\n    ensures\n        (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n            =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) ==> (substring\n            =~= string.subrange(0, substring.len() as int)),\n    decreases substring.len(),\n{\n    if (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n        =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) {\n        assert forall|i: int| 0 <= i < substring.len() implies #[trigger] substring[i]\n            == string.subrange(0, substring.len() as int)[i] by {\n            if i == 0 {\n            } else {\n                assert(forall|j: int|\n                    (0 <= #[trigger] (j + 0) < substring.len() - 1) ==> substring.skip(1)[j]\n                        == string.skip(1).subrange(0, substring.skip(1).len() as int)[j]);\n                assert(0 <= #[trigger] (i - 1 + 0) < substring.len() - 1);\n            }\n        }\n    } else {\n    }\n}\n\nfn is_prefix(substring: Vec<char>, string: Vec<char>) -> (b: bool)\n    ensures\n        b == substring@.is_prefix_of(string@),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// spec\npub closed spec fn how_many_times(string: Seq<char>, substring: Seq<char>) -> nat\n    decreases string.len(),\n{\n    if (string.len() == 0) {\n        0\n    } else if substring.is_prefix_of(string) {\n        1 + how_many_times(string.skip(1), substring)\n    } else {\n        how_many_times(string.skip(1), substring)\n    }\n}\n\n// implementation\nproof fn lemma_step_subrange(substring: Seq<char>, string: Seq<char>)\n    requires\n        substring.len() > 0,\n        string.len() >= substring.len(),\n    ensures\n        (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n            =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) ==> (substring\n            =~= string.subrange(0, substring.len() as int)),\n    decreases substring.len(),\n{\n    if (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n        =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) {\n        assert forall|i: int| 0 <= i < substring.len() implies #[trigger] substring[i]\n            == string.subrange(0, substring.len() as int)[i] by {\n            if i == 0 {\n            } else {\n                assert(forall|j: int|\n                    (0 <= #[trigger] (j + 0) < substring.len() - 1) ==> substring.skip(1)[j]\n                        == string.skip(1).subrange(0, substring.skip(1).len() as int)[j]);\n                assert(0 <= #[trigger] (i - 1 + 0) < substring.len() - 1);\n            }\n        }\n    } else {\n    }\n}\n\nfn is_prefix(substring: Vec<char>, string: Vec<char>) -> (b: bool)\n    ensures\n        b == substring@.is_prefix_of(string@),\n{\n    let mut current_substring = substring.clone();\n    let mut current_string = string.clone();\n\n    if substring.len() > string.len() {\n        return false\n    }\n    while (current_substring.len() > 0)\n        invariant\n            0 <= current_substring.len() <= current_string.len(),\n            substring.len() <= string.len(),\n            (substring@ =~= string@.subrange(0, substring@.len() as int)) == (current_substring@\n                =~= current_string@.subrange(0, current_substring@.len() as int)),\n        decreases current_substring.len(),\n    {\n        if (current_substring[0] != current_string[0]) {\n            return false;\n        }\n        let old_substring = current_substring.clone();\n        let old_string = current_string.clone();\n\n        let substring_first = current_substring.remove(0);\n        let string_first = current_string.remove(0);\n        assert((old_substring@ =~= old_string@.subrange(0, old_substring@.len() as int)) <== (\n        old_substring@[0] == old_string@.subrange(0, old_substring@.len() as int)[0] && (\n        old_substring@.skip(1) =~= old_string@.skip(1).subrange(\n            0,\n            old_substring@.skip(1).len() as int,\n        )))) by { lemma_step_subrange(old_substring@, old_string@) };\n    }\n    return true;\n}\n\nproof fn lemma_how_many_times_zero(string: Seq<char>, substring: Seq<char>)\n    requires\n        string.len() < substring.len(),\n    ensures\n        how_many_times(string, substring) == 0,\n    decreases string.len(),\n{\n    if string.len() == 0 {\n    } else {\n        lemma_how_many_times_zero(string.skip(1), substring)\n    }\n}\n\nfn how_many_times_impl(string: Vec<char>, substring: Vec<char>) -> (opt_k: Option<u32>)\n    requires\n        substring.len() >= 1,\n    ensures\n        match opt_k {\n            Some(k) => k as nat == how_many_times(string@, substring@),\n            None => how_many_times(string@, substring@) > u32::MAX,\n        },\n{\n    let mut k = 0u64;\n    let mut current_string = string;\n    while current_string.len() >= substring.len()\n        invariant\n            how_many_times(string@, substring@) == k + how_many_times(current_string@, substring@),\n            k <= u32::MAX as u64,\n            substring.len() >= 1,\n        decreases current_string.len(),\n    {\n        if (is_prefix(substring.clone(), current_string.clone())) {\n            if (k >= u32::MAX as u64) {\n                current_string = current_string.split_off(1);\n                assert(how_many_times(string@, substring@) == k + 1 + how_many_times(\n                    current_string@,\n                    substring@,\n                ));\n                return None;\n            }\n            k = k + 1;\n        }\n        current_string = current_string.split_off(1);\n    }\n    assert(how_many_times(current_string@, substring@) == 0) by {\n        lemma_how_many_times_zero(current_string@, substring@)\n    };\n    return Some(k as u32);\n}\n\n} // verus!\nfn main() {\n    println!(\"{:?}\", how_many_times_impl(vec![], vec!['a']));\n    // 0\n    println!(\"{:?}\", how_many_times_impl(vec!['a', 'a', 'a'], vec!['a']));\n    // 3\n    println!(\n        \"{:?}\",\n        how_many_times_impl(vec!['a', 'a', 'a', 'a'], vec!['a', 'a'])\n    );\n    // 3\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nhow_many_times\n*/\n\n/*\n### CANONICAL SOLUTION\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\n// spec\npub closed spec fn how_many_times(string: Seq<char>, substring: Seq<char>) -> nat\n    decreases string.len(),\n{\n    if (string.len() == 0) {\n        0\n    } else if substring.is_prefix_of(string) {\n        1 + how_many_times(string.skip(1), substring)\n    } else {\n        how_many_times(string.skip(1), substring)\n    }\n}\n\n// implementation\nproof fn lemma_step_subrange(substring: Seq<char>, string: Seq<char>)\n    requires\n        substring.len() > 0,\n        string.len() >= substring.len(),\n    ensures\n        (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n            =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) ==> (substring\n            =~= string.subrange(0, substring.len() as int)),\n    decreases substring.len(),\n{\n    if (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n        =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) {\n        assert forall|i: int| 0 <= i < substring.len() implies #[trigger] substring[i]\n            == string.subrange(0, substring.len() as int)[i] by {\n            if i == 0 {\n            } else {\n                assert(forall|j: int|\n                    (0 <= #[trigger] (j + 0) < substring.len() - 1) ==> substring.skip(1)[j]\n                        == string.skip(1).subrange(0, substring.skip(1).len() as int)[j]);\n                assert(0 <= #[trigger] (i - 1 + 0) < substring.len() - 1);\n            }\n        }\n    } else {\n    }\n}\n\nfn is_prefix(substring: Vec<char>, string: Vec<char>) -> (b: bool)\n    ensures\n        b == substring@.is_prefix_of(string@),\n{\n    let mut current_substring = substring.clone();\n    let mut current_string = string.clone();\n\n    if substring.len() > string.len() {\n        return false\n    }\n    while (current_substring.len() > 0)\n        invariant\n            0 <= current_substring.len() <= current_string.len(),\n            substring.len() <= string.len(),\n            (substring@ =~= string@.subrange(0, substring@.len() as int)) == (current_substring@\n                =~= current_string@.subrange(0, current_substring@.len() as int)),\n        decreases current_substring.len(),\n    {\n        if (current_substring[0] != current_string[0]) {\n            return false;\n        }\n        let old_substring = current_substring.clone();\n        let old_string = current_string.clone();\n\n        let substring_first = current_substring.remove(0);\n        let string_first = current_string.remove(0);\n        assert((old_substring@ =~= old_string@.subrange(0, old_substring@.len() as int)) <== (\n        old_substring@[0] == old_string@.subrange(0, old_substring@.len() as int)[0] && (\n        old_substring@.skip(1) =~= old_string@.skip(1).subrange(\n            0,\n            old_substring@.skip(1).len() as int,\n        )))) by { lemma_step_subrange(old_substring@, old_string@) };\n    }\n    return true;\n}\n\nproof fn lemma_how_many_times_zero(string: Seq<char>, substring: Seq<char>)\n    requires\n        string.len() < substring.len(),\n    ensures\n        how_many_times(string, substring) == 0,\n    decreases string.len(),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// spec\npub closed spec fn how_many_times(string: Seq<char>, substring: Seq<char>) -> nat\n    decreases string.len(),\n{\n    if (string.len() == 0) {\n        0\n    } else if substring.is_prefix_of(string) {\n        1 + how_many_times(string.skip(1), substring)\n    } else {\n        how_many_times(string.skip(1), substring)\n    }\n}\n\n// implementation\nproof fn lemma_step_subrange(substring: Seq<char>, string: Seq<char>)\n    requires\n        substring.len() > 0,\n        string.len() >= substring.len(),\n    ensures\n        (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n            =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) ==> (substring\n            =~= string.subrange(0, substring.len() as int)),\n    decreases substring.len(),\n{\n    if (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n        =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) {\n        assert forall|i: int| 0 <= i < substring.len() implies #[trigger] substring[i]\n            == string.subrange(0, substring.len() as int)[i] by {\n            if i == 0 {\n            } else {\n                assert(forall|j: int|\n                    (0 <= #[trigger] (j + 0) < substring.len() - 1) ==> substring.skip(1)[j]\n                        == string.skip(1).subrange(0, substring.skip(1).len() as int)[j]);\n                assert(0 <= #[trigger] (i - 1 + 0) < substring.len() - 1);\n            }\n        }\n    } else {\n    }\n}\n\nfn is_prefix(substring: Vec<char>, string: Vec<char>) -> (b: bool)\n    ensures\n        b == substring@.is_prefix_of(string@),\n{\n    let mut current_substring = substring.clone();\n    let mut current_string = string.clone();\n\n    if substring.len() > string.len() {\n        return false\n    }\n    while (current_substring.len() > 0)\n        invariant\n            0 <= current_substring.len() <= current_string.len(),\n            substring.len() <= string.len(),\n            (substring@ =~= string@.subrange(0, substring@.len() as int)) == (current_substring@\n                =~= current_string@.subrange(0, current_substring@.len() as int)),\n        decreases current_substring.len(),\n    {\n        if (current_substring[0] != current_string[0]) {\n            return false;\n        }\n        let old_substring = current_substring.clone();\n        let old_string = current_string.clone();\n\n        let substring_first = current_substring.remove(0);\n        let string_first = current_string.remove(0);\n        assert((old_substring@ =~= old_string@.subrange(0, old_substring@.len() as int)) <== (\n        old_substring@[0] == old_string@.subrange(0, old_substring@.len() as int)[0] && (\n        old_substring@.skip(1) =~= old_string@.skip(1).subrange(\n            0,\n            old_substring@.skip(1).len() as int,\n        )))) by { lemma_step_subrange(old_substring@, old_string@) };\n    }\n    return true;\n}\n\nproof fn lemma_how_many_times_zero(string: Seq<char>, substring: Seq<char>)\n    requires\n        string.len() < substring.len(),\n    ensures\n        how_many_times(string, substring) == 0,\n    decreases string.len(),\n{\n    if string.len() == 0 {\n    } else {\n        lemma_how_many_times_zero(string.skip(1), substring)\n    }\n}\n\nfn how_many_times_impl(string: Vec<char>, substring: Vec<char>) -> (opt_k: Option<u32>)\n    requires\n        substring.len() >= 1,\n    ensures\n        match opt_k {\n            Some(k) => k as nat == how_many_times(string@, substring@),\n            None => how_many_times(string@, substring@) > u32::MAX,\n        },\n{\n    let mut k = 0u64;\n    let mut current_string = string;\n    while current_string.len() >= substring.len()\n        invariant\n            how_many_times(string@, substring@) == k + how_many_times(current_string@, substring@),\n            k <= u32::MAX as u64,\n            substring.len() >= 1,\n        decreases current_string.len(),\n    {\n        if (is_prefix(substring.clone(), current_string.clone())) {\n            if (k >= u32::MAX as u64) {\n                current_string = current_string.split_off(1);\n                assert(how_many_times(string@, substring@) == k + 1 + how_many_times(\n                    current_string@,\n                    substring@,\n                ));\n                return None;\n            }\n            k = k + 1;\n        }\n        current_string = current_string.split_off(1);\n    }\n    assert(how_many_times(current_string@, substring@) == 0) by {\n        lemma_how_many_times_zero(current_string@, substring@)\n    };\n    return Some(k as u32);\n}\n\n} // verus!\nfn main() {\n    println!(\"{:?}\", how_many_times_impl(vec![], vec!['a']));\n    // 0\n    println!(\"{:?}\", how_many_times_impl(vec!['a', 'a', 'a'], vec!['a']));\n    // 3\n    println!(\n        \"{:?}\",\n        how_many_times_impl(vec!['a', 'a', 'a', 'a'], vec!['a', 'a'])\n    );\n    // 3\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nhow_many_times\n*/\n\n/*\n### CANONICAL SOLUTION\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\n// spec\npub closed spec fn how_many_times(string: Seq<char>, substring: Seq<char>) -> nat\n    decreases string.len(),\n{\n    if (string.len() == 0) {\n        0\n    } else if substring.is_prefix_of(string) {\n        1 + how_many_times(string.skip(1), substring)\n    } else {\n        how_many_times(string.skip(1), substring)\n    }\n}\n\n// implementation\nproof fn lemma_step_subrange(substring: Seq<char>, string: Seq<char>)\n    requires\n        substring.len() > 0,\n        string.len() >= substring.len(),\n    ensures\n        (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n            =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) ==> (substring\n            =~= string.subrange(0, substring.len() as int)),\n    decreases substring.len(),\n{\n    if (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n        =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) {\n        assert forall|i: int| 0 <= i < substring.len() implies #[trigger] substring[i]\n            == string.subrange(0, substring.len() as int)[i] by {\n            if i == 0 {\n            } else {\n                assert(forall|j: int|\n                    (0 <= #[trigger] (j + 0) < substring.len() - 1) ==> substring.skip(1)[j]\n                        == string.skip(1).subrange(0, substring.skip(1).len() as int)[j]);\n                assert(0 <= #[trigger] (i - 1 + 0) < substring.len() - 1);\n            }\n        }\n    } else {\n    }\n}\n\nfn is_prefix(substring: Vec<char>, string: Vec<char>) -> (b: bool)\n    ensures\n        b == substring@.is_prefix_of(string@),\n{\n    let mut current_substring = substring.clone();\n    let mut current_string = string.clone();\n\n    if substring.len() > string.len() {\n        return false\n    }\n    while (current_substring.len() > 0)\n        invariant\n            0 <= current_substring.len() <= current_string.len(),\n            substring.len() <= string.len(),\n            (substring@ =~= string@.subrange(0, substring@.len() as int)) == (current_substring@\n                =~= current_string@.subrange(0, current_substring@.len() as int)),\n        decreases current_substring.len(),\n    {\n        if (current_substring[0] != current_string[0]) {\n            return false;\n        }\n        let old_substring = current_substring.clone();\n        let old_string = current_string.clone();\n\n        let substring_first = current_substring.remove(0);\n        let string_first = current_string.remove(0);\n        assert((old_substring@ =~= old_string@.subrange(0, old_substring@.len() as int)) <== (\n        old_substring@[0] == old_string@.subrange(0, old_substring@.len() as int)[0] && (\n        old_substring@.skip(1) =~= old_string@.skip(1).subrange(\n            0,\n            old_substring@.skip(1).len() as int,\n        )))) by { lemma_step_subrange(old_substring@, old_string@) };\n    }\n    return true;\n}\n\nproof fn lemma_how_many_times_zero(string: Seq<char>, substring: Seq<char>)\n    requires\n        string.len() < substring.len(),\n    ensures\n        how_many_times(string, substring) == 0,\n    decreases string.len(),\n{\n    if string.len() == 0 {\n    } else {\n        lemma_how_many_times_zero(string.skip(1), substring)\n    }\n}\n\nfn how_many_times_impl(string: Vec<char>, substring: Vec<char>) -> (opt_k: Option<u32>)\n    requires\n        substring.len() >= 1,\n    ensures\n        match opt_k {\n            Some(k) => k as nat == how_many_times(string@, substring@),\n            None => how_many_times(string@, substring@) > u32::MAX,\n        },\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// spec\npub closed spec fn how_many_times(string: Seq<char>, substring: Seq<char>) -> nat\n    decreases string.len(),\n{\n    if (string.len() == 0) {\n        0\n    } else if substring.is_prefix_of(string) {\n        1 + how_many_times(string.skip(1), substring)\n    } else {\n        how_many_times(string.skip(1), substring)\n    }\n}\n\n// implementation\nproof fn lemma_step_subrange(substring: Seq<char>, string: Seq<char>)\n    requires\n        substring.len() > 0,\n        string.len() >= substring.len(),\n    ensures\n        (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n            =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) ==> (substring\n            =~= string.subrange(0, substring.len() as int)),\n    decreases substring.len(),\n{\n    if (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n        =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) {\n        assert forall|i: int| 0 <= i < substring.len() implies #[trigger] substring[i]\n            == string.subrange(0, substring.len() as int)[i] by {\n            if i == 0 {\n            } else {\n                assert(forall|j: int|\n                    (0 <= #[trigger] (j + 0) < substring.len() - 1) ==> substring.skip(1)[j]\n                        == string.skip(1).subrange(0, substring.skip(1).len() as int)[j]);\n                assert(0 <= #[trigger] (i - 1 + 0) < substring.len() - 1);\n            }\n        }\n    } else {\n    }\n}\n\nfn is_prefix(substring: Vec<char>, string: Vec<char>) -> (b: bool)\n    ensures\n        b == substring@.is_prefix_of(string@),\n{\n    let mut current_substring = substring.clone();\n    let mut current_string = string.clone();\n\n    if substring.len() > string.len() {\n        return false\n    }\n    while (current_substring.len() > 0)\n        invariant\n            0 <= current_substring.len() <= current_string.len(),\n            substring.len() <= string.len(),\n            (substring@ =~= string@.subrange(0, substring@.len() as int)) == (current_substring@\n                =~= current_string@.subrange(0, current_substring@.len() as int)),\n        decreases current_substring.len(),\n    {\n        if (current_substring[0] != current_string[0]) {\n            return false;\n        }\n        let old_substring = current_substring.clone();\n        let old_string = current_string.clone();\n\n        let substring_first = current_substring.remove(0);\n        let string_first = current_string.remove(0);\n        assert((old_substring@ =~= old_string@.subrange(0, old_substring@.len() as int)) <== (\n        old_substring@[0] == old_string@.subrange(0, old_substring@.len() as int)[0] && (\n        old_substring@.skip(1) =~= old_string@.skip(1).subrange(\n            0,\n            old_substring@.skip(1).len() as int,\n        )))) by { lemma_step_subrange(old_substring@, old_string@) };\n    }\n    return true;\n}\n\nproof fn lemma_how_many_times_zero(string: Seq<char>, substring: Seq<char>)\n    requires\n        string.len() < substring.len(),\n    ensures\n        how_many_times(string, substring) == 0,\n    decreases string.len(),\n{\n    if string.len() == 0 {\n    } else {\n        lemma_how_many_times_zero(string.skip(1), substring)\n    }\n}\n\nfn how_many_times_impl(string: Vec<char>, substring: Vec<char>) -> (opt_k: Option<u32>)\n    requires\n        substring.len() >= 1,\n    ensures\n        match opt_k {\n            Some(k) => k as nat == how_many_times(string@, substring@),\n            None => how_many_times(string@, substring@) > u32::MAX,\n        },\n{\n    let mut k = 0u64;\n    let mut current_string = string;\n    while current_string.len() >= substring.len()\n        invariant\n            how_many_times(string@, substring@) == k + how_many_times(current_string@, substring@),\n            k <= u32::MAX as u64,\n            substring.len() >= 1,\n        decreases current_string.len(),\n    {\n        if (is_prefix(substring.clone(), current_string.clone())) {\n            if (k >= u32::MAX as u64) {\n                current_string = current_string.split_off(1);\n                assert(how_many_times(string@, substring@) == k + 1 + how_many_times(\n                    current_string@,\n                    substring@,\n                ));\n                return None;\n            }\n            k = k + 1;\n        }\n        current_string = current_string.split_off(1);\n    }\n    assert(how_many_times(current_string@, substring@) == 0) by {\n        lemma_how_many_times_zero(current_string@, substring@)\n    };\n    return Some(k as u32);\n}\n\n} // verus!\nfn main() {\n    println!(\"{:?}\", how_many_times_impl(vec![], vec!['a']));\n    // 0\n    println!(\"{:?}\", how_many_times_impl(vec!['a', 'a', 'a'], vec!['a']));\n    // 3\n    println!(\n        \"{:?}\",\n        how_many_times_impl(vec!['a', 'a', 'a', 'a'], vec!['a', 'a'])\n    );\n    // 3\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\n\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nhow_many_times\n*/\n\n/*\n### CANONICAL SOLUTION\n    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\n// spec\npub closed spec fn how_many_times(string: Seq<char>, substring: Seq<char>) -> nat\n    decreases string.len(),\n{\n    if (string.len() == 0) {\n        0\n    } else if substring.is_prefix_of(string) {\n        1 + how_many_times(string.skip(1), substring)\n    } else {\n        how_many_times(string.skip(1), substring)\n    }\n}\n\n// implementation\nproof fn lemma_step_subrange(substring: Seq<char>, string: Seq<char>)\n    requires\n        substring.len() > 0,\n        string.len() >= substring.len(),\n    ensures\n        (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n            =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) ==> (substring\n            =~= string.subrange(0, substring.len() as int)),\n    decreases substring.len(),\n{\n    if (substring[0] == string.subrange(0, substring.len() as int)[0] && (substring.skip(1)\n        =~= string.skip(1).subrange(0, substring.skip(1).len() as int))) {\n        assert forall|i: int| 0 <= i < substring.len() implies #[trigger] substring[i]\n            == string.subrange(0, substring.len() as int)[i] by {\n            if i == 0 {\n            } else {\n                assert(forall|j: int|\n                    (0 <= #[trigger] (j + 0) < substring.len() - 1) ==> substring.skip(1)[j]\n                        == string.skip(1).subrange(0, substring.skip(1).len() as int)[j]);\n                assert(0 <= #[trigger] (i - 1 + 0) < substring.len() - 1);\n            }\n        }\n    } else {\n    }\n}\n\nfn is_prefix(substring: Vec<char>, string: Vec<char>) -> (b: bool)\n    ensures\n        b == substring@.is_prefix_of(string@),\n{\n    let mut current_substring = substring.clone();\n    let mut current_string = string.clone();\n\n    if substring.len() > string.len() {\n        return false\n    }\n    while (current_substring.len() > 0)\n        invariant\n            0 <= current_substring.len() <= current_string.len(),\n            substring.len() <= string.len(),\n            (substring@ =~= string@.subrange(0, substring@.len() as int)) == (current_substring@\n                =~= current_string@.subrange(0, current_substring@.len() as int)),\n        decreases current_substring.len(),\n    {\n        if (current_substring[0] != current_string[0]) {\n            return false;\n        }\n        let old_substring = current_substring.clone();\n        let old_string = current_string.clone();\n\n        let substring_first = current_substring.remove(0);\n        let string_first = current_string.remove(0);\n        assert((old_substring@ =~= old_string@.subrange(0, old_substring@.len() as int)) <== (\n        old_substring@[0] == old_string@.subrange(0, old_substring@.len() as int)[0] && (\n        old_substring@.skip(1) =~= old_string@.skip(1).subrange(\n            0,\n            old_substring@.skip(1).len() as int,\n        )))) by { lemma_step_subrange(old_substring@, old_string@) };\n    }\n    return true;\n}\n\nproof fn lemma_how_many_times_zero(string: Seq<char>, substring: Seq<char>)\n    requires\n        string.len() < substring.len(),\n    ensures\n        how_many_times(string, substring) == 0,\n    decreases string.len(),\n{\n    if string.len() == 0 {\n    } else {\n        lemma_how_many_times_zero(string.skip(1), substring)\n    }\n}\n\nfn how_many_times_impl(string: Vec<char>, substring: Vec<char>) -> (opt_k: Option<u32>)\n    requires\n        substring.len() >= 1,\n    ensures\n        match opt_k {\n            Some(k) => k as nat == how_many_times(string@, substring@),\n            None => how_many_times(string@, substring@) > u32::MAX,\n        },\n{\n    let mut k = 0u64;\n    let mut current_string = string;\n    while current_string.len() >= substring.len()\n        invariant\n            how_many_times(string@, substring@) == k + how_many_times(current_string@, substring@),\n            k <= u32::MAX as u64,\n            substring.len() >= 1,\n        decreases current_string.len(),\n    {\n        if (is_prefix(substring.clone(), current_string.clone())) {\n            if (k >= u32::MAX as u64) {\n                current_string = current_string.split_off(1);\n                assert(how_many_times(string@, substring@) == k + 1 + how_many_times(\n                    current_string@,\n                    substring@,\n                ));\n                return None;\n            }\n            k = k + 1;\n        }\n        current_string = current_string.split_off(1);\n    }\n    assert(how_many_times(current_string@, substring@) == 0) by {\n        lemma_how_many_times_zero(current_string@, substring@)\n    };\n    return Some(k as u32);\n}\n\n} // verus!\nf"}
{"y": "use vstd::arithmetic::div_mod::{\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse_div,\n};\nuse vstd::prelude::*;\n\nverus! {\n\npub open spec fn mul(a: nat, b: nat) -> nat {\n    builtin::mul(a, b)\n}\n\n/// Specification for what it means for d to divide a\npub open spec fn divides(factor: nat, candidate: nat) -> bool {\n    exists|k: nat| mul(factor, k) == candidate\n}\n\n/// Helper function to prove a % b == 0 imples b divides a\nproof fn lemma_mod_zero(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        a % b == 0,\n    ensures\n        divides(b, a),\n{\n    lemma_fundamental_div_mod(a as int, b as int);\n    assert(mul(b, (a / b)) == a);\n}\n\n/// Helper function to prove b divides a imples a % b == 0\nproof fn lemma_mod_zero_reversed(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        divides(b, a),\n    ensures\n        a % b == 0,\n{\n    let k_wit = choose|k: nat| mul(b, k) == a;\n    assert(k_wit == a / b) by {\n        lemma_fundamental_div_mod_converse_div(a as int, b as int, k_wit as int, 0 as int);\n    }\n    lemma_fundamental_div_mod(a as int, b as int);\n}\n\n/// Helper function to prove everything is divided by one\nproof fn lemma_one_divides_all()\n    ensures\n        forall|v: nat| divides(1 as nat, v),\n{\n    assert forall|v: nat| divides(1 as nat, v) by {\n        assert(mul(1 as nat, v) == v);\n    }\n}\n\n/// Implementation.\nfn largest_divisor(n: u32) -> (ret: u32)\n    requires\n        n > 1,\n    ensures\n        divides(ret as nat, n as nat),\n        ret < n,\n        forall|k: u32| (0 < k < n && divides(k as nat, n as nat)) ==> ret >= k,\n{\n    let mut i = n - 1;\n    while i >= 2\n        invariant\n            n > 0,\n            i < n,\n            forall|k: u32| i < k < n ==> !divides(k as nat, n as nat),\n    {\n        if n % i == 0 {\n            assert(divides(i as nat, n as nat)) by {\n                lemma_mod_zero(n as nat, i as nat);\n            }\n            return i;\n        }\n        i -= 1;\n\n        assert forall|k: u32| i < k < n implies !divides(k as nat, n as nat) by {\n            if k == i + 1 {\n                assert(!divides(k as nat, n as nat)) by {\n                    if (divides(k as nat, n as nat)) {\n                        lemma_mod_zero_reversed(n as nat, k as nat);\n                    }\n                }\n            }\n        }\n    }\n    assert(divides(1 as nat, n as nat)) by {\n        lemma_one_divides_all();\n    }\n    1\n}\n\n} // verus!\n", "x": "use vstd::arithmetic::div_mod::{\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse_div,\n};\nuse vstd::prelude::*;\n\nverus! {\n\npub open spec fn mul(a: nat, b: nat) -> nat {\n    builtin::mul(a, b)\n}\n\n/// Specification for what it means for d to divide a\npub open spec fn divides(factor: nat, candidate: nat) -> bool {\n    exists|k: nat| mul(factor, k) == candidate\n}\n\n/// Helper function to prove a % b == 0 imples b divides a\nproof fn lemma_mod_zero(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        a % b == 0,\n    ensures\n        divides(b, a),\n{"}
{"y": "use vstd::arithmetic::div_mod::{\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse_div,\n};\nuse vstd::prelude::*;\n\nverus! {\n\npub open spec fn mul(a: nat, b: nat) -> nat {\n    builtin::mul(a, b)\n}\n\n/// Specification for what it means for d to divide a\npub open spec fn divides(factor: nat, candidate: nat) -> bool {\n    exists|k: nat| mul(factor, k) == candidate\n}\n\n/// Helper function to prove a % b == 0 imples b divides a\nproof fn lemma_mod_zero(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        a % b == 0,\n    ensures\n        divides(b, a),\n{\n    lemma_fundamental_div_mod(a as int, b as int);\n    assert(mul(b, (a / b)) == a);\n}\n\n/// Helper function to prove b divides a imples a % b == 0\nproof fn lemma_mod_zero_reversed(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        divides(b, a),\n    ensures\n        a % b == 0,\n{\n    let k_wit = choose|k: nat| mul(b, k) == a;\n    assert(k_wit == a / b) by {\n        lemma_fundamental_div_mod_converse_div(a as int, b as int, k_wit as int, 0 as int);\n    }\n    lemma_fundamental_div_mod(a as int, b as int);\n}\n\n/// Helper function to prove everything is divided by one\nproof fn lemma_one_divides_all()\n    ensures\n        forall|v: nat| divides(1 as nat, v),\n{\n    assert forall|v: nat| divides(1 as nat, v) by {\n        assert(mul(1 as nat, v) == v);\n    }\n}\n\n/// Implementation.\nfn largest_divisor(n: u32) -> (ret: u32)\n    requires\n        n > 1,\n    ensures\n        divides(ret as nat, n as nat),\n        ret < n,\n        forall|k: u32| (0 < k < n && divides(k as nat, n as nat)) ==> ret >= k,\n{\n    let mut i = n - 1;\n    while i >= 2\n        invariant\n            n > 0,\n            i < n,\n            forall|k: u32| i < k < n ==> !divides(k as nat, n as nat),\n    {\n        if n % i == 0 {\n            assert(divides(i as nat, n as nat)) by {\n                lemma_mod_zero(n as nat, i as nat);\n            }\n            return i;\n        }\n        i -= 1;\n\n        assert forall|k: u32| i < k < n implies !divides(k as nat, n as nat) by {\n            if k == i + 1 {\n                assert(!divides(k as nat, n as nat)) by {\n                    if (divides(k as nat, n as nat)) {\n                        lemma_mod_zero_reversed(n as nat, k as nat);\n                    }\n                }\n            }\n        }\n    }\n    assert(divides(1 as nat, n as nat)) by {\n        lemma_one_divides_all();\n    }\n    1\n}\n\n} // verus!\n", "x": "use vstd::arithmetic::div_mod::{\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse_div,\n};\nuse vstd::prelude::*;\n\nverus! {\n\npub open spec fn mul(a: nat, b: nat) -> nat {\n    builtin::mul(a, b)\n}\n\n/// Specification for what it means for d to divide a\npub open spec fn divides(factor: nat, candidate: nat) -> bool {\n    exists|k: nat| mul(factor, k) == candidate\n}\n\n/// Helper function to prove a % b == 0 imples b divides a\nproof fn lemma_mod_zero(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        a % b == 0,\n    ensures\n        divides(b, a),\n{\n    lemma_fundamental_div_mod(a as int, b as int);\n    assert(mul(b, (a / b)) == a);\n}\n\n/// Helper function to prove b divides a imples a % b == 0\nproof fn lemma_mod_zero_reversed(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        divides(b, a),\n    ensures\n        a % b == 0,\n{"}
{"y": "use vstd::arithmetic::div_mod::{\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse_div,\n};\nuse vstd::prelude::*;\n\nverus! {\n\npub open spec fn mul(a: nat, b: nat) -> nat {\n    builtin::mul(a, b)\n}\n\n/// Specification for what it means for d to divide a\npub open spec fn divides(factor: nat, candidate: nat) -> bool {\n    exists|k: nat| mul(factor, k) == candidate\n}\n\n/// Helper function to prove a % b == 0 imples b divides a\nproof fn lemma_mod_zero(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        a % b == 0,\n    ensures\n        divides(b, a),\n{\n    lemma_fundamental_div_mod(a as int, b as int);\n    assert(mul(b, (a / b)) == a);\n}\n\n/// Helper function to prove b divides a imples a % b == 0\nproof fn lemma_mod_zero_reversed(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        divides(b, a),\n    ensures\n        a % b == 0,\n{\n    let k_wit = choose|k: nat| mul(b, k) == a;\n    assert(k_wit == a / b) by {\n        lemma_fundamental_div_mod_converse_div(a as int, b as int, k_wit as int, 0 as int);\n    }\n    lemma_fundamental_div_mod(a as int, b as int);\n}\n\n/// Helper function to prove everything is divided by one\nproof fn lemma_one_divides_all()\n    ensures\n        forall|v: nat| divides(1 as nat, v),\n{\n    assert forall|v: nat| divides(1 as nat, v) by {\n        assert(mul(1 as nat, v) == v);\n    }\n}\n\n/// Implementation.\nfn largest_divisor(n: u32) -> (ret: u32)\n    requires\n        n > 1,\n    ensures\n        divides(ret as nat, n as nat),\n        ret < n,\n        forall|k: u32| (0 < k < n && divides(k as nat, n as nat)) ==> ret >= k,\n{\n    let mut i = n - 1;\n    while i >= 2\n        invariant\n            n > 0,\n            i < n,\n            forall|k: u32| i < k < n ==> !divides(k as nat, n as nat),\n    {\n        if n % i == 0 {\n            assert(divides(i as nat, n as nat)) by {\n                lemma_mod_zero(n as nat, i as nat);\n            }\n            return i;\n        }\n        i -= 1;\n\n        assert forall|k: u32| i < k < n implies !divides(k as nat, n as nat) by {\n            if k == i + 1 {\n                assert(!divides(k as nat, n as nat)) by {\n                    if (divides(k as nat, n as nat)) {\n                        lemma_mod_zero_reversed(n as nat, k as nat);\n                    }\n                }\n            }\n        }\n    }\n    assert(divides(1 as nat, n as nat)) by {\n        lemma_one_divides_all();\n    }\n    1\n}\n\n} // verus!\n", "x": "use vstd::arithmetic::div_mod::{\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse_div,\n};\nuse vstd::prelude::*;\n\nverus! {\n\npub open spec fn mul(a: nat, b: nat) -> nat {\n    builtin::mul(a, b)\n}\n\n/// Specification for what it means for d to divide a\npub open spec fn divides(factor: nat, candidate: nat) -> bool {\n    exists|k: nat| mul(factor, k) == candidate\n}\n\n/// Helper function to prove a % b == 0 imples b divides a\nproof fn lemma_mod_zero(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        a % b == 0,\n    ensures\n        divides(b, a),\n{\n    lemma_fundamental_div_mod(a as int, b as int);\n    assert(mul(b, (a / b)) == a);\n}\n\n/// Helper function to prove b divides a imples a % b == 0\nproof fn lemma_mod_zero_reversed(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        divides(b, a),\n    ensures\n        a % b == 0,\n{\n    let k_wit = choose|k: nat| mul(b, k) == a;\n    assert(k_wit == a / b) by {\n        lemma_fundamental_div_mod_converse_div(a as int, b as int, k_wit as int, 0 as int);\n    }\n    lemma_fundamental_div_mod(a as int, b as int);\n}\n\n/// Helper function to prove everything is divided by one\nproof fn lemma_one_divides_all()\n    ensures\n        forall|v: nat| divides(1 as nat, v),\n{"}
{"y": "use vstd::arithmetic::div_mod::{\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse_div,\n};\nuse vstd::prelude::*;\n\nverus! {\n\npub open spec fn mul(a: nat, b: nat) -> nat {\n    builtin::mul(a, b)\n}\n\n/// Specification for what it means for d to divide a\npub open spec fn divides(factor: nat, candidate: nat) -> bool {\n    exists|k: nat| mul(factor, k) == candidate\n}\n\n/// Helper function to prove a % b == 0 imples b divides a\nproof fn lemma_mod_zero(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        a % b == 0,\n    ensures\n        divides(b, a),\n{\n    lemma_fundamental_div_mod(a as int, b as int);\n    assert(mul(b, (a / b)) == a);\n}\n\n/// Helper function to prove b divides a imples a % b == 0\nproof fn lemma_mod_zero_reversed(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        divides(b, a),\n    ensures\n        a % b == 0,\n{\n    let k_wit = choose|k: nat| mul(b, k) == a;\n    assert(k_wit == a / b) by {\n        lemma_fundamental_div_mod_converse_div(a as int, b as int, k_wit as int, 0 as int);\n    }\n    lemma_fundamental_div_mod(a as int, b as int);\n}\n\n/// Helper function to prove everything is divided by one\nproof fn lemma_one_divides_all()\n    ensures\n        forall|v: nat| divides(1 as nat, v),\n{\n    assert forall|v: nat| divides(1 as nat, v) by {\n        assert(mul(1 as nat, v) == v);\n    }\n}\n\n/// Implementation.\nfn largest_divisor(n: u32) -> (ret: u32)\n    requires\n        n > 1,\n    ensures\n        divides(ret as nat, n as nat),\n        ret < n,\n        forall|k: u32| (0 < k < n && divides(k as nat, n as nat)) ==> ret >= k,\n{\n    let mut i = n - 1;\n    while i >= 2\n        invariant\n            n > 0,\n            i < n,\n            forall|k: u32| i < k < n ==> !divides(k as nat, n as nat),\n    {\n        if n % i == 0 {\n            assert(divides(i as nat, n as nat)) by {\n                lemma_mod_zero(n as nat, i as nat);\n            }\n            return i;\n        }\n        i -= 1;\n\n        assert forall|k: u32| i < k < n implies !divides(k as nat, n as nat) by {\n            if k == i + 1 {\n                assert(!divides(k as nat, n as nat)) by {\n                    if (divides(k as nat, n as nat)) {\n                        lemma_mod_zero_reversed(n as nat, k as nat);\n                    }\n                }\n            }\n        }\n    }\n    assert(divides(1 as nat, n as nat)) by {\n        lemma_one_divides_all();\n    }\n    1\n}\n\n} // verus!\n", "x": "use vstd::arithmetic::div_mod::{\n    lemma_fundamental_div_mod, lemma_fundamental_div_mod_converse_div,\n};\nuse vstd::prelude::*;\n\nverus! {\n\npub open spec fn mul(a: nat, b: nat) -> nat {\n    builtin::mul(a, b)\n}\n\n/// Specification for what it means for d to divide a\npub open spec fn divides(factor: nat, candidate: nat) -> bool {\n    exists|k: nat| mul(factor, k) == candidate\n}\n\n/// Helper function to prove a % b == 0 imples b divides a\nproof fn lemma_mod_zero(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        a % b == 0,\n    ensures\n        divides(b, a),\n{\n    lemma_fundamental_div_mod(a as int, b as int);\n    assert(mul(b, (a / b)) == a);\n}\n\n/// Helper function to prove b divides a imples a % b == 0\nproof fn lemma_mod_zero_reversed(a: nat, b: nat)\n    requires\n        a > 0 && b > 0,\n        divides(b, a),\n    ensures\n        a % b == 0,\n{\n    let k_wit = choose|k: nat| mul(b, k) == a;\n    assert(k_wit == a / b) by {\n        lemma_fundamental_div_mod_converse_div(a as int, b as int, k_wit as int, 0 as int);\n    }\n    lemma_fundamental_div_mod(a as int, b as int);\n}\n\n/// Helper function to prove everything is divided by one\nproof fn lemma_one_divides_all()\n    ensures\n        forall|v: nat| divides(1 as nat, v),\n{\n    assert forall|v: nat| divides(1 as nat, v) by {\n        assert(mul(1 as nat, v) == v);\n    }\n}\n\n/// Implementation.\nfn largest_divisor(n: u32) -> (ret: u32)\n    requires\n        n > 1,\n    ensures\n        divides(ret as nat, n as nat),\n        ret < n,\n        forall|k: u32| (0 < k < n && divides(k as nat, n as nat)) ==> ret >= k,\n{"}
{"y": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{\n    assert((old_factors.push(m)).drop_last() == old_factors);\n    assert(((k as int) / (m as int)) * (m as int) + (k as int) % (m as int) == (k as int)) by {\n        lemma_fundamental_div_mod(k as int, m as int)\n    };\n}\n\nproof fn lemma_unfold_right_fold_new(factors: Seq<u8>, old_factors: Seq<u8>, m: u8)\n    requires\n        old_factors.push(m as u8) == factors,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1nat,\n        ) * (m as nat),\n{\n    assert((old_factors.push(m as u8)).drop_last() == old_factors);\n    assert(factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n        |x, acc: nat| (acc * x) as nat,\n        1,\n    ) * (m as nat)) by { lemma_fold_right_pull_out_hybrid(old_factors, m as nat) }\n}\n\nproof fn lemma_multiple_mod_is_zero(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n    ensures\n        n % (k / m) == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n\n    assert(n == ((n / k) * m) * (k / m)) by {\n        broadcast use group_mul_properties;\n\n    };\n    assert(n % (k / m) == 0) by { lemma_mod_multiples_basic((n / k) * m, k / m) };\n}\n\nproof fn lemma_multiple_mod_is_zero_new(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n        n > 0,\n    ensures\n        m * (n / k) == n / (k / m),\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    let a = choose|a: int| (#[trigger] (a * m) == k && (a == k / m));\n\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n    let b = choose|b: int| (#[trigger] (b * k) == n && b == n / k);\n\n    assert((a * m) * b == n) by { lemma_mul_is_commutative(b, a * m) }\n    assert(a * (m * b) == n) by { lemma_mul_is_associative(a, m, b) };\n    assert((m * b) == n / a) by { lemma_div_multiples_vanish(m * b, a) };\n}\n\nproof fn lemma_factor_mod_is_zero(k: int, m: int, j: int)\n    requires\n        k % j != 0,\n        k % m == 0,\n        1 <= j < m,\n    ensures\n        (k / m) % j != 0,\n{\n    assert_by_contradiction!((k/m) % j != 0,\n            { /* proof */\n                assert (k == (k/m) * m) by {lemma_fundamental_div_mod(k, m)};\n                let a = choose|a:int| (#[trigger] (a * m) == k);\n\n                assert ((k/m) == ((k/m)/j) * j) by {lemma_fundamental_div_mod(k/m, j)};\n                let b = choose|b:int| (#[trigger] (b * j) == k/m);\n\n                calc! {\n                    (==)\n                    k % j; {broadcast use group_mul_properties;}\n                    ((b * m) * j) % j; {broadcast use lemma_mod_multiples_basic;}\n                    0;\n                }\n            });\n\n}\n\nproof fn lemma_mod_zero_twice(k: int, m: int, i: int)\n    requires\n        k % m == 0,\n        m % i == 0,\n        m > 0,\n        i > 0,\n    ensures\n        k % i == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k as int, m as int) };\n    let a = choose|a: int| (#[trigger] (a * m) == k);\n\n    assert(m == (m / i) * i) by { lemma_fundamental_div_mod(m as int, i as int) };\n    let b = choose|b: int| (#[trigger] (b * i) == m);\n\n    assert(k == (a * b) * i) by { lemma_mul_is_associative(a, b, i) };\n    assert(k % i == 0) by { lemma_mod_multiples_vanish(a * b, 0, i) };\n\n}\n\nproof fn lemma_first_divisor_is_prime(k: nat, m: nat)\n    requires\n        k % m == 0,\n        forall|j: nat| 1 < j < m ==> #[trigger] (k % j) != 0,\n        m >= 2,\n    ensures\n        is_prime(m),\n{\n    assert_by_contradiction!(is_prime(m),\n            {\n                let i = choose|i:nat| (1 < i < m && #[trigger] (m % i) == 0);\n                assert (k % i == 0) by {lemma_mod_zero_twice(k as int, m as int, i as int)};\n            })\n}\n\nproof fn lemma_drop_last_map_commute(seq: Seq<u8>)\n    requires\n        seq.len() >= 1,\n    ensures\n        seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(|_idx, j: u8| j as nat),\n{\n    assert(seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(\n        |_idx, j: u8| j as nat,\n    ));\n}\n\nproof fn lemma_fold_right_equivalent_for_nat_u8(factorization: Seq<u8>)\n    requires\n        factorization.fold_right(|x, acc: u8| (acc * x) as u8, 1u8) <= u8::MAX as u8,\n        forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n    ensures\n        factorization.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == factorization.map(\n            |_idx, j: u8| j as nat,\n        ).fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat),\n    decreases factorization.len(),\n{\n    if (factorization.len() == 0) {\n    } else {\n        let factorization_ = factorization.drop_last();\n        let last = factorization.last();\n\n        calc! {\n            (==)\n            factorization.map(|_idx, j: u8| j as nat).fold_right(|x, acc: nat| acc * x, 1nat); {\n                lemma_drop_last_map_commute(factorization)\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                (factorization.last() as nat),\n            ); {\n                lemma_fold_right_pull_out_nat(\n                    factorization.drop_last().map(|_idx, j: u8| j as nat),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                1nat,\n            ) * (factorization.last() as nat); {\n                lemma_fold_right_equivalent_for_nat_u8(factorization.drop_last())\n            }\n            factorization.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1nat) * (\n            factorization.last() as nat); {\n                lemma_fold_right_pull_out_hybrid(\n                    factorization.drop_last(),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().fold_right(\n                |x, acc: nat| (acc * x) as nat,\n                (factorization.last() as nat),\n            );\n        }\n    }\n}\n\npub fn factorize(n: u8) -> (factorization: Vec<u8>)\n    requires\n        1 <= n <= u8::MAX,\n    ensures\n        is_prime_factorization(n as nat, factorization@.map(|_idx, j: u8| j as nat)),\n{\n    let mut factorization = vec![];\n    let mut k = n;\n    let mut m = 2u16;\n    let ghost n_nat = n as nat;\n    while (m <= n as u16)\n        invariant\n            1 < m < n + 2,\n            n <= u8::MAX,\n            0 < k <= n,\n            forall|j: u8| 1 < j < m ==> #[trigger] (k % j) != 0,\n            factorization@.fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) == n as nat / (\n            k as nat),\n            forall|i: nat|\n                0 <= i < factorization.len() ==> #[trigger] is_prime(\n                    factorization[i as int] as nat,\n                ),\n            forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n            n % k == 0,\n            forall|i: nat, j: nat|\n                (1 < i <= j < factorization.len()) ==> ((#[trigger] factorization[i as int] as nat)\n                    <= (#[trigger] factorization[j as int] as nat) <= m),\n    {\n        if (k as u16 % m == 0) {\n            assert(is_prime(m as nat)) by { lemma_first_divisor_is_prime(k as nat, m as nat) };\n            let ghost old_factors = factorization;\n            let l = factorization.len();\n            factorization.insert(l, m as u8);\n\n            assert(old_factors@.push(m as u8) == factorization@);\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((m as nat)\n                * (n as nat / (k as nat))) as nat) by {\n                lemma_unfold_right_fold_new(factorization@, old_factors@, m as u8)\n            };\n\n            assert(n % (k / m as u8) == 0) by {\n                lemma_multiple_mod_is_zero(m as int, n as int, k as int);\n            };\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((n as nat / (\n            (k / m as u8) as nat))) as nat) by {\n                lemma_multiple_mod_is_zero_new(m as int, n as int, k as int)\n            };\n\n            assert forall|j: u8| (1 < j < m && (k % j != 0)) implies #[trigger] ((k / m as u8) % j)\n                != 0 by { lemma_factor_mod_is_zero(k as int, m as int, j as int) };\n            assert((k as int) == ((k as int) / (m as int)) * (m as int)) by {\n                lemma_fundamental_div_mod(k as int, m as int)\n            };\n\n            k = k / m as u8;\n        } else {\n            m = m + 1;\n        }\n    }\n    proof {\n        assert_by_contradiction!(k == 1, {\n                assert (k % k == 0);\n            });\n    }\n\n    assert(factorization@.map(|_idx, j: u8| j as nat).fold_right(\n        |x: nat, acc: nat| (acc * x as nat),\n        1nat,\n    ) == n) by { lemma_fold_right_equivalent_for_nat_u8(factorization@) };\n    return factorization;\n}\n\n} // verus!\nfn main() {\n    print!(\"{:?}\", factorize(254));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nfactorize\n*/\n\n/*\n### CANONICAL SOLUTION\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n\n*/", "x": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{"}
{"y": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{\n    assert((old_factors.push(m)).drop_last() == old_factors);\n    assert(((k as int) / (m as int)) * (m as int) + (k as int) % (m as int) == (k as int)) by {\n        lemma_fundamental_div_mod(k as int, m as int)\n    };\n}\n\nproof fn lemma_unfold_right_fold_new(factors: Seq<u8>, old_factors: Seq<u8>, m: u8)\n    requires\n        old_factors.push(m as u8) == factors,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1nat,\n        ) * (m as nat),\n{\n    assert((old_factors.push(m as u8)).drop_last() == old_factors);\n    assert(factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n        |x, acc: nat| (acc * x) as nat,\n        1,\n    ) * (m as nat)) by { lemma_fold_right_pull_out_hybrid(old_factors, m as nat) }\n}\n\nproof fn lemma_multiple_mod_is_zero(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n    ensures\n        n % (k / m) == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n\n    assert(n == ((n / k) * m) * (k / m)) by {\n        broadcast use group_mul_properties;\n\n    };\n    assert(n % (k / m) == 0) by { lemma_mod_multiples_basic((n / k) * m, k / m) };\n}\n\nproof fn lemma_multiple_mod_is_zero_new(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n        n > 0,\n    ensures\n        m * (n / k) == n / (k / m),\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    let a = choose|a: int| (#[trigger] (a * m) == k && (a == k / m));\n\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n    let b = choose|b: int| (#[trigger] (b * k) == n && b == n / k);\n\n    assert((a * m) * b == n) by { lemma_mul_is_commutative(b, a * m) }\n    assert(a * (m * b) == n) by { lemma_mul_is_associative(a, m, b) };\n    assert((m * b) == n / a) by { lemma_div_multiples_vanish(m * b, a) };\n}\n\nproof fn lemma_factor_mod_is_zero(k: int, m: int, j: int)\n    requires\n        k % j != 0,\n        k % m == 0,\n        1 <= j < m,\n    ensures\n        (k / m) % j != 0,\n{\n    assert_by_contradiction!((k/m) % j != 0,\n            { /* proof */\n                assert (k == (k/m) * m) by {lemma_fundamental_div_mod(k, m)};\n                let a = choose|a:int| (#[trigger] (a * m) == k);\n\n                assert ((k/m) == ((k/m)/j) * j) by {lemma_fundamental_div_mod(k/m, j)};\n                let b = choose|b:int| (#[trigger] (b * j) == k/m);\n\n                calc! {\n                    (==)\n                    k % j; {broadcast use group_mul_properties;}\n                    ((b * m) * j) % j; {broadcast use lemma_mod_multiples_basic;}\n                    0;\n                }\n            });\n\n}\n\nproof fn lemma_mod_zero_twice(k: int, m: int, i: int)\n    requires\n        k % m == 0,\n        m % i == 0,\n        m > 0,\n        i > 0,\n    ensures\n        k % i == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k as int, m as int) };\n    let a = choose|a: int| (#[trigger] (a * m) == k);\n\n    assert(m == (m / i) * i) by { lemma_fundamental_div_mod(m as int, i as int) };\n    let b = choose|b: int| (#[trigger] (b * i) == m);\n\n    assert(k == (a * b) * i) by { lemma_mul_is_associative(a, b, i) };\n    assert(k % i == 0) by { lemma_mod_multiples_vanish(a * b, 0, i) };\n\n}\n\nproof fn lemma_first_divisor_is_prime(k: nat, m: nat)\n    requires\n        k % m == 0,\n        forall|j: nat| 1 < j < m ==> #[trigger] (k % j) != 0,\n        m >= 2,\n    ensures\n        is_prime(m),\n{\n    assert_by_contradiction!(is_prime(m),\n            {\n                let i = choose|i:nat| (1 < i < m && #[trigger] (m % i) == 0);\n                assert (k % i == 0) by {lemma_mod_zero_twice(k as int, m as int, i as int)};\n            })\n}\n\nproof fn lemma_drop_last_map_commute(seq: Seq<u8>)\n    requires\n        seq.len() >= 1,\n    ensures\n        seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(|_idx, j: u8| j as nat),\n{\n    assert(seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(\n        |_idx, j: u8| j as nat,\n    ));\n}\n\nproof fn lemma_fold_right_equivalent_for_nat_u8(factorization: Seq<u8>)\n    requires\n        factorization.fold_right(|x, acc: u8| (acc * x) as u8, 1u8) <= u8::MAX as u8,\n        forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n    ensures\n        factorization.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == factorization.map(\n            |_idx, j: u8| j as nat,\n        ).fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat),\n    decreases factorization.len(),\n{\n    if (factorization.len() == 0) {\n    } else {\n        let factorization_ = factorization.drop_last();\n        let last = factorization.last();\n\n        calc! {\n            (==)\n            factorization.map(|_idx, j: u8| j as nat).fold_right(|x, acc: nat| acc * x, 1nat); {\n                lemma_drop_last_map_commute(factorization)\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                (factorization.last() as nat),\n            ); {\n                lemma_fold_right_pull_out_nat(\n                    factorization.drop_last().map(|_idx, j: u8| j as nat),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                1nat,\n            ) * (factorization.last() as nat); {\n                lemma_fold_right_equivalent_for_nat_u8(factorization.drop_last())\n            }\n            factorization.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1nat) * (\n            factorization.last() as nat); {\n                lemma_fold_right_pull_out_hybrid(\n                    factorization.drop_last(),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().fold_right(\n                |x, acc: nat| (acc * x) as nat,\n                (factorization.last() as nat),\n            );\n        }\n    }\n}\n\npub fn factorize(n: u8) -> (factorization: Vec<u8>)\n    requires\n        1 <= n <= u8::MAX,\n    ensures\n        is_prime_factorization(n as nat, factorization@.map(|_idx, j: u8| j as nat)),\n{\n    let mut factorization = vec![];\n    let mut k = n;\n    let mut m = 2u16;\n    let ghost n_nat = n as nat;\n    while (m <= n as u16)\n        invariant\n            1 < m < n + 2,\n            n <= u8::MAX,\n            0 < k <= n,\n            forall|j: u8| 1 < j < m ==> #[trigger] (k % j) != 0,\n            factorization@.fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) == n as nat / (\n            k as nat),\n            forall|i: nat|\n                0 <= i < factorization.len() ==> #[trigger] is_prime(\n                    factorization[i as int] as nat,\n                ),\n            forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n            n % k == 0,\n            forall|i: nat, j: nat|\n                (1 < i <= j < factorization.len()) ==> ((#[trigger] factorization[i as int] as nat)\n                    <= (#[trigger] factorization[j as int] as nat) <= m),\n    {\n        if (k as u16 % m == 0) {\n            assert(is_prime(m as nat)) by { lemma_first_divisor_is_prime(k as nat, m as nat) };\n            let ghost old_factors = factorization;\n            let l = factorization.len();\n            factorization.insert(l, m as u8);\n\n            assert(old_factors@.push(m as u8) == factorization@);\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((m as nat)\n                * (n as nat / (k as nat))) as nat) by {\n                lemma_unfold_right_fold_new(factorization@, old_factors@, m as u8)\n            };\n\n            assert(n % (k / m as u8) == 0) by {\n                lemma_multiple_mod_is_zero(m as int, n as int, k as int);\n            };\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((n as nat / (\n            (k / m as u8) as nat))) as nat) by {\n                lemma_multiple_mod_is_zero_new(m as int, n as int, k as int)\n            };\n\n            assert forall|j: u8| (1 < j < m && (k % j != 0)) implies #[trigger] ((k / m as u8) % j)\n                != 0 by { lemma_factor_mod_is_zero(k as int, m as int, j as int) };\n            assert((k as int) == ((k as int) / (m as int)) * (m as int)) by {\n                lemma_fundamental_div_mod(k as int, m as int)\n            };\n\n            k = k / m as u8;\n        } else {\n            m = m + 1;\n        }\n    }\n    proof {\n        assert_by_contradiction!(k == 1, {\n                assert (k % k == 0);\n            });\n    }\n\n    assert(factorization@.map(|_idx, j: u8| j as nat).fold_right(\n        |x: nat, acc: nat| (acc * x as nat),\n        1nat,\n    ) == n) by { lemma_fold_right_equivalent_for_nat_u8(factorization@) };\n    return factorization;\n}\n\n} // verus!\nfn main() {\n    print!(\"{:?}\", factorize(254));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nfactorize\n*/\n\n/*\n### CANONICAL SOLUTION\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n\n*/", "x": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{"}
{"y": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{\n    assert((old_factors.push(m)).drop_last() == old_factors);\n    assert(((k as int) / (m as int)) * (m as int) + (k as int) % (m as int) == (k as int)) by {\n        lemma_fundamental_div_mod(k as int, m as int)\n    };\n}\n\nproof fn lemma_unfold_right_fold_new(factors: Seq<u8>, old_factors: Seq<u8>, m: u8)\n    requires\n        old_factors.push(m as u8) == factors,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1nat,\n        ) * (m as nat),\n{\n    assert((old_factors.push(m as u8)).drop_last() == old_factors);\n    assert(factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n        |x, acc: nat| (acc * x) as nat,\n        1,\n    ) * (m as nat)) by { lemma_fold_right_pull_out_hybrid(old_factors, m as nat) }\n}\n\nproof fn lemma_multiple_mod_is_zero(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n    ensures\n        n % (k / m) == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n\n    assert(n == ((n / k) * m) * (k / m)) by {\n        broadcast use group_mul_properties;\n\n    };\n    assert(n % (k / m) == 0) by { lemma_mod_multiples_basic((n / k) * m, k / m) };\n}\n\nproof fn lemma_multiple_mod_is_zero_new(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n        n > 0,\n    ensures\n        m * (n / k) == n / (k / m),\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    let a = choose|a: int| (#[trigger] (a * m) == k && (a == k / m));\n\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n    let b = choose|b: int| (#[trigger] (b * k) == n && b == n / k);\n\n    assert((a * m) * b == n) by { lemma_mul_is_commutative(b, a * m) }\n    assert(a * (m * b) == n) by { lemma_mul_is_associative(a, m, b) };\n    assert((m * b) == n / a) by { lemma_div_multiples_vanish(m * b, a) };\n}\n\nproof fn lemma_factor_mod_is_zero(k: int, m: int, j: int)\n    requires\n        k % j != 0,\n        k % m == 0,\n        1 <= j < m,\n    ensures\n        (k / m) % j != 0,\n{\n    assert_by_contradiction!((k/m) % j != 0,\n            { /* proof */\n                assert (k == (k/m) * m) by {lemma_fundamental_div_mod(k, m)};\n                let a = choose|a:int| (#[trigger] (a * m) == k);\n\n                assert ((k/m) == ((k/m)/j) * j) by {lemma_fundamental_div_mod(k/m, j)};\n                let b = choose|b:int| (#[trigger] (b * j) == k/m);\n\n                calc! {\n                    (==)\n                    k % j; {broadcast use group_mul_properties;}\n                    ((b * m) * j) % j; {broadcast use lemma_mod_multiples_basic;}\n                    0;\n                }\n            });\n\n}\n\nproof fn lemma_mod_zero_twice(k: int, m: int, i: int)\n    requires\n        k % m == 0,\n        m % i == 0,\n        m > 0,\n        i > 0,\n    ensures\n        k % i == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k as int, m as int) };\n    let a = choose|a: int| (#[trigger] (a * m) == k);\n\n    assert(m == (m / i) * i) by { lemma_fundamental_div_mod(m as int, i as int) };\n    let b = choose|b: int| (#[trigger] (b * i) == m);\n\n    assert(k == (a * b) * i) by { lemma_mul_is_associative(a, b, i) };\n    assert(k % i == 0) by { lemma_mod_multiples_vanish(a * b, 0, i) };\n\n}\n\nproof fn lemma_first_divisor_is_prime(k: nat, m: nat)\n    requires\n        k % m == 0,\n        forall|j: nat| 1 < j < m ==> #[trigger] (k % j) != 0,\n        m >= 2,\n    ensures\n        is_prime(m),\n{\n    assert_by_contradiction!(is_prime(m),\n            {\n                let i = choose|i:nat| (1 < i < m && #[trigger] (m % i) == 0);\n                assert (k % i == 0) by {lemma_mod_zero_twice(k as int, m as int, i as int)};\n            })\n}\n\nproof fn lemma_drop_last_map_commute(seq: Seq<u8>)\n    requires\n        seq.len() >= 1,\n    ensures\n        seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(|_idx, j: u8| j as nat),\n{\n    assert(seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(\n        |_idx, j: u8| j as nat,\n    ));\n}\n\nproof fn lemma_fold_right_equivalent_for_nat_u8(factorization: Seq<u8>)\n    requires\n        factorization.fold_right(|x, acc: u8| (acc * x) as u8, 1u8) <= u8::MAX as u8,\n        forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n    ensures\n        factorization.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == factorization.map(\n            |_idx, j: u8| j as nat,\n        ).fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat),\n    decreases factorization.len(),\n{\n    if (factorization.len() == 0) {\n    } else {\n        let factorization_ = factorization.drop_last();\n        let last = factorization.last();\n\n        calc! {\n            (==)\n            factorization.map(|_idx, j: u8| j as nat).fold_right(|x, acc: nat| acc * x, 1nat); {\n                lemma_drop_last_map_commute(factorization)\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                (factorization.last() as nat),\n            ); {\n                lemma_fold_right_pull_out_nat(\n                    factorization.drop_last().map(|_idx, j: u8| j as nat),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                1nat,\n            ) * (factorization.last() as nat); {\n                lemma_fold_right_equivalent_for_nat_u8(factorization.drop_last())\n            }\n            factorization.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1nat) * (\n            factorization.last() as nat); {\n                lemma_fold_right_pull_out_hybrid(\n                    factorization.drop_last(),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().fold_right(\n                |x, acc: nat| (acc * x) as nat,\n                (factorization.last() as nat),\n            );\n        }\n    }\n}\n\npub fn factorize(n: u8) -> (factorization: Vec<u8>)\n    requires\n        1 <= n <= u8::MAX,\n    ensures\n        is_prime_factorization(n as nat, factorization@.map(|_idx, j: u8| j as nat)),\n{\n    let mut factorization = vec![];\n    let mut k = n;\n    let mut m = 2u16;\n    let ghost n_nat = n as nat;\n    while (m <= n as u16)\n        invariant\n            1 < m < n + 2,\n            n <= u8::MAX,\n            0 < k <= n,\n            forall|j: u8| 1 < j < m ==> #[trigger] (k % j) != 0,\n            factorization@.fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) == n as nat / (\n            k as nat),\n            forall|i: nat|\n                0 <= i < factorization.len() ==> #[trigger] is_prime(\n                    factorization[i as int] as nat,\n                ),\n            forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n            n % k == 0,\n            forall|i: nat, j: nat|\n                (1 < i <= j < factorization.len()) ==> ((#[trigger] factorization[i as int] as nat)\n                    <= (#[trigger] factorization[j as int] as nat) <= m),\n    {\n        if (k as u16 % m == 0) {\n            assert(is_prime(m as nat)) by { lemma_first_divisor_is_prime(k as nat, m as nat) };\n            let ghost old_factors = factorization;\n            let l = factorization.len();\n            factorization.insert(l, m as u8);\n\n            assert(old_factors@.push(m as u8) == factorization@);\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((m as nat)\n                * (n as nat / (k as nat))) as nat) by {\n                lemma_unfold_right_fold_new(factorization@, old_factors@, m as u8)\n            };\n\n            assert(n % (k / m as u8) == 0) by {\n                lemma_multiple_mod_is_zero(m as int, n as int, k as int);\n            };\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((n as nat / (\n            (k / m as u8) as nat))) as nat) by {\n                lemma_multiple_mod_is_zero_new(m as int, n as int, k as int)\n            };\n\n            assert forall|j: u8| (1 < j < m && (k % j != 0)) implies #[trigger] ((k / m as u8) % j)\n                != 0 by { lemma_factor_mod_is_zero(k as int, m as int, j as int) };\n            assert((k as int) == ((k as int) / (m as int)) * (m as int)) by {\n                lemma_fundamental_div_mod(k as int, m as int)\n            };\n\n            k = k / m as u8;\n        } else {\n            m = m + 1;\n        }\n    }\n    proof {\n        assert_by_contradiction!(k == 1, {\n                assert (k % k == 0);\n            });\n    }\n\n    assert(factorization@.map(|_idx, j: u8| j as nat).fold_right(\n        |x: nat, acc: nat| (acc * x as nat),\n        1nat,\n    ) == n) by { lemma_fold_right_equivalent_for_nat_u8(factorization@) };\n    return factorization;\n}\n\n} // verus!\nfn main() {\n    print!(\"{:?}\", factorize(254));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nfactorize\n*/\n\n/*\n### CANONICAL SOLUTION\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n\n*/", "x": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{"}
{"y": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{\n    assert((old_factors.push(m)).drop_last() == old_factors);\n    assert(((k as int) / (m as int)) * (m as int) + (k as int) % (m as int) == (k as int)) by {\n        lemma_fundamental_div_mod(k as int, m as int)\n    };\n}\n\nproof fn lemma_unfold_right_fold_new(factors: Seq<u8>, old_factors: Seq<u8>, m: u8)\n    requires\n        old_factors.push(m as u8) == factors,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1nat,\n        ) * (m as nat),\n{\n    assert((old_factors.push(m as u8)).drop_last() == old_factors);\n    assert(factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n        |x, acc: nat| (acc * x) as nat,\n        1,\n    ) * (m as nat)) by { lemma_fold_right_pull_out_hybrid(old_factors, m as nat) }\n}\n\nproof fn lemma_multiple_mod_is_zero(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n    ensures\n        n % (k / m) == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n\n    assert(n == ((n / k) * m) * (k / m)) by {\n        broadcast use group_mul_properties;\n\n    };\n    assert(n % (k / m) == 0) by { lemma_mod_multiples_basic((n / k) * m, k / m) };\n}\n\nproof fn lemma_multiple_mod_is_zero_new(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n        n > 0,\n    ensures\n        m * (n / k) == n / (k / m),\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    let a = choose|a: int| (#[trigger] (a * m) == k && (a == k / m));\n\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n    let b = choose|b: int| (#[trigger] (b * k) == n && b == n / k);\n\n    assert((a * m) * b == n) by { lemma_mul_is_commutative(b, a * m) }\n    assert(a * (m * b) == n) by { lemma_mul_is_associative(a, m, b) };\n    assert((m * b) == n / a) by { lemma_div_multiples_vanish(m * b, a) };\n}\n\nproof fn lemma_factor_mod_is_zero(k: int, m: int, j: int)\n    requires\n        k % j != 0,\n        k % m == 0,\n        1 <= j < m,\n    ensures\n        (k / m) % j != 0,\n{\n    assert_by_contradiction!((k/m) % j != 0,\n            { /* proof */\n                assert (k == (k/m) * m) by {lemma_fundamental_div_mod(k, m)};\n                let a = choose|a:int| (#[trigger] (a * m) == k);\n\n                assert ((k/m) == ((k/m)/j) * j) by {lemma_fundamental_div_mod(k/m, j)};\n                let b = choose|b:int| (#[trigger] (b * j) == k/m);\n\n                calc! {\n                    (==)\n                    k % j; {broadcast use group_mul_properties;}\n                    ((b * m) * j) % j; {broadcast use lemma_mod_multiples_basic;}\n                    0;\n                }\n            });\n\n}\n\nproof fn lemma_mod_zero_twice(k: int, m: int, i: int)\n    requires\n        k % m == 0,\n        m % i == 0,\n        m > 0,\n        i > 0,\n    ensures\n        k % i == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k as int, m as int) };\n    let a = choose|a: int| (#[trigger] (a * m) == k);\n\n    assert(m == (m / i) * i) by { lemma_fundamental_div_mod(m as int, i as int) };\n    let b = choose|b: int| (#[trigger] (b * i) == m);\n\n    assert(k == (a * b) * i) by { lemma_mul_is_associative(a, b, i) };\n    assert(k % i == 0) by { lemma_mod_multiples_vanish(a * b, 0, i) };\n\n}\n\nproof fn lemma_first_divisor_is_prime(k: nat, m: nat)\n    requires\n        k % m == 0,\n        forall|j: nat| 1 < j < m ==> #[trigger] (k % j) != 0,\n        m >= 2,\n    ensures\n        is_prime(m),\n{\n    assert_by_contradiction!(is_prime(m),\n            {\n                let i = choose|i:nat| (1 < i < m && #[trigger] (m % i) == 0);\n                assert (k % i == 0) by {lemma_mod_zero_twice(k as int, m as int, i as int)};\n            })\n}\n\nproof fn lemma_drop_last_map_commute(seq: Seq<u8>)\n    requires\n        seq.len() >= 1,\n    ensures\n        seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(|_idx, j: u8| j as nat),\n{\n    assert(seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(\n        |_idx, j: u8| j as nat,\n    ));\n}\n\nproof fn lemma_fold_right_equivalent_for_nat_u8(factorization: Seq<u8>)\n    requires\n        factorization.fold_right(|x, acc: u8| (acc * x) as u8, 1u8) <= u8::MAX as u8,\n        forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n    ensures\n        factorization.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == factorization.map(\n            |_idx, j: u8| j as nat,\n        ).fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat),\n    decreases factorization.len(),\n{\n    if (factorization.len() == 0) {\n    } else {\n        let factorization_ = factorization.drop_last();\n        let last = factorization.last();\n\n        calc! {\n            (==)\n            factorization.map(|_idx, j: u8| j as nat).fold_right(|x, acc: nat| acc * x, 1nat); {\n                lemma_drop_last_map_commute(factorization)\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                (factorization.last() as nat),\n            ); {\n                lemma_fold_right_pull_out_nat(\n                    factorization.drop_last().map(|_idx, j: u8| j as nat),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                1nat,\n            ) * (factorization.last() as nat); {\n                lemma_fold_right_equivalent_for_nat_u8(factorization.drop_last())\n            }\n            factorization.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1nat) * (\n            factorization.last() as nat); {\n                lemma_fold_right_pull_out_hybrid(\n                    factorization.drop_last(),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().fold_right(\n                |x, acc: nat| (acc * x) as nat,\n                (factorization.last() as nat),\n            );\n        }\n    }\n}\n\npub fn factorize(n: u8) -> (factorization: Vec<u8>)\n    requires\n        1 <= n <= u8::MAX,\n    ensures\n        is_prime_factorization(n as nat, factorization@.map(|_idx, j: u8| j as nat)),\n{\n    let mut factorization = vec![];\n    let mut k = n;\n    let mut m = 2u16;\n    let ghost n_nat = n as nat;\n    while (m <= n as u16)\n        invariant\n            1 < m < n + 2,\n            n <= u8::MAX,\n            0 < k <= n,\n            forall|j: u8| 1 < j < m ==> #[trigger] (k % j) != 0,\n            factorization@.fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) == n as nat / (\n            k as nat),\n            forall|i: nat|\n                0 <= i < factorization.len() ==> #[trigger] is_prime(\n                    factorization[i as int] as nat,\n                ),\n            forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n            n % k == 0,\n            forall|i: nat, j: nat|\n                (1 < i <= j < factorization.len()) ==> ((#[trigger] factorization[i as int] as nat)\n                    <= (#[trigger] factorization[j as int] as nat) <= m),\n    {\n        if (k as u16 % m == 0) {\n            assert(is_prime(m as nat)) by { lemma_first_divisor_is_prime(k as nat, m as nat) };\n            let ghost old_factors = factorization;\n            let l = factorization.len();\n            factorization.insert(l, m as u8);\n\n            assert(old_factors@.push(m as u8) == factorization@);\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((m as nat)\n                * (n as nat / (k as nat))) as nat) by {\n                lemma_unfold_right_fold_new(factorization@, old_factors@, m as u8)\n            };\n\n            assert(n % (k / m as u8) == 0) by {\n                lemma_multiple_mod_is_zero(m as int, n as int, k as int);\n            };\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((n as nat / (\n            (k / m as u8) as nat))) as nat) by {\n                lemma_multiple_mod_is_zero_new(m as int, n as int, k as int)\n            };\n\n            assert forall|j: u8| (1 < j < m && (k % j != 0)) implies #[trigger] ((k / m as u8) % j)\n                != 0 by { lemma_factor_mod_is_zero(k as int, m as int, j as int) };\n            assert((k as int) == ((k as int) / (m as int)) * (m as int)) by {\n                lemma_fundamental_div_mod(k as int, m as int)\n            };\n\n            k = k / m as u8;\n        } else {\n            m = m + 1;\n        }\n    }\n    proof {\n        assert_by_contradiction!(k == 1, {\n                assert (k % k == 0);\n            });\n    }\n\n    assert(factorization@.map(|_idx, j: u8| j as nat).fold_right(\n        |x: nat, acc: nat| (acc * x as nat),\n        1nat,\n    ) == n) by { lemma_fold_right_equivalent_for_nat_u8(factorization@) };\n    return factorization;\n}\n\n} // verus!\nfn main() {\n    print!(\"{:?}\", factorize(254));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nfactorize\n*/\n\n/*\n### CANONICAL SOLUTION\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n\n*/", "x": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{\n    assert((old_factors.push(m)).drop_last() == old_factors);\n    assert(((k as int) / (m as int)) * (m as int) + (k as int) % (m as int) == (k as int)) by {\n        lemma_fundamental_div_mod(k as int, m as int)\n    };\n}\n\nproof fn lemma_unfold_right_fold_new(factors: Seq<u8>, old_factors: Seq<u8>, m: u8)\n    requires\n        old_factors.push(m as u8) == factors,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1nat,\n        ) * (m as nat),\n{"}
{"y": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{\n    assert((old_factors.push(m)).drop_last() == old_factors);\n    assert(((k as int) / (m as int)) * (m as int) + (k as int) % (m as int) == (k as int)) by {\n        lemma_fundamental_div_mod(k as int, m as int)\n    };\n}\n\nproof fn lemma_unfold_right_fold_new(factors: Seq<u8>, old_factors: Seq<u8>, m: u8)\n    requires\n        old_factors.push(m as u8) == factors,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1nat,\n        ) * (m as nat),\n{\n    assert((old_factors.push(m as u8)).drop_last() == old_factors);\n    assert(factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n        |x, acc: nat| (acc * x) as nat,\n        1,\n    ) * (m as nat)) by { lemma_fold_right_pull_out_hybrid(old_factors, m as nat) }\n}\n\nproof fn lemma_multiple_mod_is_zero(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n    ensures\n        n % (k / m) == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n\n    assert(n == ((n / k) * m) * (k / m)) by {\n        broadcast use group_mul_properties;\n\n    };\n    assert(n % (k / m) == 0) by { lemma_mod_multiples_basic((n / k) * m, k / m) };\n}\n\nproof fn lemma_multiple_mod_is_zero_new(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n        n > 0,\n    ensures\n        m * (n / k) == n / (k / m),\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    let a = choose|a: int| (#[trigger] (a * m) == k && (a == k / m));\n\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n    let b = choose|b: int| (#[trigger] (b * k) == n && b == n / k);\n\n    assert((a * m) * b == n) by { lemma_mul_is_commutative(b, a * m) }\n    assert(a * (m * b) == n) by { lemma_mul_is_associative(a, m, b) };\n    assert((m * b) == n / a) by { lemma_div_multiples_vanish(m * b, a) };\n}\n\nproof fn lemma_factor_mod_is_zero(k: int, m: int, j: int)\n    requires\n        k % j != 0,\n        k % m == 0,\n        1 <= j < m,\n    ensures\n        (k / m) % j != 0,\n{\n    assert_by_contradiction!((k/m) % j != 0,\n            { /* proof */\n                assert (k == (k/m) * m) by {lemma_fundamental_div_mod(k, m)};\n                let a = choose|a:int| (#[trigger] (a * m) == k);\n\n                assert ((k/m) == ((k/m)/j) * j) by {lemma_fundamental_div_mod(k/m, j)};\n                let b = choose|b:int| (#[trigger] (b * j) == k/m);\n\n                calc! {\n                    (==)\n                    k % j; {broadcast use group_mul_properties;}\n                    ((b * m) * j) % j; {broadcast use lemma_mod_multiples_basic;}\n                    0;\n                }\n            });\n\n}\n\nproof fn lemma_mod_zero_twice(k: int, m: int, i: int)\n    requires\n        k % m == 0,\n        m % i == 0,\n        m > 0,\n        i > 0,\n    ensures\n        k % i == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k as int, m as int) };\n    let a = choose|a: int| (#[trigger] (a * m) == k);\n\n    assert(m == (m / i) * i) by { lemma_fundamental_div_mod(m as int, i as int) };\n    let b = choose|b: int| (#[trigger] (b * i) == m);\n\n    assert(k == (a * b) * i) by { lemma_mul_is_associative(a, b, i) };\n    assert(k % i == 0) by { lemma_mod_multiples_vanish(a * b, 0, i) };\n\n}\n\nproof fn lemma_first_divisor_is_prime(k: nat, m: nat)\n    requires\n        k % m == 0,\n        forall|j: nat| 1 < j < m ==> #[trigger] (k % j) != 0,\n        m >= 2,\n    ensures\n        is_prime(m),\n{\n    assert_by_contradiction!(is_prime(m),\n            {\n                let i = choose|i:nat| (1 < i < m && #[trigger] (m % i) == 0);\n                assert (k % i == 0) by {lemma_mod_zero_twice(k as int, m as int, i as int)};\n            })\n}\n\nproof fn lemma_drop_last_map_commute(seq: Seq<u8>)\n    requires\n        seq.len() >= 1,\n    ensures\n        seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(|_idx, j: u8| j as nat),\n{\n    assert(seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(\n        |_idx, j: u8| j as nat,\n    ));\n}\n\nproof fn lemma_fold_right_equivalent_for_nat_u8(factorization: Seq<u8>)\n    requires\n        factorization.fold_right(|x, acc: u8| (acc * x) as u8, 1u8) <= u8::MAX as u8,\n        forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n    ensures\n        factorization.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == factorization.map(\n            |_idx, j: u8| j as nat,\n        ).fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat),\n    decreases factorization.len(),\n{\n    if (factorization.len() == 0) {\n    } else {\n        let factorization_ = factorization.drop_last();\n        let last = factorization.last();\n\n        calc! {\n            (==)\n            factorization.map(|_idx, j: u8| j as nat).fold_right(|x, acc: nat| acc * x, 1nat); {\n                lemma_drop_last_map_commute(factorization)\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                (factorization.last() as nat),\n            ); {\n                lemma_fold_right_pull_out_nat(\n                    factorization.drop_last().map(|_idx, j: u8| j as nat),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                1nat,\n            ) * (factorization.last() as nat); {\n                lemma_fold_right_equivalent_for_nat_u8(factorization.drop_last())\n            }\n            factorization.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1nat) * (\n            factorization.last() as nat); {\n                lemma_fold_right_pull_out_hybrid(\n                    factorization.drop_last(),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().fold_right(\n                |x, acc: nat| (acc * x) as nat,\n                (factorization.last() as nat),\n            );\n        }\n    }\n}\n\npub fn factorize(n: u8) -> (factorization: Vec<u8>)\n    requires\n        1 <= n <= u8::MAX,\n    ensures\n        is_prime_factorization(n as nat, factorization@.map(|_idx, j: u8| j as nat)),\n{\n    let mut factorization = vec![];\n    let mut k = n;\n    let mut m = 2u16;\n    let ghost n_nat = n as nat;\n    while (m <= n as u16)\n        invariant\n            1 < m < n + 2,\n            n <= u8::MAX,\n            0 < k <= n,\n            forall|j: u8| 1 < j < m ==> #[trigger] (k % j) != 0,\n            factorization@.fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) == n as nat / (\n            k as nat),\n            forall|i: nat|\n                0 <= i < factorization.len() ==> #[trigger] is_prime(\n                    factorization[i as int] as nat,\n                ),\n            forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n            n % k == 0,\n            forall|i: nat, j: nat|\n                (1 < i <= j < factorization.len()) ==> ((#[trigger] factorization[i as int] as nat)\n                    <= (#[trigger] factorization[j as int] as nat) <= m),\n    {\n        if (k as u16 % m == 0) {\n            assert(is_prime(m as nat)) by { lemma_first_divisor_is_prime(k as nat, m as nat) };\n            let ghost old_factors = factorization;\n            let l = factorization.len();\n            factorization.insert(l, m as u8);\n\n            assert(old_factors@.push(m as u8) == factorization@);\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((m as nat)\n                * (n as nat / (k as nat))) as nat) by {\n                lemma_unfold_right_fold_new(factorization@, old_factors@, m as u8)\n            };\n\n            assert(n % (k / m as u8) == 0) by {\n                lemma_multiple_mod_is_zero(m as int, n as int, k as int);\n            };\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((n as nat / (\n            (k / m as u8) as nat))) as nat) by {\n                lemma_multiple_mod_is_zero_new(m as int, n as int, k as int)\n            };\n\n            assert forall|j: u8| (1 < j < m && (k % j != 0)) implies #[trigger] ((k / m as u8) % j)\n                != 0 by { lemma_factor_mod_is_zero(k as int, m as int, j as int) };\n            assert((k as int) == ((k as int) / (m as int)) * (m as int)) by {\n                lemma_fundamental_div_mod(k as int, m as int)\n            };\n\n            k = k / m as u8;\n        } else {\n            m = m + 1;\n        }\n    }\n    proof {\n        assert_by_contradiction!(k == 1, {\n                assert (k % k == 0);\n            });\n    }\n\n    assert(factorization@.map(|_idx, j: u8| j as nat).fold_right(\n        |x: nat, acc: nat| (acc * x as nat),\n        1nat,\n    ) == n) by { lemma_fold_right_equivalent_for_nat_u8(factorization@) };\n    return factorization;\n}\n\n} // verus!\nfn main() {\n    print!(\"{:?}\", factorize(254));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nfactorize\n*/\n\n/*\n### CANONICAL SOLUTION\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n\n*/", "x": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{\n    assert((old_factors.push(m)).drop_last() == old_factors);\n    assert(((k as int) / (m as int)) * (m as int) + (k as int) % (m as int) == (k as int)) by {\n        lemma_fundamental_div_mod(k as int, m as int)\n    };\n}\n\nproof fn lemma_unfold_right_fold_new(factors: Seq<u8>, old_factors: Seq<u8>, m: u8)\n    requires\n        old_factors.push(m as u8) == factors,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1nat,\n        ) * (m as nat),\n{\n    assert((old_factors.push(m as u8)).drop_last() == old_factors);\n    assert(factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n        |x, acc: nat| (acc * x) as nat,\n        1,\n    ) * (m as nat)) by { lemma_fold_right_pull_out_hybrid(old_factors, m as nat) }\n}\n\nproof fn lemma_multiple_mod_is_zero(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n    ensures\n        n % (k / m) == 0,\n{"}
{"y": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{\n    assert((old_factors.push(m)).drop_last() == old_factors);\n    assert(((k as int) / (m as int)) * (m as int) + (k as int) % (m as int) == (k as int)) by {\n        lemma_fundamental_div_mod(k as int, m as int)\n    };\n}\n\nproof fn lemma_unfold_right_fold_new(factors: Seq<u8>, old_factors: Seq<u8>, m: u8)\n    requires\n        old_factors.push(m as u8) == factors,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1nat,\n        ) * (m as nat),\n{\n    assert((old_factors.push(m as u8)).drop_last() == old_factors);\n    assert(factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n        |x, acc: nat| (acc * x) as nat,\n        1,\n    ) * (m as nat)) by { lemma_fold_right_pull_out_hybrid(old_factors, m as nat) }\n}\n\nproof fn lemma_multiple_mod_is_zero(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n    ensures\n        n % (k / m) == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n\n    assert(n == ((n / k) * m) * (k / m)) by {\n        broadcast use group_mul_properties;\n\n    };\n    assert(n % (k / m) == 0) by { lemma_mod_multiples_basic((n / k) * m, k / m) };\n}\n\nproof fn lemma_multiple_mod_is_zero_new(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n        n > 0,\n    ensures\n        m * (n / k) == n / (k / m),\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    let a = choose|a: int| (#[trigger] (a * m) == k && (a == k / m));\n\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n    let b = choose|b: int| (#[trigger] (b * k) == n && b == n / k);\n\n    assert((a * m) * b == n) by { lemma_mul_is_commutative(b, a * m) }\n    assert(a * (m * b) == n) by { lemma_mul_is_associative(a, m, b) };\n    assert((m * b) == n / a) by { lemma_div_multiples_vanish(m * b, a) };\n}\n\nproof fn lemma_factor_mod_is_zero(k: int, m: int, j: int)\n    requires\n        k % j != 0,\n        k % m == 0,\n        1 <= j < m,\n    ensures\n        (k / m) % j != 0,\n{\n    assert_by_contradiction!((k/m) % j != 0,\n            { /* proof */\n                assert (k == (k/m) * m) by {lemma_fundamental_div_mod(k, m)};\n                let a = choose|a:int| (#[trigger] (a * m) == k);\n\n                assert ((k/m) == ((k/m)/j) * j) by {lemma_fundamental_div_mod(k/m, j)};\n                let b = choose|b:int| (#[trigger] (b * j) == k/m);\n\n                calc! {\n                    (==)\n                    k % j; {broadcast use group_mul_properties;}\n                    ((b * m) * j) % j; {broadcast use lemma_mod_multiples_basic;}\n                    0;\n                }\n            });\n\n}\n\nproof fn lemma_mod_zero_twice(k: int, m: int, i: int)\n    requires\n        k % m == 0,\n        m % i == 0,\n        m > 0,\n        i > 0,\n    ensures\n        k % i == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k as int, m as int) };\n    let a = choose|a: int| (#[trigger] (a * m) == k);\n\n    assert(m == (m / i) * i) by { lemma_fundamental_div_mod(m as int, i as int) };\n    let b = choose|b: int| (#[trigger] (b * i) == m);\n\n    assert(k == (a * b) * i) by { lemma_mul_is_associative(a, b, i) };\n    assert(k % i == 0) by { lemma_mod_multiples_vanish(a * b, 0, i) };\n\n}\n\nproof fn lemma_first_divisor_is_prime(k: nat, m: nat)\n    requires\n        k % m == 0,\n        forall|j: nat| 1 < j < m ==> #[trigger] (k % j) != 0,\n        m >= 2,\n    ensures\n        is_prime(m),\n{\n    assert_by_contradiction!(is_prime(m),\n            {\n                let i = choose|i:nat| (1 < i < m && #[trigger] (m % i) == 0);\n                assert (k % i == 0) by {lemma_mod_zero_twice(k as int, m as int, i as int)};\n            })\n}\n\nproof fn lemma_drop_last_map_commute(seq: Seq<u8>)\n    requires\n        seq.len() >= 1,\n    ensures\n        seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(|_idx, j: u8| j as nat),\n{\n    assert(seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(\n        |_idx, j: u8| j as nat,\n    ));\n}\n\nproof fn lemma_fold_right_equivalent_for_nat_u8(factorization: Seq<u8>)\n    requires\n        factorization.fold_right(|x, acc: u8| (acc * x) as u8, 1u8) <= u8::MAX as u8,\n        forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n    ensures\n        factorization.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == factorization.map(\n            |_idx, j: u8| j as nat,\n        ).fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat),\n    decreases factorization.len(),\n{\n    if (factorization.len() == 0) {\n    } else {\n        let factorization_ = factorization.drop_last();\n        let last = factorization.last();\n\n        calc! {\n            (==)\n            factorization.map(|_idx, j: u8| j as nat).fold_right(|x, acc: nat| acc * x, 1nat); {\n                lemma_drop_last_map_commute(factorization)\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                (factorization.last() as nat),\n            ); {\n                lemma_fold_right_pull_out_nat(\n                    factorization.drop_last().map(|_idx, j: u8| j as nat),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                1nat,\n            ) * (factorization.last() as nat); {\n                lemma_fold_right_equivalent_for_nat_u8(factorization.drop_last())\n            }\n            factorization.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1nat) * (\n            factorization.last() as nat); {\n                lemma_fold_right_pull_out_hybrid(\n                    factorization.drop_last(),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().fold_right(\n                |x, acc: nat| (acc * x) as nat,\n                (factorization.last() as nat),\n            );\n        }\n    }\n}\n\npub fn factorize(n: u8) -> (factorization: Vec<u8>)\n    requires\n        1 <= n <= u8::MAX,\n    ensures\n        is_prime_factorization(n as nat, factorization@.map(|_idx, j: u8| j as nat)),\n{\n    let mut factorization = vec![];\n    let mut k = n;\n    let mut m = 2u16;\n    let ghost n_nat = n as nat;\n    while (m <= n as u16)\n        invariant\n            1 < m < n + 2,\n            n <= u8::MAX,\n            0 < k <= n,\n            forall|j: u8| 1 < j < m ==> #[trigger] (k % j) != 0,\n            factorization@.fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) == n as nat / (\n            k as nat),\n            forall|i: nat|\n                0 <= i < factorization.len() ==> #[trigger] is_prime(\n                    factorization[i as int] as nat,\n                ),\n            forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n            n % k == 0,\n            forall|i: nat, j: nat|\n                (1 < i <= j < factorization.len()) ==> ((#[trigger] factorization[i as int] as nat)\n                    <= (#[trigger] factorization[j as int] as nat) <= m),\n    {\n        if (k as u16 % m == 0) {\n            assert(is_prime(m as nat)) by { lemma_first_divisor_is_prime(k as nat, m as nat) };\n            let ghost old_factors = factorization;\n            let l = factorization.len();\n            factorization.insert(l, m as u8);\n\n            assert(old_factors@.push(m as u8) == factorization@);\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((m as nat)\n                * (n as nat / (k as nat))) as nat) by {\n                lemma_unfold_right_fold_new(factorization@, old_factors@, m as u8)\n            };\n\n            assert(n % (k / m as u8) == 0) by {\n                lemma_multiple_mod_is_zero(m as int, n as int, k as int);\n            };\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((n as nat / (\n            (k / m as u8) as nat))) as nat) by {\n                lemma_multiple_mod_is_zero_new(m as int, n as int, k as int)\n            };\n\n            assert forall|j: u8| (1 < j < m && (k % j != 0)) implies #[trigger] ((k / m as u8) % j)\n                != 0 by { lemma_factor_mod_is_zero(k as int, m as int, j as int) };\n            assert((k as int) == ((k as int) / (m as int)) * (m as int)) by {\n                lemma_fundamental_div_mod(k as int, m as int)\n            };\n\n            k = k / m as u8;\n        } else {\n            m = m + 1;\n        }\n    }\n    proof {\n        assert_by_contradiction!(k == 1, {\n                assert (k % k == 0);\n            });\n    }\n\n    assert(factorization@.map(|_idx, j: u8| j as nat).fold_right(\n        |x: nat, acc: nat| (acc * x as nat),\n        1nat,\n    ) == n) by { lemma_fold_right_equivalent_for_nat_u8(factorization@) };\n    return factorization;\n}\n\n} // verus!\nfn main() {\n    print!(\"{:?}\", factorize(254));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nfactorize\n*/\n\n/*\n### CANONICAL SOLUTION\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n\n*/", "x": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{\n    assert((old_factors.push(m)).drop_last() == old_factors);\n    assert(((k as int) / (m as int)) * (m as int) + (k as int) % (m as int) == (k as int)) by {\n        lemma_fundamental_div_mod(k as int, m as int)\n    };\n}\n\nproof fn lemma_unfold_right_fold_new(factors: Seq<u8>, old_factors: Seq<u8>, m: u8)\n    requires\n        old_factors.push(m as u8) == factors,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1nat,\n        ) * (m as nat),\n{\n    assert((old_factors.push(m as u8)).drop_last() == old_factors);\n    assert(factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n        |x, acc: nat| (acc * x) as nat,\n        1,\n    ) * (m as nat)) by { lemma_fold_right_pull_out_hybrid(old_factors, m as nat) }\n}\n\nproof fn lemma_multiple_mod_is_zero(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n    ensures\n        n % (k / m) == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n\n    assert(n == ((n / k) * m) * (k / m)) by {\n        broadcast use group_mul_properties;\n\n    };\n    assert(n % (k / m) == 0) by { lemma_mod_multiples_basic((n / k) * m, k / m) };\n}\n\nproof fn lemma_multiple_mod_is_zero_new(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n        n > 0,\n    ensures\n        m * (n / k) == n / (k / m),\n{"}
{"y": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{\n    assert((old_factors.push(m)).drop_last() == old_factors);\n    assert(((k as int) / (m as int)) * (m as int) + (k as int) % (m as int) == (k as int)) by {\n        lemma_fundamental_div_mod(k as int, m as int)\n    };\n}\n\nproof fn lemma_unfold_right_fold_new(factors: Seq<u8>, old_factors: Seq<u8>, m: u8)\n    requires\n        old_factors.push(m as u8) == factors,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1nat,\n        ) * (m as nat),\n{\n    assert((old_factors.push(m as u8)).drop_last() == old_factors);\n    assert(factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n        |x, acc: nat| (acc * x) as nat,\n        1,\n    ) * (m as nat)) by { lemma_fold_right_pull_out_hybrid(old_factors, m as nat) }\n}\n\nproof fn lemma_multiple_mod_is_zero(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n    ensures\n        n % (k / m) == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n\n    assert(n == ((n / k) * m) * (k / m)) by {\n        broadcast use group_mul_properties;\n\n    };\n    assert(n % (k / m) == 0) by { lemma_mod_multiples_basic((n / k) * m, k / m) };\n}\n\nproof fn lemma_multiple_mod_is_zero_new(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n        n > 0,\n    ensures\n        m * (n / k) == n / (k / m),\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    let a = choose|a: int| (#[trigger] (a * m) == k && (a == k / m));\n\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n    let b = choose|b: int| (#[trigger] (b * k) == n && b == n / k);\n\n    assert((a * m) * b == n) by { lemma_mul_is_commutative(b, a * m) }\n    assert(a * (m * b) == n) by { lemma_mul_is_associative(a, m, b) };\n    assert((m * b) == n / a) by { lemma_div_multiples_vanish(m * b, a) };\n}\n\nproof fn lemma_factor_mod_is_zero(k: int, m: int, j: int)\n    requires\n        k % j != 0,\n        k % m == 0,\n        1 <= j < m,\n    ensures\n        (k / m) % j != 0,\n{\n    assert_by_contradiction!((k/m) % j != 0,\n            { /* proof */\n                assert (k == (k/m) * m) by {lemma_fundamental_div_mod(k, m)};\n                let a = choose|a:int| (#[trigger] (a * m) == k);\n\n                assert ((k/m) == ((k/m)/j) * j) by {lemma_fundamental_div_mod(k/m, j)};\n                let b = choose|b:int| (#[trigger] (b * j) == k/m);\n\n                calc! {\n                    (==)\n                    k % j; {broadcast use group_mul_properties;}\n                    ((b * m) * j) % j; {broadcast use lemma_mod_multiples_basic;}\n                    0;\n                }\n            });\n\n}\n\nproof fn lemma_mod_zero_twice(k: int, m: int, i: int)\n    requires\n        k % m == 0,\n        m % i == 0,\n        m > 0,\n        i > 0,\n    ensures\n        k % i == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k as int, m as int) };\n    let a = choose|a: int| (#[trigger] (a * m) == k);\n\n    assert(m == (m / i) * i) by { lemma_fundamental_div_mod(m as int, i as int) };\n    let b = choose|b: int| (#[trigger] (b * i) == m);\n\n    assert(k == (a * b) * i) by { lemma_mul_is_associative(a, b, i) };\n    assert(k % i == 0) by { lemma_mod_multiples_vanish(a * b, 0, i) };\n\n}\n\nproof fn lemma_first_divisor_is_prime(k: nat, m: nat)\n    requires\n        k % m == 0,\n        forall|j: nat| 1 < j < m ==> #[trigger] (k % j) != 0,\n        m >= 2,\n    ensures\n        is_prime(m),\n{\n    assert_by_contradiction!(is_prime(m),\n            {\n                let i = choose|i:nat| (1 < i < m && #[trigger] (m % i) == 0);\n                assert (k % i == 0) by {lemma_mod_zero_twice(k as int, m as int, i as int)};\n            })\n}\n\nproof fn lemma_drop_last_map_commute(seq: Seq<u8>)\n    requires\n        seq.len() >= 1,\n    ensures\n        seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(|_idx, j: u8| j as nat),\n{\n    assert(seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(\n        |_idx, j: u8| j as nat,\n    ));\n}\n\nproof fn lemma_fold_right_equivalent_for_nat_u8(factorization: Seq<u8>)\n    requires\n        factorization.fold_right(|x, acc: u8| (acc * x) as u8, 1u8) <= u8::MAX as u8,\n        forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n    ensures\n        factorization.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == factorization.map(\n            |_idx, j: u8| j as nat,\n        ).fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat),\n    decreases factorization.len(),\n{\n    if (factorization.len() == 0) {\n    } else {\n        let factorization_ = factorization.drop_last();\n        let last = factorization.last();\n\n        calc! {\n            (==)\n            factorization.map(|_idx, j: u8| j as nat).fold_right(|x, acc: nat| acc * x, 1nat); {\n                lemma_drop_last_map_commute(factorization)\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                (factorization.last() as nat),\n            ); {\n                lemma_fold_right_pull_out_nat(\n                    factorization.drop_last().map(|_idx, j: u8| j as nat),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                1nat,\n            ) * (factorization.last() as nat); {\n                lemma_fold_right_equivalent_for_nat_u8(factorization.drop_last())\n            }\n            factorization.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1nat) * (\n            factorization.last() as nat); {\n                lemma_fold_right_pull_out_hybrid(\n                    factorization.drop_last(),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().fold_right(\n                |x, acc: nat| (acc * x) as nat,\n                (factorization.last() as nat),\n            );\n        }\n    }\n}\n\npub fn factorize(n: u8) -> (factorization: Vec<u8>)\n    requires\n        1 <= n <= u8::MAX,\n    ensures\n        is_prime_factorization(n as nat, factorization@.map(|_idx, j: u8| j as nat)),\n{\n    let mut factorization = vec![];\n    let mut k = n;\n    let mut m = 2u16;\n    let ghost n_nat = n as nat;\n    while (m <= n as u16)\n        invariant\n            1 < m < n + 2,\n            n <= u8::MAX,\n            0 < k <= n,\n            forall|j: u8| 1 < j < m ==> #[trigger] (k % j) != 0,\n            factorization@.fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) == n as nat / (\n            k as nat),\n            forall|i: nat|\n                0 <= i < factorization.len() ==> #[trigger] is_prime(\n                    factorization[i as int] as nat,\n                ),\n            forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n            n % k == 0,\n            forall|i: nat, j: nat|\n                (1 < i <= j < factorization.len()) ==> ((#[trigger] factorization[i as int] as nat)\n                    <= (#[trigger] factorization[j as int] as nat) <= m),\n    {\n        if (k as u16 % m == 0) {\n            assert(is_prime(m as nat)) by { lemma_first_divisor_is_prime(k as nat, m as nat) };\n            let ghost old_factors = factorization;\n            let l = factorization.len();\n            factorization.insert(l, m as u8);\n\n            assert(old_factors@.push(m as u8) == factorization@);\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((m as nat)\n                * (n as nat / (k as nat))) as nat) by {\n                lemma_unfold_right_fold_new(factorization@, old_factors@, m as u8)\n            };\n\n            assert(n % (k / m as u8) == 0) by {\n                lemma_multiple_mod_is_zero(m as int, n as int, k as int);\n            };\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((n as nat / (\n            (k / m as u8) as nat))) as nat) by {\n                lemma_multiple_mod_is_zero_new(m as int, n as int, k as int)\n            };\n\n            assert forall|j: u8| (1 < j < m && (k % j != 0)) implies #[trigger] ((k / m as u8) % j)\n                != 0 by { lemma_factor_mod_is_zero(k as int, m as int, j as int) };\n            assert((k as int) == ((k as int) / (m as int)) * (m as int)) by {\n                lemma_fundamental_div_mod(k as int, m as int)\n            };\n\n            k = k / m as u8;\n        } else {\n            m = m + 1;\n        }\n    }\n    proof {\n        assert_by_contradiction!(k == 1, {\n                assert (k % k == 0);\n            });\n    }\n\n    assert(factorization@.map(|_idx, j: u8| j as nat).fold_right(\n        |x: nat, acc: nat| (acc * x as nat),\n        1nat,\n    ) == n) by { lemma_fold_right_equivalent_for_nat_u8(factorization@) };\n    return factorization;\n}\n\n} // verus!\nfn main() {\n    print!(\"{:?}\", factorize(254));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nfactorize\n*/\n\n/*\n### CANONICAL SOLUTION\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n\n*/", "x": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{\n    assert((old_factors.push(m)).drop_last() == old_factors);\n    assert(((k as int) / (m as int)) * (m as int) + (k as int) % (m as int) == (k as int)) by {\n        lemma_fundamental_div_mod(k as int, m as int)\n    };\n}\n\nproof fn lemma_unfold_right_fold_new(factors: Seq<u8>, old_factors: Seq<u8>, m: u8)\n    requires\n        old_factors.push(m as u8) == factors,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1nat,\n        ) * (m as nat),\n{\n    assert((old_factors.push(m as u8)).drop_last() == old_factors);\n    assert(factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n        |x, acc: nat| (acc * x) as nat,\n        1,\n    ) * (m as nat)) by { lemma_fold_right_pull_out_hybrid(old_factors, m as nat) }\n}\n\nproof fn lemma_multiple_mod_is_zero(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n    ensures\n        n % (k / m) == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n\n    assert(n == ((n / k) * m) * (k / m)) by {\n        broadcast use group_mul_properties;\n\n    };\n    assert(n % (k / m) == 0) by { lemma_mod_multiples_basic((n / k) * m, k / m) };\n}\n\nproof fn lemma_multiple_mod_is_zero_new(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n        n > 0,\n    ensures\n        m * (n / k) == n / (k / m),\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    let a = choose|a: int| (#[trigger] (a * m) == k && (a == k / m));\n\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n    let b = choose|b: int| (#[trigger] (b * k) == n && b == n / k);\n\n    assert((a * m) * b == n) by { lemma_mul_is_commutative(b, a * m) }\n    assert(a * (m * b) == n) by { lemma_mul_is_associative(a, m, b) };\n    assert((m * b) == n / a) by { lemma_div_multiples_vanish(m * b, a) };\n}\n\nproof fn lemma_factor_mod_is_zero(k: int, m: int, j: int)\n    requires\n        k % j != 0,\n        k % m == 0,\n        1 <= j < m,\n    ensures\n        (k / m) % j != 0,\n{"}
{"y": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{\n    assert((old_factors.push(m)).drop_last() == old_factors);\n    assert(((k as int) / (m as int)) * (m as int) + (k as int) % (m as int) == (k as int)) by {\n        lemma_fundamental_div_mod(k as int, m as int)\n    };\n}\n\nproof fn lemma_unfold_right_fold_new(factors: Seq<u8>, old_factors: Seq<u8>, m: u8)\n    requires\n        old_factors.push(m as u8) == factors,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1nat,\n        ) * (m as nat),\n{\n    assert((old_factors.push(m as u8)).drop_last() == old_factors);\n    assert(factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n        |x, acc: nat| (acc * x) as nat,\n        1,\n    ) * (m as nat)) by { lemma_fold_right_pull_out_hybrid(old_factors, m as nat) }\n}\n\nproof fn lemma_multiple_mod_is_zero(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n    ensures\n        n % (k / m) == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n\n    assert(n == ((n / k) * m) * (k / m)) by {\n        broadcast use group_mul_properties;\n\n    };\n    assert(n % (k / m) == 0) by { lemma_mod_multiples_basic((n / k) * m, k / m) };\n}\n\nproof fn lemma_multiple_mod_is_zero_new(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n        n > 0,\n    ensures\n        m * (n / k) == n / (k / m),\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    let a = choose|a: int| (#[trigger] (a * m) == k && (a == k / m));\n\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n    let b = choose|b: int| (#[trigger] (b * k) == n && b == n / k);\n\n    assert((a * m) * b == n) by { lemma_mul_is_commutative(b, a * m) }\n    assert(a * (m * b) == n) by { lemma_mul_is_associative(a, m, b) };\n    assert((m * b) == n / a) by { lemma_div_multiples_vanish(m * b, a) };\n}\n\nproof fn lemma_factor_mod_is_zero(k: int, m: int, j: int)\n    requires\n        k % j != 0,\n        k % m == 0,\n        1 <= j < m,\n    ensures\n        (k / m) % j != 0,\n{\n    assert_by_contradiction!((k/m) % j != 0,\n            { /* proof */\n                assert (k == (k/m) * m) by {lemma_fundamental_div_mod(k, m)};\n                let a = choose|a:int| (#[trigger] (a * m) == k);\n\n                assert ((k/m) == ((k/m)/j) * j) by {lemma_fundamental_div_mod(k/m, j)};\n                let b = choose|b:int| (#[trigger] (b * j) == k/m);\n\n                calc! {\n                    (==)\n                    k % j; {broadcast use group_mul_properties;}\n                    ((b * m) * j) % j; {broadcast use lemma_mod_multiples_basic;}\n                    0;\n                }\n            });\n\n}\n\nproof fn lemma_mod_zero_twice(k: int, m: int, i: int)\n    requires\n        k % m == 0,\n        m % i == 0,\n        m > 0,\n        i > 0,\n    ensures\n        k % i == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k as int, m as int) };\n    let a = choose|a: int| (#[trigger] (a * m) == k);\n\n    assert(m == (m / i) * i) by { lemma_fundamental_div_mod(m as int, i as int) };\n    let b = choose|b: int| (#[trigger] (b * i) == m);\n\n    assert(k == (a * b) * i) by { lemma_mul_is_associative(a, b, i) };\n    assert(k % i == 0) by { lemma_mod_multiples_vanish(a * b, 0, i) };\n\n}\n\nproof fn lemma_first_divisor_is_prime(k: nat, m: nat)\n    requires\n        k % m == 0,\n        forall|j: nat| 1 < j < m ==> #[trigger] (k % j) != 0,\n        m >= 2,\n    ensures\n        is_prime(m),\n{\n    assert_by_contradiction!(is_prime(m),\n            {\n                let i = choose|i:nat| (1 < i < m && #[trigger] (m % i) == 0);\n                assert (k % i == 0) by {lemma_mod_zero_twice(k as int, m as int, i as int)};\n            })\n}\n\nproof fn lemma_drop_last_map_commute(seq: Seq<u8>)\n    requires\n        seq.len() >= 1,\n    ensures\n        seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(|_idx, j: u8| j as nat),\n{\n    assert(seq.map(|_idx, j: u8| j as nat).drop_last() == seq.drop_last().map(\n        |_idx, j: u8| j as nat,\n    ));\n}\n\nproof fn lemma_fold_right_equivalent_for_nat_u8(factorization: Seq<u8>)\n    requires\n        factorization.fold_right(|x, acc: u8| (acc * x) as u8, 1u8) <= u8::MAX as u8,\n        forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n    ensures\n        factorization.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == factorization.map(\n            |_idx, j: u8| j as nat,\n        ).fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat),\n    decreases factorization.len(),\n{\n    if (factorization.len() == 0) {\n    } else {\n        let factorization_ = factorization.drop_last();\n        let last = factorization.last();\n\n        calc! {\n            (==)\n            factorization.map(|_idx, j: u8| j as nat).fold_right(|x, acc: nat| acc * x, 1nat); {\n                lemma_drop_last_map_commute(factorization)\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                (factorization.last() as nat),\n            ); {\n                lemma_fold_right_pull_out_nat(\n                    factorization.drop_last().map(|_idx, j: u8| j as nat),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().map(|_idx, j: u8| j as nat).fold_right(\n                |x, acc: nat| acc * x,\n                1nat,\n            ) * (factorization.last() as nat); {\n                lemma_fold_right_equivalent_for_nat_u8(factorization.drop_last())\n            }\n            factorization.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1nat) * (\n            factorization.last() as nat); {\n                lemma_fold_right_pull_out_hybrid(\n                    factorization.drop_last(),\n                    (factorization.last() as nat),\n                )\n            }\n            factorization.drop_last().fold_right(\n                |x, acc: nat| (acc * x) as nat,\n                (factorization.last() as nat),\n            );\n        }\n    }\n}\n\npub fn factorize(n: u8) -> (factorization: Vec<u8>)\n    requires\n        1 <= n <= u8::MAX,\n    ensures\n        is_prime_factorization(n as nat, factorization@.map(|_idx, j: u8| j as nat)),\n{\n    let mut factorization = vec![];\n    let mut k = n;\n    let mut m = 2u16;\n    let ghost n_nat = n as nat;\n    while (m <= n as u16)\n        invariant\n            1 < m < n + 2,\n            n <= u8::MAX,\n            0 < k <= n,\n            forall|j: u8| 1 < j < m ==> #[trigger] (k % j) != 0,\n            factorization@.fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) == n as nat / (\n            k as nat),\n            forall|i: nat|\n                0 <= i < factorization.len() ==> #[trigger] is_prime(\n                    factorization[i as int] as nat,\n                ),\n            forall|i: int| 0 <= i < factorization.len() ==> factorization[i] > 0,\n            n % k == 0,\n            forall|i: nat, j: nat|\n                (1 < i <= j < factorization.len()) ==> ((#[trigger] factorization[i as int] as nat)\n                    <= (#[trigger] factorization[j as int] as nat) <= m),\n    {\n        if (k as u16 % m == 0) {\n            assert(is_prime(m as nat)) by { lemma_first_divisor_is_prime(k as nat, m as nat) };\n            let ghost old_factors = factorization;\n            let l = factorization.len();\n            factorization.insert(l, m as u8);\n\n            assert(old_factors@.push(m as u8) == factorization@);\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((m as nat)\n                * (n as nat / (k as nat))) as nat) by {\n                lemma_unfold_right_fold_new(factorization@, old_factors@, m as u8)\n            };\n\n            assert(n % (k / m as u8) == 0) by {\n                lemma_multiple_mod_is_zero(m as int, n as int, k as int);\n            };\n\n            assert(factorization@.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == ((n as nat / (\n            (k / m as u8) as nat))) as nat) by {\n                lemma_multiple_mod_is_zero_new(m as int, n as int, k as int)\n            };\n\n            assert forall|j: u8| (1 < j < m && (k % j != 0)) implies #[trigger] ((k / m as u8) % j)\n                != 0 by { lemma_factor_mod_is_zero(k as int, m as int, j as int) };\n            assert((k as int) == ((k as int) / (m as int)) * (m as int)) by {\n                lemma_fundamental_div_mod(k as int, m as int)\n            };\n\n            k = k / m as u8;\n        } else {\n            m = m + 1;\n        }\n    }\n    proof {\n        assert_by_contradiction!(k == 1, {\n                assert (k % k == 0);\n            });\n    }\n\n    assert(factorization@.map(|_idx, j: u8| j as nat).fold_right(\n        |x: nat, acc: nat| (acc * x as nat),\n        1nat,\n    ) == n) by { lemma_fold_right_equivalent_for_nat_u8(factorization@) };\n    return factorization;\n}\n\n} // verus!\nfn main() {\n    print!(\"{:?}\", factorize(254));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\nfrom typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nfactorize\n*/\n\n/*\n### CANONICAL SOLUTION\n    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n //= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n\n*/", "x": "use vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::assert_by_contradiction;\nuse vstd::calc;\nuse vstd::prelude::*;\n\nverus! {\n\npub closed spec fn is_prime(n: nat) -> bool {\n    forall|i: nat| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\n// canonical definition of prime factoriztion\npub closed spec fn is_prime_factorization(n: nat, factorization: Seq<nat>) -> bool {\n    // all factors are prime\n    &&& forall|i: int|\n        0 <= i < factorization.len() ==> #[trigger] is_prime(\n            factorization[i] as nat,\n        )\n    // product of factors is n\n    &&& factorization.fold_right(|x: nat, acc: nat| (acc * x as nat), 1nat)\n        == n\n    // factors are listed in ascending order\n    &&& forall|i: nat, j: nat|\n        (1 < i <= j < factorization.len()) ==> (#[trigger] factorization[i as int]\n            <= #[trigger] factorization[j as int])\n}\n\n// these two pull out lemmas are the same except for types\n// would prefer to have one polymorphic function, but won't go through\n// See https://github.com/verus-lang/verus/issues/1287\nproof fn lemma_fold_right_pull_out_nat(seq: Seq<nat>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_nat(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: nat, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }  // {lemma_mul_is_associative(seq.drop_last().fold_right(|x, acc : nat| (acc * x) as nat, 1) as int, seq.last() as int, k as int)}\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_nat(seq.drop_last(), seq.last() as nat) }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_fold_right_pull_out_hybrid(seq: Seq<u8>, k: nat)\n    ensures\n        seq.fold_right(|x, acc: nat| (acc * x) as nat, k) == (seq.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1,\n        ) * k) as nat,\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n    } else {\n        calc! {\n            (==)\n            seq.fold_right(|x, acc: nat| (acc * x) as nat, k); {\n                lemma_fold_right_pull_out_hybrid(seq.drop_last(), (k * seq.last()) as nat)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (k\n                * seq.last()) as nat) as nat; {\n                lemma_mul_is_commutative(k as int, seq.last() as int)\n            }\n            (seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * (seq.last()\n                * k) as nat) as nat; {\n                lemma_mul_is_associative(\n                    seq.drop_last().fold_right(|x: u8, acc: nat| (acc * x) as nat, 1nat) as int,\n                    seq.last() as int,\n                    k as int,\n                );\n            }\n            (((seq.drop_last().fold_right(|x, acc: nat| (acc * x) as nat, 1) * seq.last()) as nat)\n                * k) as nat; { lemma_fold_right_pull_out_hybrid(seq.drop_last(), seq.last() as nat)\n            }\n            (seq.fold_right(|x, acc: nat| (acc * x) as nat, 1) * k) as nat;\n        }\n    }\n}\n\nproof fn lemma_unfold_right_fold(factors: Seq<u8>, old_factors: Seq<u8>, k: u8, m: u8)\n    requires\n        old_factors.push(m) == factors,\n        k % m == 0,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k / m) as nat))\n            == old_factors.fold_right(|x, acc: nat| (acc * x) as nat, ((k as nat))),\n{\n    assert((old_factors.push(m)).drop_last() == old_factors);\n    assert(((k as int) / (m as int)) * (m as int) + (k as int) % (m as int) == (k as int)) by {\n        lemma_fundamental_div_mod(k as int, m as int)\n    };\n}\n\nproof fn lemma_unfold_right_fold_new(factors: Seq<u8>, old_factors: Seq<u8>, m: u8)\n    requires\n        old_factors.push(m as u8) == factors,\n        m != 0,\n    ensures\n        factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n            |x, acc: nat| (acc * x) as nat,\n            1nat,\n        ) * (m as nat),\n{\n    assert((old_factors.push(m as u8)).drop_last() == old_factors);\n    assert(factors.fold_right(|x, acc: nat| (acc * x) as nat, 1nat) == old_factors.fold_right(\n        |x, acc: nat| (acc * x) as nat,\n        1,\n    ) * (m as nat)) by { lemma_fold_right_pull_out_hybrid(old_factors, m as nat) }\n}\n\nproof fn lemma_multiple_mod_is_zero(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n    ensures\n        n % (k / m) == 0,\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n\n    assert(n == ((n / k) * m) * (k / m)) by {\n        broadcast use group_mul_properties;\n\n    };\n    assert(n % (k / m) == 0) by { lemma_mod_multiples_basic((n / k) * m, k / m) };\n}\n\nproof fn lemma_multiple_mod_is_zero_new(m: int, n: int, k: int)\n    requires\n        n % k == 0,\n        k % m == 0,\n        k > 0,\n        m > 0,\n        n > 0,\n    ensures\n        m * (n / k) == n / (k / m),\n{\n    assert(k == (k / m) * m) by { lemma_fundamental_div_mod(k, m) };\n    let a = choose|a: int| (#[trigger] (a * m) == k && (a == k / m));\n\n    assert(n == (n / k) * k) by { lemma_fundamental_div_mod(n, k) };\n    let b = choose|b: int| (#[trigger] (b * k) == n && b == n / k);\n\n    assert((a * m) * b == n) by { lemma_mul_is_commutative(b, a * m) }\n    assert(a * (m * b) == n) by { lemma_mul_is_associative(a, m, b) };\n    assert((m * b) == n / a) by { lemma_div_multiples_vanish(m * b, a) };\n}\n\nproof fn lemma_factor_mod_is_zero(k: int, m: int, j: int)\n    requires\n        k % j != 0,\n        k % m == 0,\n        1 <= j < m,\n    ensures\n        (k / m) % j != 0,\n{\n    assert_by_contradiction!((k/m) % j != 0,\n            { /* proof */\n                assert (k == (k/m) * m) by {lemma_fundamental_div_mod(k, m)};\n                let a = choose|a:int| (#[trigger] (a * m) == k);\n\n                assert ((k/m) == ((k/m)/j) * j) by {lemma_fundamental_div_mod(k/m, j)};\n                let b = choose|b:int| (#[trigger] (b * j) == k/m);\n\n                calc! {\n                    (==)\n                    k % j; {broadcast use group_mul_properties;}\n                    ((b * m) * j) % j; {broadcast use lemma_mod_multiples_basic;}\n                    0;\n                }\n            });\n\n}\n\nproof fn lemma_mod_zero_twice(k: int, m: int, i: int)\n    requires\n        k % m == 0,\n        m % i == 0,\n        m > 0,\n        i > 0,\n    ensures\n        k % i == 0,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// This spec function recursively computes the frequency of an element in a given sequence.\npub open spec fn count_frequency_spec(seq: Seq<i64>, key: i64) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_frequency_spec(seq.drop_last(), key) + if (seq.last() == key) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\n// This auxilary exe function computes the frequency of an element in a given sequence\nfn count_frequency(elements: &Vec<i64>, key: i64) -> (frequency: usize)\n    ensures\n        count_frequency_spec(elements@, key) == frequency,\n{\n    let ghost elements_length = elements.len();\n    let mut counter = 0;\n    let mut index = 0;\n    while index < elements.len()\n        invariant\n            0 <= index <= elements.len(),\n            0 <= counter <= index,\n            count_frequency_spec(elements@.subrange(0, index as int), key) == counter,\n    {\n        if (elements[index] == key) {\n            counter += 1;\n        }\n        index += 1;\n        assert(elements@.subrange(0, index - 1 as int) == elements@.subrange(\n            0,\n            index as int,\n        ).drop_last());\n    }\n    assert(elements@ == elements@.subrange(0, elements_length as int));\n    counter\n}\n\n//This function removes all elements that occur more than once\n// Implementation following the ground-truth\nfn remove_duplicates(numbers: &Vec<i64>) -> (unique_numbers: Vec<i64>)\n    ensures\n        unique_numbers@ == numbers@.filter(|x: i64| count_frequency_spec(numbers@, x) == 1),\n{\n    let ghost numbers_length = numbers.len();\n    let mut unique_numbers: Vec<i64> = Vec::new();\n    assert(numbers@.take(0int).filter(|x: i64| count_frequency_spec(numbers@, x) == 1) == Seq::<\n        i64,\n    >::empty());\n\n    for index in 0..numbers.len()\n        invariant\n            0 <= index <= numbers.len(),\n            unique_numbers@ == numbers@.take(index as int).filter(\n                |x: i64| count_frequency_spec(numbers@, x) == 1,\n            ),\n    {\n        if count_frequency(&numbers, numbers[index]) == 1 {\n            unique_numbers.push(numbers[index]);\n        }\n        assert(numbers@.take((index + 1) as int).drop_last() == numbers@.take(index as int));\n        reveal(Seq::filter);\n    }\n    assert(numbers@ == numbers@.take(numbers_length as int));\n    unique_numbers\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// This spec function recursively computes the frequency of an element in a given sequence.\npub open spec fn count_frequency_spec(seq: Seq<i64>, key: i64) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_frequency_spec(seq.drop_last(), key) + if (seq.last() == key) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\n// This auxilary exe function computes the frequency of an element in a given sequence\nfn count_frequency(elements: &Vec<i64>, key: i64) -> (frequency: usize)\n    ensures\n        count_frequency_spec(elements@, key) == frequency,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// This spec function recursively computes the frequency of an element in a given sequence.\npub open spec fn count_frequency_spec(seq: Seq<i64>, key: i64) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_frequency_spec(seq.drop_last(), key) + if (seq.last() == key) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\n// This auxilary exe function computes the frequency of an element in a given sequence\nfn count_frequency(elements: &Vec<i64>, key: i64) -> (frequency: usize)\n    ensures\n        count_frequency_spec(elements@, key) == frequency,\n{\n    let ghost elements_length = elements.len();\n    let mut counter = 0;\n    let mut index = 0;\n    while index < elements.len()\n        invariant\n            0 <= index <= elements.len(),\n            0 <= counter <= index,\n            count_frequency_spec(elements@.subrange(0, index as int), key) == counter,\n    {\n        if (elements[index] == key) {\n            counter += 1;\n        }\n        index += 1;\n        assert(elements@.subrange(0, index - 1 as int) == elements@.subrange(\n            0,\n            index as int,\n        ).drop_last());\n    }\n    assert(elements@ == elements@.subrange(0, elements_length as int));\n    counter\n}\n\n//This function removes all elements that occur more than once\n// Implementation following the ground-truth\nfn remove_duplicates(numbers: &Vec<i64>) -> (unique_numbers: Vec<i64>)\n    ensures\n        unique_numbers@ == numbers@.filter(|x: i64| count_frequency_spec(numbers@, x) == 1),\n{\n    let ghost numbers_length = numbers.len();\n    let mut unique_numbers: Vec<i64> = Vec::new();\n    assert(numbers@.take(0int).filter(|x: i64| count_frequency_spec(numbers@, x) == 1) == Seq::<\n        i64,\n    >::empty());\n\n    for index in 0..numbers.len()\n        invariant\n            0 <= index <= numbers.len(),\n            unique_numbers@ == numbers@.take(index as int).filter(\n                |x: i64| count_frequency_spec(numbers@, x) == 1,\n            ),\n    {\n        if count_frequency(&numbers, numbers[index]) == 1 {\n            unique_numbers.push(numbers[index]);\n        }\n        assert(numbers@.take((index + 1) as int).drop_last() == numbers@.take(index as int));\n        reveal(Seq::filter);\n    }\n    assert(numbers@ == numbers@.take(numbers_length as int));\n    unique_numbers\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// This spec function recursively computes the frequency of an element in a given sequence.\npub open spec fn count_frequency_spec(seq: Seq<i64>, key: i64) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_frequency_spec(seq.drop_last(), key) + if (seq.last() == key) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\n// This auxilary exe function computes the frequency of an element in a given sequence\nfn count_frequency(elements: &Vec<i64>, key: i64) -> (frequency: usize)\n    ensures\n        count_frequency_spec(elements@, key) == frequency,\n{\n    let ghost elements_length = elements.len();\n    let mut counter = 0;\n    let mut index = 0;\n    while index < elements.len()\n        invariant\n            0 <= index <= elements.len(),\n            0 <= counter <= index,\n            count_frequency_spec(elements@.subrange(0, index as int), key) == counter,\n    {\n        if (elements[index] == key) {\n            counter += 1;\n        }\n        index += 1;\n        assert(elements@.subrange(0, index - 1 as int) == elements@.subrange(\n            0,\n            index as int,\n        ).drop_last());\n    }\n    assert(elements@ == elements@.subrange(0, elements_length as int));\n    counter\n}\n\n//This function removes all elements that occur more than once\n// Implementation following the ground-truth\nfn remove_duplicates(numbers: &Vec<i64>) -> (unique_numbers: Vec<i64>)\n    ensures\n        unique_numbers@ == numbers@.filter(|x: i64| count_frequency_spec(numbers@, x) == 1),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_upper_case(c: char) -> bool {\n    c >= 'A' && c <= 'Z'\n}\n\npub open spec fn is_lower_case(c: char) -> bool {\n    c >= 'a' && c <= 'z'\n}\n\npub open spec fn shift_plus_32_spec(c: char) -> char {\n    ((c as u8) + 32) as char\n}\n\npub open spec fn shift_minus_32_spec(c: char) -> char {\n    ((c as u8) - 32) as char\n}\n\n// This spec function tranforms a lowercase character to uppercase and vice-versa\npub open spec fn flip_case_spec(c: char) -> char {\n    if is_lower_case(c) {\n        shift_minus_32_spec(c)\n    } else if is_upper_case(c) {\n        shift_plus_32_spec(c)\n    } else {\n        c\n    }\n}\n\n// Implementation following the ground-truth (i.e, swapcase())\nfn flip_case(str: &[char]) -> (flipped_case: Vec<char>)\n    ensures\n        str@.len() == flipped_case@.len(),\n        forall|i: int| 0 <= i < str.len() ==> flipped_case[i] == flip_case_spec(#[trigger] str[i]),\n{\n    let mut flipped_case = Vec::with_capacity(str.len());\n\n    for index in 0..str.len()\n        invariant\n            0 <= index <= str.len(),\n            flipped_case.len() == index,\n            forall|i: int| 0 <= i < index ==> flipped_case[i] == flip_case_spec(#[trigger] str[i]),\n    {\n        if (str[index] >= 'a' && str[index] <= 'z') {\n            flipped_case.push(((str[index] as u8) - 32) as char);\n        } else if (str[index] >= 'A' && str[index] <= 'Z') {\n            flipped_case.push(((str[index] as u8) + 32) as char);\n        } else {\n            flipped_case.push(str[index]);\n        }\n        assert(flipped_case[index as int] == flip_case_spec(str[index as int]));\n    }\n    flipped_case\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_upper_case(c: char) -> bool {\n    c >= 'A' && c <= 'Z'\n}\n\npub open spec fn is_lower_case(c: char) -> bool {\n    c >= 'a' && c <= 'z'\n}\n\npub open spec fn shift_plus_32_spec(c: char) -> char {\n    ((c as u8) + 32) as char\n}\n\npub open spec fn shift_minus_32_spec(c: char) -> char {\n    ((c as u8) - 32) as char\n}\n\n// This spec function tranforms a lowercase character to uppercase and vice-versa\npub open spec fn flip_case_spec(c: char) -> char {\n    if is_lower_case(c) {\n        shift_minus_32_spec(c)\n    } else if is_upper_case(c) {\n        shift_plus_32_spec(c)\n    } else {\n        c\n    }\n}\n\n// Implementation following the ground-truth (i.e, swapcase())\nfn flip_case(str: &[char]) -> (flipped_case: Vec<char>)\n    ensures\n        str@.len() == flipped_case@.len(),\n        forall|i: int| 0 <= i < str.len() ==> flipped_case[i] == flip_case_spec(#[trigger] str[i]),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\npub closed spec fn concat_helper(strings: Seq<Seq<char>>, i: nat) -> Seq<char>\n    recommends\n        i <= strings.len(),\n    decreases strings.len() - i,\n{\n    if (i >= strings.len()) {\n        seq![]\n    } else {\n        strings[i as int] + concat_helper(strings, i + 1)\n    }\n}\n\npub open spec fn concatenate(strings: Seq<Seq<char>>) -> Seq<char> {\n    concat_helper(strings, 0)\n}\n\nproof fn sanity_check() {\n    assert(concatenate(seq![seq!['a'], seq!['b'], seq!['c']]) == seq!['a', 'b', 'c']) by (compute);\n    assert(concatenate(Seq::empty()) == Seq::<char>::empty());\n    assert(concatenate(seq![seq!['a', 'z'], seq!['b'], seq!['c', 'y']]) == seq![\n        'a',\n        'z',\n        'b',\n        'c',\n        'y',\n    ]) by (compute);\n}\n\nfn concatenate_impl(strings: Vec<Vec<char>>) -> (joined: Vec<char>)\n    ensures\n        joined@ == concatenate(strings.deep_view()),\n{\n    let mut i = 0;\n    let mut joined = vec![];\n\n    while (i < strings.len())\n        invariant\n            0 <= i <= strings.len(),\n            concatenate(strings.deep_view()) == joined@ + concat_helper(\n                strings.deep_view(),\n                i as nat,\n            ),\n    {\n        assert(concatenate(strings.deep_view()) == joined@ + strings[i as int]@ + concat_helper(\n            strings.deep_view(),\n            (i + 1) as nat,\n        ));\n\n        let mut copy_str = strings[i].clone();\n        joined.append(&mut copy_str);\n        i = i + 1;\n    }\n    return joined;\n}\n\n} // verus!\nfn main() {\n    let test1 = vec![vec!['a'], vec!['b'], vec!['c']];\n    let test2: Vec<Vec<char>> = Vec::new();\n    let test3 = vec![vec!['a', 'z'], vec!['b'], vec!['c', 'y']];\n\n    print!(\"concatenation of {:?}:\\n\", test1);\n    print!(\"{:?}\\n\", concatenate_impl(test1));\n    print!(\"concatenation of {:?}:\\n\", test2);\n    print!(\"{:?}\\n\", concatenate_impl(test2));\n    print!(\"concatenation of {:?}:\\n\", test3);\n    print!(\"{:?}\\n\", concatenate_impl(test3));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\nfrom typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nconcatenate\n*/\n\n/*\n### CANONICAL SOLUTION\n    return ''.join(strings)\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\npub closed spec fn concat_helper(strings: Seq<Seq<char>>, i: nat) -> Seq<char>\n    recommends\n        i <= strings.len(),\n    decreases strings.len() - i,\n{\n    if (i >= strings.len()) {\n        seq![]\n    } else {\n        strings[i as int] + concat_helper(strings, i + 1)\n    }\n}\n\npub open spec fn concatenate(strings: Seq<Seq<char>>) -> Seq<char> {\n    concat_helper(strings, 0)\n}\n\nproof fn sanity_check() {\n    assert(concatenate(seq![seq!['a'], seq!['b'], seq!['c']]) == seq!['a', 'b', 'c']) by (compute);\n    assert(concatenate(Seq::empty()) == Seq::<char>::empty());\n    assert(concatenate(seq![seq!['a', 'z'], seq!['b'], seq!['c', 'y']]) == seq![\n        'a',\n        'z',\n        'b',\n        'c',\n        'y',\n    ]) by (compute);\n}\n\nfn concatenate_impl(strings: Vec<Vec<char>>) -> (joined: Vec<char>)\n    ensures\n        joined@ == concatenate(strings.deep_view()),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\npub closed spec fn concat_helper(strings: Seq<Seq<char>>, i: nat) -> Seq<char>\n    recommends\n        i <= strings.len(),\n    decreases strings.len() - i,\n{\n    if (i >= strings.len()) {\n        seq![]\n    } else {\n        strings[i as int] + concat_helper(strings, i + 1)\n    }\n}\n\npub open spec fn concatenate(strings: Seq<Seq<char>>) -> Seq<char> {\n    concat_helper(strings, 0)\n}\n\nproof fn sanity_check() {\n    assert(concatenate(seq![seq!['a'], seq!['b'], seq!['c']]) == seq!['a', 'b', 'c']) by (compute);\n    assert(concatenate(Seq::empty()) == Seq::<char>::empty());\n    assert(concatenate(seq![seq!['a', 'z'], seq!['b'], seq!['c', 'y']]) == seq![\n        'a',\n        'z',\n        'b',\n        'c',\n        'y',\n    ]) by (compute);\n}\n\nfn concatenate_impl(strings: Vec<Vec<char>>) -> (joined: Vec<char>)\n    ensures\n        joined@ == concatenate(strings.deep_view()),\n{\n    let mut i = 0;\n    let mut joined = vec![];\n\n    while (i < strings.len())\n        invariant\n            0 <= i <= strings.len(),\n            concatenate(strings.deep_view()) == joined@ + concat_helper(\n                strings.deep_view(),\n                i as nat,\n            ),\n    {\n        assert(concatenate(strings.deep_view()) == joined@ + strings[i as int]@ + concat_helper(\n            strings.deep_view(),\n            (i + 1) as nat,\n        ));\n\n        let mut copy_str = strings[i].clone();\n        joined.append(&mut copy_str);\n        i = i + 1;\n    }\n    return joined;\n}\n\n} // verus!\nfn main() {\n    let test1 = vec![vec!['a'], vec!['b'], vec!['c']];\n    let test2: Vec<Vec<char>> = Vec::new();\n    let test3 = vec![vec!['a', 'z'], vec!['b'], vec!['c', 'y']];\n\n    print!(\"concatenation of {:?}:\\n\", test1);\n    print!(\"{:?}\\n\", concatenate_impl(test1));\n    print!(\"concatenation of {:?}:\\n\", test2);\n    print!(\"{:?}\\n\", concatenate_impl(test2));\n    print!(\"concatenation of {:?}:\\n\", test3);\n    print!(\"{:?}\\n\", concatenate_impl(test3));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\nfrom typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nconcatenate\n*/\n\n/*\n### CANONICAL SOLUTION\n    return ''.join(strings)\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\npub closed spec fn concat_helper(strings: Seq<Seq<char>>, i: nat) -> Seq<char>\n    recommends\n        i <= strings.len(),\n    decreases strings.len() - i,\n{\n    if (i >= strings.len()) {\n        seq![]\n    } else {\n        strings[i as int] + concat_helper(strings, i + 1)\n    }\n}\n\npub open spec fn concatenate(strings: Seq<Seq<char>>) -> Seq<char> {\n    concat_helper(strings, 0)\n}\n\nproof fn sanity_check() {\n    assert(concatenate(seq![seq!['a'], seq!['b'], seq!['c']]) == seq!['a', 'b', 'c']) by (compute);\n    assert(concatenate(Seq::empty()) == Seq::<char>::empty());\n    assert(concatenate(seq![seq!['a', 'z'], seq!['b'], seq!['c', 'y']]) == seq![\n        'a',\n        'z',\n        'b',\n        'c',\n        'y',\n    ]) by (compute);\n}\n\nfn concatenate_impl(strings: Vec<Vec<char>>) -> (joined: Vec<char>)\n    ensures\n        joined@ == concatenate(strings.deep_view()),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\npub closed spec fn concat_helper(strings: Seq<Seq<char>>, i: nat) -> Seq<char>\n    recommends\n        i <= strings.len(),\n    decreases strings.len() - i,\n{\n    if (i >= strings.len()) {\n        seq![]\n    } else {\n        strings[i as int] + concat_helper(strings, i + 1)\n    }\n}\n\npub open spec fn concatenate(strings: Seq<Seq<char>>) -> Seq<char> {\n    concat_helper(strings, 0)\n}\n\nproof fn sanity_check() {\n    assert(concatenate(seq![seq!['a'], seq!['b'], seq!['c']]) == seq!['a', 'b', 'c']) by (compute);\n    assert(concatenate(Seq::empty()) == Seq::<char>::empty());\n    assert(concatenate(seq![seq!['a', 'z'], seq!['b'], seq!['c', 'y']]) == seq![\n        'a',\n        'z',\n        'b',\n        'c',\n        'y',\n    ]) by (compute);\n}\n\nfn concatenate_impl(strings: Vec<Vec<char>>) -> (joined: Vec<char>)\n    ensures\n        joined@ == concatenate(strings.deep_view()),\n{\n    let mut i = 0;\n    let mut joined = vec![];\n\n    while (i < strings.len())\n        invariant\n            0 <= i <= strings.len(),\n            concatenate(strings.deep_view()) == joined@ + concat_helper(\n                strings.deep_view(),\n                i as nat,\n            ),\n    {\n        assert(concatenate(strings.deep_view()) == joined@ + strings[i as int]@ + concat_helper(\n            strings.deep_view(),\n            (i + 1) as nat,\n        ));\n\n        let mut copy_str = strings[i].clone();\n        joined.append(&mut copy_str);\n        i = i + 1;\n    }\n    return joined;\n}\n\n} // verus!\nfn main() {\n    let test1 = vec![vec!['a'], vec!['b'], vec!['c']];\n    let test2: Vec<Vec<char>> = Vec::new();\n    let test3 = vec![vec!['a', 'z'], vec!['b'], vec!['c', 'y']];\n\n    print!(\"concatenation of {:?}:\\n\", test1);\n    print!(\"{:?}\\n\", concatenate_impl(test1));\n    print!(\"concatenation of {:?}:\\n\", test2);\n    print!(\"{:?}\\n\", concatenate_impl(test2));\n    print!(\"concatenation of {:?}:\\n\", test3);\n    print!(\"{:?}\\n\", concatenate_impl(test3));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\nfrom typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nconcatenate\n*/\n\n/*\n### CANONICAL SOLUTION\n    return ''.join(strings)\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\npub closed spec fn concat_helper(strings: Seq<Seq<char>>, i: nat) -> Seq<char>\n    recommends\n        i <= strings.len(),\n    decreases strings.len() - i,\n{\n    if (i >= strings.len()) {\n        seq![]\n    } else {\n        strings[i as int] + concat_helper(strings, i + 1)\n    }\n}\n\npub open spec fn concatenate(strings: Seq<Seq<char>>) -> Seq<char> {\n    concat_helper(strings, 0)\n}\n\nproof fn sanity_check() {\n    assert(concatenate(seq![seq!['a'], seq!['b'], seq!['c']]) == seq!['a', 'b', 'c']) by (compute);\n    assert(concatenate(Seq::empty()) == Seq::<char>::empty());\n    assert(concatenate(seq![seq!['a', 'z'], seq!['b'], seq!['c', 'y']]) == seq![\n        'a',\n        'z',\n        'b',\n        'c',\n        'y',\n    ]) by (compute);\n}\n\nfn concatenate_impl(strings: Vec<Vec<char>>) -> (joined: Vec<char>)\n    ensures\n        joined@ == concatenate(strings.deep_view()),\n{\n    let mut i = 0;\n    let mut joined = vec![];\n\n    while (i < strings.len())\n        invariant\n            0 <= i <= strings.len(),\n            concatenate(strings.deep_view()) == joined@ + concat_helper(\n                strings.deep_view(),\n                i as nat,\n            ),\n    {\n        assert(concatenate(strings.deep_view()) == joined@ + strings[i as int]@ + concat_helper(\n            strings.deep_view(),\n            (i + 1) as nat,\n        ));\n\n        let mut copy_str = strings[i].clone();\n        joined.append(&mut copy_str);\n        i = i + 1;\n    }\n    return joined;\n}\n\n} // verus!\nf"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn get_positive(input: Vec<i32>) -> (positive_list: Vec<i32>)\n    ensures\n        positive_list@ == input@.filter(|x: i32| x > 0),\n{\n    let mut positive_list = Vec::<i32>::new();\n    let input_len = input.len();\n    assert(input@.take(0int).filter(|x: i32| x > 0) == Seq::<i32>::empty());\n    for pos in 0..input_len\n        invariant\n            input_len == input.len(),\n            positive_list@ == input@.take(pos as int).filter(|x: i32| x > 0),\n    {\n        let n = input[pos];\n        if n > 0 {\n            positive_list.push(n);\n        }\n        assert(input@.take((pos + 1) as int).drop_last() == input@.take(pos as int));\n        reveal(Seq::filter);\n    }\n    assert(input@ == input@.take(input_len as int));\n    positive_list\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn get_positive(input: Vec<i32>) -> (positive_list: Vec<i32>)\n    ensures\n        positive_list@ == input@.filter(|x: i32| x > 0),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub open spec fn is_prime(n: nat) -> bool {\n    (n > 1) && forall|i| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\npub closed spec fn is_prime_so_far(n: nat, k: nat) -> bool\n    recommends\n        n >= k > 1,\n{\n    forall|i| 1 < i < k ==> #[trigger] (n % i) != 0\n}\n\n// Verus does not yet support quantifiers when using proof-by-compute\n// proof fn sanity_check() {\n//     assert(is_prime(6) == false) by (compute);\n//     assert(is_prime(101) == true) by (compute);\n//     assert(is_prime(11) == true) by (compute);\n//     assert(is_prime(13441) == true) by (compute);\n//     assert(is_prime(61) == true) by (compute);\n//     assert(is_prime(4) == false) by (compute);\n//     assert(is_prime(1) == false) by (compute);\n// }\n// implementation\nfn is_prime_impl(n: u8) -> (res: bool)\n    ensures\n        res == is_prime(n as nat),\n{\n    if n < 2 {\n        return false;\n    }\n    let mut k = 2;\n    let mut res = true;\n\n    while (k < n)\n        invariant\n            2 <= k <= n,\n            res == is_prime_so_far(n as nat, k as nat),\n    {\n        assert((is_prime_so_far(n as nat, k as nat) && (n as nat) % (k as nat) != 0)\n            == is_prime_so_far(n as nat, (k + 1) as nat));\n\n        res = res && n % k != 0;\n        k = k + 1;\n    }\n    return res;\n}\n\n} // verus!\nfn main() {\n    print!(\"6 is prime? {}\\n\", is_prime_impl(6));\n    print!(\"101 is prime? {}\\n\", is_prime_impl(101));\n    print!(\"11 is prime? {}\\n\", is_prime_impl(11));\n    print!(\"61 is prime? {}\\n\", is_prime_impl(61));\n    print!(\"4 is prime? {}\\n\", is_prime_impl(4));\n    print!(\"1 is prime? {}\\n\", is_prime_impl(1));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\n\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nis_prime\n*/\n\n/*\n### CANONICAL SOLUTION\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub open spec fn is_prime(n: nat) -> bool {\n    (n > 1) && forall|i| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\npub closed spec fn is_prime_so_far(n: nat, k: nat) -> bool\n    recommends\n        n >= k > 1,\n{\n    forall|i| 1 < i < k ==> #[trigger] (n % i) != 0\n}\n\n// Verus does not yet support quantifiers when using proof-by-compute\n// proof fn sanity_check() {\n//     assert(is_prime(6) == false) by (compute);\n//     assert(is_prime(101) == true) by (compute);\n//     assert(is_prime(11) == true) by (compute);\n//     assert(is_prime(13441) == true) by (compute);\n//     assert(is_prime(61) == true) by (compute);\n//     assert(is_prime(4) == false) by (compute);\n//     assert(is_prime(1) == false) by (compute);\n// }\n// implementation\nfn is_prime_impl(n: u8) -> (res: bool)\n    ensures\n        res == is_prime(n as nat),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub open spec fn is_prime(n: nat) -> bool {\n    (n > 1) && forall|i| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\npub closed spec fn is_prime_so_far(n: nat, k: nat) -> bool\n    recommends\n        n >= k > 1,\n{\n    forall|i| 1 < i < k ==> #[trigger] (n % i) != 0\n}\n\n// Verus does not yet support quantifiers when using proof-by-compute\n// proof fn sanity_check() {\n//     assert(is_prime(6) == false) by (compute);\n//     assert(is_prime(101) == true) by (compute);\n//     assert(is_prime(11) == true) by (compute);\n//     assert(is_prime(13441) == true) by (compute);\n//     assert(is_prime(61) == true) by (compute);\n//     assert(is_prime(4) == false) by (compute);\n//     assert(is_prime(1) == false) by (compute);\n// }\n// implementation\nfn is_prime_impl(n: u8) -> (res: bool)\n    ensures\n        res == is_prime(n as nat),\n{\n    if n < 2 {\n        return false;\n    }\n    let mut k = 2;\n    let mut res = true;\n\n    while (k < n)\n        invariant\n            2 <= k <= n,\n            res == is_prime_so_far(n as nat, k as nat),\n    {\n        assert((is_prime_so_far(n as nat, k as nat) && (n as nat) % (k as nat) != 0)\n            == is_prime_so_far(n as nat, (k + 1) as nat));\n\n        res = res && n % k != 0;\n        k = k + 1;\n    }\n    return res;\n}\n\n} // verus!\nfn main() {\n    print!(\"6 is prime? {}\\n\", is_prime_impl(6));\n    print!(\"101 is prime? {}\\n\", is_prime_impl(101));\n    print!(\"11 is prime? {}\\n\", is_prime_impl(11));\n    print!(\"61 is prime? {}\\n\", is_prime_impl(61));\n    print!(\"4 is prime? {}\\n\", is_prime_impl(4));\n    print!(\"1 is prime? {}\\n\", is_prime_impl(1));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\n\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nis_prime\n*/\n\n/*\n### CANONICAL SOLUTION\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub open spec fn is_prime(n: nat) -> bool {\n    (n > 1) && forall|i| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\npub closed spec fn is_prime_so_far(n: nat, k: nat) -> bool\n    recommends\n        n >= k > 1,\n{\n    forall|i| 1 < i < k ==> #[trigger] (n % i) != 0\n}\n\n// Verus does not yet support quantifiers when using proof-by-compute\n// proof fn sanity_check() {\n//     assert(is_prime(6) == false) by (compute);\n//     assert(is_prime(101) == true) by (compute);\n//     assert(is_prime(11) == true) by (compute);\n//     assert(is_prime(13441) == true) by (compute);\n//     assert(is_prime(61) == true) by (compute);\n//     assert(is_prime(4) == false) by (compute);\n//     assert(is_prime(1) == false) by (compute);\n// }\n// implementation\nfn is_prime_impl(n: u8) -> (res: bool)\n    ensures\n        res == is_prime(n as nat),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub open spec fn is_prime(n: nat) -> bool {\n    (n > 1) && forall|i| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\npub closed spec fn is_prime_so_far(n: nat, k: nat) -> bool\n    recommends\n        n >= k > 1,\n{\n    forall|i| 1 < i < k ==> #[trigger] (n % i) != 0\n}\n\n// Verus does not yet support quantifiers when using proof-by-compute\n// proof fn sanity_check() {\n//     assert(is_prime(6) == false) by (compute);\n//     assert(is_prime(101) == true) by (compute);\n//     assert(is_prime(11) == true) by (compute);\n//     assert(is_prime(13441) == true) by (compute);\n//     assert(is_prime(61) == true) by (compute);\n//     assert(is_prime(4) == false) by (compute);\n//     assert(is_prime(1) == false) by (compute);\n// }\n// implementation\nfn is_prime_impl(n: u8) -> (res: bool)\n    ensures\n        res == is_prime(n as nat),\n{\n    if n < 2 {\n        return false;\n    }\n    let mut k = 2;\n    let mut res = true;\n\n    while (k < n)\n        invariant\n            2 <= k <= n,\n            res == is_prime_so_far(n as nat, k as nat),\n    {\n        assert((is_prime_so_far(n as nat, k as nat) && (n as nat) % (k as nat) != 0)\n            == is_prime_so_far(n as nat, (k + 1) as nat));\n\n        res = res && n % k != 0;\n        k = k + 1;\n    }\n    return res;\n}\n\n} // verus!\nfn main() {\n    print!(\"6 is prime? {}\\n\", is_prime_impl(6));\n    print!(\"101 is prime? {}\\n\", is_prime_impl(101));\n    print!(\"11 is prime? {}\\n\", is_prime_impl(11));\n    print!(\"61 is prime? {}\\n\", is_prime_impl(61));\n    print!(\"4 is prime? {}\\n\", is_prime_impl(4));\n    print!(\"1 is prime? {}\\n\", is_prime_impl(1));\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\n\ndef is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nis_prime\n*/\n\n/*\n### CANONICAL SOLUTION\n    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n\n*/\n\n/*\n### TEST\n\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n\n*/", "x": "use vstd::prelude::*;\n\nverus! {\n\n// specification\npub open spec fn is_prime(n: nat) -> bool {\n    (n > 1) && forall|i| 1 < i < n ==> #[trigger] (n % i) != 0\n}\n\npub closed spec fn is_prime_so_far(n: nat, k: nat) -> bool\n    recommends\n        n >= k > 1,\n{\n    forall|i| 1 < i < k ==> #[trigger] (n % i) != 0\n}\n\n// Verus does not yet support quantifiers when using proof-by-compute\n// proof fn sanity_check() {\n//     assert(is_prime(6) == false) by (compute);\n//     assert(is_prime(101) == true) by (compute);\n//     assert(is_prime(11) == true) by (compute);\n//     assert(is_prime(13441) == true) by (compute);\n//     assert(is_prime(61) == true) by (compute);\n//     assert(is_prime(4) == false) by (compute);\n//     assert(is_prime(1) == false) by (compute);\n// }\n// implementation\nfn is_prime_impl(n: u8) -> (res: bool)\n    ensures\n        res == is_prime(n as nat),\n{\n    if n < 2 {\n        return false;\n    }\n    let mut k = 2;\n    let mut res = true;\n\n    while (k < n)\n        invariant\n            2 <= k <= n,\n            res == is_prime_so_far(n as nat, k as nat),\n    {\n        assert((is_prime_so_far(n as nat, k as nat) && (n as nat) % (k as nat) != 0)\n            == is_prime_so_far(n as nat, (k + 1) as nat));\n\n        res = res && n % k != 0;\n        k = k + 1;\n    }\n    return res;\n}\n\n} // verus!\nf"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// This function counts the number of elements of `s` that are equal to `x`.\nspec fn count<T>(s: Seq<T>, x: T) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        count(s.skip(1), x) + if s[0] == x {\n            1int\n        } else {\n            0int\n        }\n    }\n}\n\n// This function defines what it means for two sequences to be\n// permutations of each other: for every value `x`, each of the two\n// sequences has the same number of instances of `x`.\nspec fn permutes<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    forall|x: T| count(s1, x) == count(s2, x)\n}\n\n// This lemma establishes the effect of an `update` operation on the\n// result of a `count`. That is, it gives a closed-form\n// (non-recursive) description of what happens to `count(s, x)` when\n// `s` is updated to `s.update(i, v)`.\nproof fn lemma_update_effect_on_count<T>(s: Seq<T>, i: int, v: T, x: T)\n    requires\n        0 <= i < s.len(),\n    ensures\n        count(s.update(i, v), x) == if v == x && s[i] != x {\n            count(s, x) + 1\n        } else if v != x && s[i] == x {\n            count(s, x) - 1\n        } else {\n            count(s, x)\n        },\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        return ;\n    }\n    if i == 0 {\n        assert(s.update(i, v) =~= seq![v] + s.skip(1));\n        assert(s.update(i, v).skip(1) =~= s.skip(1));\n    } else {\n        assert(s.update(i, v) =~= seq![s[0]] + s.skip(1).update(i - 1, v));\n        assert(s.update(i, v).skip(1) =~= s.skip(1).update(i - 1, v));\n        lemma_update_effect_on_count(s.skip(1), i - 1, v, x);\n    }\n}\n\n// This lemma proves that if you swap elements `i` and `j` of sequence `s`,\n// you get a permutation of `s`.\nproof fn lemma_swapping_produces_a_permutation<T>(s: Seq<T>, i: int, j: int)\n    requires\n        0 <= i < s.len(),\n        0 <= j < s.len(),\n    ensures\n        permutes(s.update(i, s[j]).update(j, s[i]), s),\n{\n    assert forall|x: T| #[trigger] count(s.update(i, s[j]).update(j, s[i]), x) == count(s, x) by {\n        lemma_update_effect_on_count(s, i, s[j], x);\n        lemma_update_effect_on_count(s.update(i, s[j]), j, s[i], x);\n    }\n}\n\n// This is the function we were asked to write.\nfn sort_third(l: Vec<i32>) -> (l_prime: Vec<i32>)\n    ensures\n        l_prime.len() == l.len(),\n        forall|i: int| 0 <= i < l.len() && i % 3 != 0 ==> l_prime[i] == l[i],  // unchanged if index not divisible by three\n        forall|i: int, j: int|\n            0 <= i < j < l.len() && i % 3 == 0 && j % 3 == 0 ==> l_prime[i] <= l_prime[j],\n        // indexes divisible by three are ordered\n        permutes(l_prime@, l@),  // new vec is a permutation of old vec\n{\n    let ghost old_l = l@;\n    let l_len = l.len();\n    let mut pos_being_set_to_smallest: usize = 0;\n    let mut l_prime: Vec<i32> = l;\n    // Iterate `pos_being_set_to_smallest` by 3 from 0 to `l_len`. Each time,\n    // look for the smallest element at a position divisible by three in the\n    // part of the vector at or past `pos_being_set_to_smallest`. Swap that\n    // element with the one at `pos_being_set_to_smallest`.\n    while pos_being_set_to_smallest < l_len\n        invariant\n            l_len == l.len() == l_prime.len(),\n            pos_being_set_to_smallest % 3 == 0,\n            forall|i: int| 0 <= i < l_len && i % 3 != 0 ==> l_prime[i] == l[i],\n            permutes(l_prime@, l@),\n            forall|i: int, j: int|\n                0 <= i < pos_being_set_to_smallest && i < j < l_len && i % 3 == 0 && j % 3 == 0\n                    ==> l_prime[i] <= l_prime[j],\n    {\n        // Iterate `pos_during_scan_for_smallest` by 3 from `pos_being_set_to_smallest`\n        // to `l_len`. Keep track of the position of the smallest element found so far\n        // in `pos_of_smallest_found_so_far`.\n        let mut pos_of_smallest_found_so_far: usize = pos_being_set_to_smallest;\n        let mut pos_during_scan_for_smallest: usize = pos_being_set_to_smallest;\n        while pos_during_scan_for_smallest < l_len\n            invariant\n                l_len == l.len() == l_prime.len(),\n                pos_being_set_to_smallest % 3 == 0,\n                pos_during_scan_for_smallest % 3 == 0,\n                pos_of_smallest_found_so_far % 3 == 0,\n                pos_being_set_to_smallest <= pos_during_scan_for_smallest,\n                pos_being_set_to_smallest <= pos_of_smallest_found_so_far < l_len,\n                forall|i: int| 0 <= i < l_len && i % 3 != 0 ==> l_prime[i] == l[i],\n                permutes(l_prime@, l@),\n                forall|i: int|\n                    pos_being_set_to_smallest <= i < pos_during_scan_for_smallest && i % 3 == 0\n                        ==> l_prime[pos_of_smallest_found_so_far as int] <= l_prime[i],\n                forall|i: int, j: int|\n                    0 <= i < pos_being_set_to_smallest && i < j < l_len && i % 3 == 0 && j % 3 == 0\n                        ==> l_prime[i] <= l_prime[j],\n        {\n            if l_prime[pos_during_scan_for_smallest] < l_prime[pos_of_smallest_found_so_far] {\n                pos_of_smallest_found_so_far = pos_during_scan_for_smallest;\n            }\n            pos_during_scan_for_smallest = pos_during_scan_for_smallest + 3;\n        }\n        // Invoke a lemma to show that swapping two elements, as we're\n        // about to do, doesn't change the count of each element.\n\n        proof {\n            lemma_swapping_produces_a_permutation(\n                l_prime@,\n                pos_being_set_to_smallest as int,\n                pos_of_smallest_found_so_far as int,\n            );\n        }\n        // Swap the elements at positions `pos_being_set_to_smallest`\n        // and `pos_of_smallest_found_so_far`.\n        let v1 = l_prime[pos_being_set_to_smallest];\n        let v2 = l_prime[pos_of_smallest_found_so_far];\n        l_prime.set(pos_being_set_to_smallest, v2);\n        l_prime.set(pos_of_smallest_found_so_far, v1);\n        pos_being_set_to_smallest = pos_being_set_to_smallest + 3;\n    }\n    l_prime\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// This function counts the number of elements of `s` that are equal to `x`.\nspec fn count<T>(s: Seq<T>, x: T) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        count(s.skip(1), x) + if s[0] == x {\n            1int\n        } else {\n            0int\n        }\n    }\n}\n\n// This function defines what it means for two sequences to be\n// permutations of each other: for every value `x`, each of the two\n// sequences has the same number of instances of `x`.\nspec fn permutes<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    forall|x: T| count(s1, x) == count(s2, x)\n}\n\n// This lemma establishes the effect of an `update` operation on the\n// result of a `count`. That is, it gives a closed-form\n// (non-recursive) description of what happens to `count(s, x)` when\n// `s` is updated to `s.update(i, v)`.\nproof fn lemma_update_effect_on_count<T>(s: Seq<T>, i: int, v: T, x: T)\n    requires\n        0 <= i < s.len(),\n    ensures\n        count(s.update(i, v), x) == if v == x && s[i] != x {\n            count(s, x) + 1\n        } else if v != x && s[i] == x {\n            count(s, x) - 1\n        } else {\n            count(s, x)\n        },\n    decreases s.len(),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// This function counts the number of elements of `s` that are equal to `x`.\nspec fn count<T>(s: Seq<T>, x: T) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        count(s.skip(1), x) + if s[0] == x {\n            1int\n        } else {\n            0int\n        }\n    }\n}\n\n// This function defines what it means for two sequences to be\n// permutations of each other: for every value `x`, each of the two\n// sequences has the same number of instances of `x`.\nspec fn permutes<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    forall|x: T| count(s1, x) == count(s2, x)\n}\n\n// This lemma establishes the effect of an `update` operation on the\n// result of a `count`. That is, it gives a closed-form\n// (non-recursive) description of what happens to `count(s, x)` when\n// `s` is updated to `s.update(i, v)`.\nproof fn lemma_update_effect_on_count<T>(s: Seq<T>, i: int, v: T, x: T)\n    requires\n        0 <= i < s.len(),\n    ensures\n        count(s.update(i, v), x) == if v == x && s[i] != x {\n            count(s, x) + 1\n        } else if v != x && s[i] == x {\n            count(s, x) - 1\n        } else {\n            count(s, x)\n        },\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        return ;\n    }\n    if i == 0 {\n        assert(s.update(i, v) =~= seq![v] + s.skip(1));\n        assert(s.update(i, v).skip(1) =~= s.skip(1));\n    } else {\n        assert(s.update(i, v) =~= seq![s[0]] + s.skip(1).update(i - 1, v));\n        assert(s.update(i, v).skip(1) =~= s.skip(1).update(i - 1, v));\n        lemma_update_effect_on_count(s.skip(1), i - 1, v, x);\n    }\n}\n\n// This lemma proves that if you swap elements `i` and `j` of sequence `s`,\n// you get a permutation of `s`.\nproof fn lemma_swapping_produces_a_permutation<T>(s: Seq<T>, i: int, j: int)\n    requires\n        0 <= i < s.len(),\n        0 <= j < s.len(),\n    ensures\n        permutes(s.update(i, s[j]).update(j, s[i]), s),\n{\n    assert forall|x: T| #[trigger] count(s.update(i, s[j]).update(j, s[i]), x) == count(s, x) by {\n        lemma_update_effect_on_count(s, i, s[j], x);\n        lemma_update_effect_on_count(s.update(i, s[j]), j, s[i], x);\n    }\n}\n\n// This is the function we were asked to write.\nfn sort_third(l: Vec<i32>) -> (l_prime: Vec<i32>)\n    ensures\n        l_prime.len() == l.len(),\n        forall|i: int| 0 <= i < l.len() && i % 3 != 0 ==> l_prime[i] == l[i],  // unchanged if index not divisible by three\n        forall|i: int, j: int|\n            0 <= i < j < l.len() && i % 3 == 0 && j % 3 == 0 ==> l_prime[i] <= l_prime[j],\n        // indexes divisible by three are ordered\n        permutes(l_prime@, l@),  // new vec is a permutation of old vec\n{\n    let ghost old_l = l@;\n    let l_len = l.len();\n    let mut pos_being_set_to_smallest: usize = 0;\n    let mut l_prime: Vec<i32> = l;\n    // Iterate `pos_being_set_to_smallest` by 3 from 0 to `l_len`. Each time,\n    // look for the smallest element at a position divisible by three in the\n    // part of the vector at or past `pos_being_set_to_smallest`. Swap that\n    // element with the one at `pos_being_set_to_smallest`.\n    while pos_being_set_to_smallest < l_len\n        invariant\n            l_len == l.len() == l_prime.len(),\n            pos_being_set_to_smallest % 3 == 0,\n            forall|i: int| 0 <= i < l_len && i % 3 != 0 ==> l_prime[i] == l[i],\n            permutes(l_prime@, l@),\n            forall|i: int, j: int|\n                0 <= i < pos_being_set_to_smallest && i < j < l_len && i % 3 == 0 && j % 3 == 0\n                    ==> l_prime[i] <= l_prime[j],\n    {\n        // Iterate `pos_during_scan_for_smallest` by 3 from `pos_being_set_to_smallest`\n        // to `l_len`. Keep track of the position of the smallest element found so far\n        // in `pos_of_smallest_found_so_far`.\n        let mut pos_of_smallest_found_so_far: usize = pos_being_set_to_smallest;\n        let mut pos_during_scan_for_smallest: usize = pos_being_set_to_smallest;\n        while pos_during_scan_for_smallest < l_len\n            invariant\n                l_len == l.len() == l_prime.len(),\n                pos_being_set_to_smallest % 3 == 0,\n                pos_during_scan_for_smallest % 3 == 0,\n                pos_of_smallest_found_so_far % 3 == 0,\n                pos_being_set_to_smallest <= pos_during_scan_for_smallest,\n                pos_being_set_to_smallest <= pos_of_smallest_found_so_far < l_len,\n                forall|i: int| 0 <= i < l_len && i % 3 != 0 ==> l_prime[i] == l[i],\n                permutes(l_prime@, l@),\n                forall|i: int|\n                    pos_being_set_to_smallest <= i < pos_during_scan_for_smallest && i % 3 == 0\n                        ==> l_prime[pos_of_smallest_found_so_far as int] <= l_prime[i],\n                forall|i: int, j: int|\n                    0 <= i < pos_being_set_to_smallest && i < j < l_len && i % 3 == 0 && j % 3 == 0\n                        ==> l_prime[i] <= l_prime[j],\n        {\n            if l_prime[pos_during_scan_for_smallest] < l_prime[pos_of_smallest_found_so_far] {\n                pos_of_smallest_found_so_far = pos_during_scan_for_smallest;\n            }\n            pos_during_scan_for_smallest = pos_during_scan_for_smallest + 3;\n        }\n        // Invoke a lemma to show that swapping two elements, as we're\n        // about to do, doesn't change the count of each element.\n\n        proof {\n            lemma_swapping_produces_a_permutation(\n                l_prime@,\n                pos_being_set_to_smallest as int,\n                pos_of_smallest_found_so_far as int,\n            );\n        }\n        // Swap the elements at positions `pos_being_set_to_smallest`\n        // and `pos_of_smallest_found_so_far`.\n        let v1 = l_prime[pos_being_set_to_smallest];\n        let v2 = l_prime[pos_of_smallest_found_so_far];\n        l_prime.set(pos_being_set_to_smallest, v2);\n        l_prime.set(pos_of_smallest_found_so_far, v1);\n        pos_being_set_to_smallest = pos_being_set_to_smallest + 3;\n    }\n    l_prime\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// This function counts the number of elements of `s` that are equal to `x`.\nspec fn count<T>(s: Seq<T>, x: T) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        count(s.skip(1), x) + if s[0] == x {\n            1int\n        } else {\n            0int\n        }\n    }\n}\n\n// This function defines what it means for two sequences to be\n// permutations of each other: for every value `x`, each of the two\n// sequences has the same number of instances of `x`.\nspec fn permutes<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    forall|x: T| count(s1, x) == count(s2, x)\n}\n\n// This lemma establishes the effect of an `update` operation on the\n// result of a `count`. That is, it gives a closed-form\n// (non-recursive) description of what happens to `count(s, x)` when\n// `s` is updated to `s.update(i, v)`.\nproof fn lemma_update_effect_on_count<T>(s: Seq<T>, i: int, v: T, x: T)\n    requires\n        0 <= i < s.len(),\n    ensures\n        count(s.update(i, v), x) == if v == x && s[i] != x {\n            count(s, x) + 1\n        } else if v != x && s[i] == x {\n            count(s, x) - 1\n        } else {\n            count(s, x)\n        },\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        return ;\n    }\n    if i == 0 {\n        assert(s.update(i, v) =~= seq![v] + s.skip(1));\n        assert(s.update(i, v).skip(1) =~= s.skip(1));\n    } else {\n        assert(s.update(i, v) =~= seq![s[0]] + s.skip(1).update(i - 1, v));\n        assert(s.update(i, v).skip(1) =~= s.skip(1).update(i - 1, v));\n        lemma_update_effect_on_count(s.skip(1), i - 1, v, x);\n    }\n}\n\n// This lemma proves that if you swap elements `i` and `j` of sequence `s`,\n// you get a permutation of `s`.\nproof fn lemma_swapping_produces_a_permutation<T>(s: Seq<T>, i: int, j: int)\n    requires\n        0 <= i < s.len(),\n        0 <= j < s.len(),\n    ensures\n        permutes(s.update(i, s[j]).update(j, s[i]), s),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// This function counts the number of elements of `s` that are equal to `x`.\nspec fn count<T>(s: Seq<T>, x: T) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        count(s.skip(1), x) + if s[0] == x {\n            1int\n        } else {\n            0int\n        }\n    }\n}\n\n// This function defines what it means for two sequences to be\n// permutations of each other: for every value `x`, each of the two\n// sequences has the same number of instances of `x`.\nspec fn permutes<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    forall|x: T| count(s1, x) == count(s2, x)\n}\n\n// This lemma establishes the effect of an `update` operation on the\n// result of a `count`. That is, it gives a closed-form\n// (non-recursive) description of what happens to `count(s, x)` when\n// `s` is updated to `s.update(i, v)`.\nproof fn lemma_update_effect_on_count<T>(s: Seq<T>, i: int, v: T, x: T)\n    requires\n        0 <= i < s.len(),\n    ensures\n        count(s.update(i, v), x) == if v == x && s[i] != x {\n            count(s, x) + 1\n        } else if v != x && s[i] == x {\n            count(s, x) - 1\n        } else {\n            count(s, x)\n        },\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        return ;\n    }\n    if i == 0 {\n        assert(s.update(i, v) =~= seq![v] + s.skip(1));\n        assert(s.update(i, v).skip(1) =~= s.skip(1));\n    } else {\n        assert(s.update(i, v) =~= seq![s[0]] + s.skip(1).update(i - 1, v));\n        assert(s.update(i, v).skip(1) =~= s.skip(1).update(i - 1, v));\n        lemma_update_effect_on_count(s.skip(1), i - 1, v, x);\n    }\n}\n\n// This lemma proves that if you swap elements `i` and `j` of sequence `s`,\n// you get a permutation of `s`.\nproof fn lemma_swapping_produces_a_permutation<T>(s: Seq<T>, i: int, j: int)\n    requires\n        0 <= i < s.len(),\n        0 <= j < s.len(),\n    ensures\n        permutes(s.update(i, s[j]).update(j, s[i]), s),\n{\n    assert forall|x: T| #[trigger] count(s.update(i, s[j]).update(j, s[i]), x) == count(s, x) by {\n        lemma_update_effect_on_count(s, i, s[j], x);\n        lemma_update_effect_on_count(s.update(i, s[j]), j, s[i], x);\n    }\n}\n\n// This is the function we were asked to write.\nfn sort_third(l: Vec<i32>) -> (l_prime: Vec<i32>)\n    ensures\n        l_prime.len() == l.len(),\n        forall|i: int| 0 <= i < l.len() && i % 3 != 0 ==> l_prime[i] == l[i],  // unchanged if index not divisible by three\n        forall|i: int, j: int|\n            0 <= i < j < l.len() && i % 3 == 0 && j % 3 == 0 ==> l_prime[i] <= l_prime[j],\n        // indexes divisible by three are ordered\n        permutes(l_prime@, l@),  // new vec is a permutation of old vec\n{\n    let ghost old_l = l@;\n    let l_len = l.len();\n    let mut pos_being_set_to_smallest: usize = 0;\n    let mut l_prime: Vec<i32> = l;\n    // Iterate `pos_being_set_to_smallest` by 3 from 0 to `l_len`. Each time,\n    // look for the smallest element at a position divisible by three in the\n    // part of the vector at or past `pos_being_set_to_smallest`. Swap that\n    // element with the one at `pos_being_set_to_smallest`.\n    while pos_being_set_to_smallest < l_len\n        invariant\n            l_len == l.len() == l_prime.len(),\n            pos_being_set_to_smallest % 3 == 0,\n            forall|i: int| 0 <= i < l_len && i % 3 != 0 ==> l_prime[i] == l[i],\n            permutes(l_prime@, l@),\n            forall|i: int, j: int|\n                0 <= i < pos_being_set_to_smallest && i < j < l_len && i % 3 == 0 && j % 3 == 0\n                    ==> l_prime[i] <= l_prime[j],\n    {\n        // Iterate `pos_during_scan_for_smallest` by 3 from `pos_being_set_to_smallest`\n        // to `l_len`. Keep track of the position of the smallest element found so far\n        // in `pos_of_smallest_found_so_far`.\n        let mut pos_of_smallest_found_so_far: usize = pos_being_set_to_smallest;\n        let mut pos_during_scan_for_smallest: usize = pos_being_set_to_smallest;\n        while pos_during_scan_for_smallest < l_len\n            invariant\n                l_len == l.len() == l_prime.len(),\n                pos_being_set_to_smallest % 3 == 0,\n                pos_during_scan_for_smallest % 3 == 0,\n                pos_of_smallest_found_so_far % 3 == 0,\n                pos_being_set_to_smallest <= pos_during_scan_for_smallest,\n                pos_being_set_to_smallest <= pos_of_smallest_found_so_far < l_len,\n                forall|i: int| 0 <= i < l_len && i % 3 != 0 ==> l_prime[i] == l[i],\n                permutes(l_prime@, l@),\n                forall|i: int|\n                    pos_being_set_to_smallest <= i < pos_during_scan_for_smallest && i % 3 == 0\n                        ==> l_prime[pos_of_smallest_found_so_far as int] <= l_prime[i],\n                forall|i: int, j: int|\n                    0 <= i < pos_being_set_to_smallest && i < j < l_len && i % 3 == 0 && j % 3 == 0\n                        ==> l_prime[i] <= l_prime[j],\n        {\n            if l_prime[pos_during_scan_for_smallest] < l_prime[pos_of_smallest_found_so_far] {\n                pos_of_smallest_found_so_far = pos_during_scan_for_smallest;\n            }\n            pos_during_scan_for_smallest = pos_during_scan_for_smallest + 3;\n        }\n        // Invoke a lemma to show that swapping two elements, as we're\n        // about to do, doesn't change the count of each element.\n\n        proof {\n            lemma_swapping_produces_a_permutation(\n                l_prime@,\n                pos_being_set_to_smallest as int,\n                pos_of_smallest_found_so_far as int,\n            );\n        }\n        // Swap the elements at positions `pos_being_set_to_smallest`\n        // and `pos_of_smallest_found_so_far`.\n        let v1 = l_prime[pos_being_set_to_smallest];\n        let v2 = l_prime[pos_of_smallest_found_so_far];\n        l_prime.set(pos_being_set_to_smallest, v2);\n        l_prime.set(pos_of_smallest_found_so_far, v1);\n        pos_being_set_to_smallest = pos_being_set_to_smallest + 3;\n    }\n    l_prime\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// This function counts the number of elements of `s` that are equal to `x`.\nspec fn count<T>(s: Seq<T>, x: T) -> int\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        0\n    } else {\n        count(s.skip(1), x) + if s[0] == x {\n            1int\n        } else {\n            0int\n        }\n    }\n}\n\n// This function defines what it means for two sequences to be\n// permutations of each other: for every value `x`, each of the two\n// sequences has the same number of instances of `x`.\nspec fn permutes<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    forall|x: T| count(s1, x) == count(s2, x)\n}\n\n// This lemma establishes the effect of an `update` operation on the\n// result of a `count`. That is, it gives a closed-form\n// (non-recursive) description of what happens to `count(s, x)` when\n// `s` is updated to `s.update(i, v)`.\nproof fn lemma_update_effect_on_count<T>(s: Seq<T>, i: int, v: T, x: T)\n    requires\n        0 <= i < s.len(),\n    ensures\n        count(s.update(i, v), x) == if v == x && s[i] != x {\n            count(s, x) + 1\n        } else if v != x && s[i] == x {\n            count(s, x) - 1\n        } else {\n            count(s, x)\n        },\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        return ;\n    }\n    if i == 0 {\n        assert(s.update(i, v) =~= seq![v] + s.skip(1));\n        assert(s.update(i, v).skip(1) =~= s.skip(1));\n    } else {\n        assert(s.update(i, v) =~= seq![s[0]] + s.skip(1).update(i - 1, v));\n        assert(s.update(i, v).skip(1) =~= s.skip(1).update(i - 1, v));\n        lemma_update_effect_on_count(s.skip(1), i - 1, v, x);\n    }\n}\n\n// This lemma proves that if you swap elements `i` and `j` of sequence `s`,\n// you get a permutation of `s`.\nproof fn lemma_swapping_produces_a_permutation<T>(s: Seq<T>, i: int, j: int)\n    requires\n        0 <= i < s.len(),\n        0 <= j < s.len(),\n    ensures\n        permutes(s.update(i, s[j]).update(j, s[i]), s),\n{\n    assert forall|x: T| #[trigger] count(s.update(i, s[j]).update(j, s[i]), x) == count(s, x) by {\n        lemma_update_effect_on_count(s, i, s[j], x);\n        lemma_update_effect_on_count(s.update(i, s[j]), j, s[i], x);\n    }\n}\n\n// This is the function we were asked to write.\nfn sort_third(l: Vec<i32>) -> (l_prime: Vec<i32>)\n    ensures\n        l_prime.len() == l.len(),\n        forall|i: int| 0 <= i < l.len() && i % 3 != 0 ==> l_prime[i] == l[i],  // unchanged if index not divisible by three\n        forall|i: int, j: int|\n            0 <= i < j < l.len() && i % 3 == 0 && j % 3 == 0 ==> l_prime[i] <= l_prime[j],\n        // indexes divisible by three are ordered\n        permutes(l_prime@, l@),  // new vec is a permutation of old vec\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn incr_list(l: Vec<i32>) -> (result: Vec<i32>)\n    requires\n        forall|i: int| 0 <= i < l.len() ==> l[i] + 1 <= i32::MAX,  // avoid overflow\n\n    ensures\n        result.len() == l.len(),\n        forall|i: int| 0 <= i < l.len() ==> #[trigger] result[i] == l[i] + 1,\n{\n    let mut result = Vec::with_capacity(l.len());\n    for i in 0..l.len()\n        invariant\n            forall|i: int| 0 <= i < l.len() ==> l[i] + 1 <= i32::MAX,\n            result.len() == i,\n            forall|j: int| 0 <= j < i ==> #[trigger] result[j] == l[j] + 1,\n    {\n        result.push(l[i] + 1);\n    }\n    result\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn incr_list(l: Vec<i32>) -> (result: Vec<i32>)\n    requires\n        forall|i: int| 0 <= i < l.len() ==> l[i] + 1 <= i32::MAX,  // avoid overflow\n\n    ensures\n        result.len() == l.len(),\n        forall|i: int| 0 <= i < l.len() ==> #[trigger] result[i] == l[i] + 1,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn triangle_area(a: u64, h: u64) -> (area: u64)\n    requires\n        a > 0,  // side length must be positive\n        h > 0,  // height must be positive\n        a * h / 2 <= u64::MAX  // area must not overflow `u64`\n        ,\n    ensures\n        area == a * h / 2,  // area of a triangle is 1/2 * base * height\n{\n    // We can't just write `a * h / 2` because the multiplication of\n    // `a * h` might overflow. Instead, we do the division `a / 2`\n    // before multiplying by `h`. This requires us to deal with the\n    // possibility of a remainder during that division. Note that some\n    // parentheses below aren't necessary, but are included to make\n    // the code more readable.\n    if a % 2 == 0 {\n        assert(a % 2 == 0 ==> (a / 2) * h == a * h / 2) by (nonlinear_arith);\n        (a / 2) * h\n    } else {\n        assert(a % 2 == 1 ==> (a / 2) * h + (h / 2) == a * h / 2) by (nonlinear_arith);\n        (a / 2) * h + (h / 2)\n    }\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn triangle_area(a: u64, h: u64) -> (area: u64)\n    requires\n        a > 0,  // side length must be positive\n        h > 0,  // height must be positive\n        a * h / 2 <= u64::MAX  // area must not overflow `u64`\n        ,\n    ensures\n        area == a * h / 2,  // area of a triangle is 1/2 * base * height\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn is_palindrome(text: &str) -> (result: bool)\n    ensures\n        result == forall|i: int|\n            0 <= i < text@.len() ==> #[trigger] text@[i] == text@[text@.len() - 1 - i],\n{\n    let text_len: usize = text.unicode_len();\n    for pos in 0..text_len / 2\n        invariant\n            text_len == text@.len(),\n            forall|i: int| 0 <= i < pos ==> #[trigger] text@[i] == text@[text_len - 1 - i],\n    {\n        if text.get_char(pos) != text.get_char(text_len - 1 - pos) {\n            return false;\n        }\n    }\n    true\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn is_palindrome(text: &str) -> (result: bool)\n    ensures\n        result == forall|i: int|\n            0 <= i < text@.len() ==> #[trigger] text@[i] == text@[text@.len() - 1 - i],\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// This spec function checks whether a character is a vowel\npub open spec fn is_vowel_spec(c: char) -> bool {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\n        || c == 'O' || c == 'U'\n}\n\n// This auxilary exec function checks whether a character is a vowel\nfn is_vowel(c: char) -> (is_vowel: bool)\n    ensures\n        is_vowel == is_vowel_spec(c),\n{\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\n        || c == 'O' || c == 'U'\n}\n\n// Implementation following the ground-truth\n// This function removes vowels from a given string\nfn remove_vowels(str: &[char]) -> (str_without_vowels: Vec<char>)\n    ensures\n        str_without_vowels@ == str@.filter(|x: char| !is_vowel_spec(x)),\n{\n    let ghost str_length = str.len();\n    let mut str_without_vowels: Vec<char> = Vec::new();\n    assert(str@.take(0int).filter(|x: char| !is_vowel_spec(x)) == Seq::<char>::empty());\n\n    for index in 0..str.len()\n        invariant\n            str_without_vowels@ == str@.take(index as int).filter(|x: char| !is_vowel_spec(x)),\n    {\n        if !is_vowel(str[index]) {\n            str_without_vowels.push(str[index]);\n        }\n        assert(str@.take((index + 1) as int).drop_last() == str@.take(index as int));\n        reveal(Seq::filter);\n    }\n    assert(str@ == str@.take(str_length as int));\n    str_without_vowels\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// This spec function checks whether a character is a vowel\npub open spec fn is_vowel_spec(c: char) -> bool {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\n        || c == 'O' || c == 'U'\n}\n\n// This auxilary exec function checks whether a character is a vowel\nfn is_vowel(c: char) -> (is_vowel: bool)\n    ensures\n        is_vowel == is_vowel_spec(c),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// This spec function checks whether a character is a vowel\npub open spec fn is_vowel_spec(c: char) -> bool {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\n        || c == 'O' || c == 'U'\n}\n\n// This auxilary exec function checks whether a character is a vowel\nfn is_vowel(c: char) -> (is_vowel: bool)\n    ensures\n        is_vowel == is_vowel_spec(c),\n{\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\n        || c == 'O' || c == 'U'\n}\n\n// Implementation following the ground-truth\n// This function removes vowels from a given string\nfn remove_vowels(str: &[char]) -> (str_without_vowels: Vec<char>)\n    ensures\n        str_without_vowels@ == str@.filter(|x: char| !is_vowel_spec(x)),\n{\n    let ghost str_length = str.len();\n    let mut str_without_vowels: Vec<char> = Vec::new();\n    assert(str@.take(0int).filter(|x: char| !is_vowel_spec(x)) == Seq::<char>::empty());\n\n    for index in 0..str.len()\n        invariant\n            str_without_vowels@ == str@.take(index as int).filter(|x: char| !is_vowel_spec(x)),\n    {\n        if !is_vowel(str[index]) {\n            str_without_vowels.push(str[index]);\n        }\n        assert(str@.take((index + 1) as int).drop_last() == str@.take(index as int));\n        reveal(Seq::filter);\n    }\n    assert(str@ == str@.take(str_length as int));\n    str_without_vowels\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// This spec function checks whether a character is a vowel\npub open spec fn is_vowel_spec(c: char) -> bool {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\n        || c == 'O' || c == 'U'\n}\n\n// This auxilary exec function checks whether a character is a vowel\nfn is_vowel(c: char) -> (is_vowel: bool)\n    ensures\n        is_vowel == is_vowel_spec(c),\n{\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\n        || c == 'O' || c == 'U'\n}\n\n// Implementation following the ground-truth\n// This function removes vowels from a given string\nfn remove_vowels(str: &[char]) -> (str_without_vowels: Vec<char>)\n    ensures\n        str_without_vowels@ == str@.filter(|x: char| !is_vowel_spec(x)),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn below_threshold(l: &[i32], t: i32) -> (result: bool)\n    ensures\n        result == forall|i: int| 0 <= i < l.len() ==> l[i] < t,\n{\n    for i in 0..l.len()\n        invariant\n            forall|j: int| 0 <= j < i ==> l[j] < t,\n    {\n        if l[i] >= t {\n            return false;\n        }\n    }\n    true\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn below_threshold(l: &[i32], t: i32) -> (result: bool)\n    ensures\n        result == forall|i: int| 0 <= i < l.len() ==> l[i] < t,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// O(n) non-recursive solution using same spec as 55a\n#[verifier::memoize]\nspec fn spec_fib(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        1\n    } else {\n        spec_fib((n - 1) as nat) + spec_fib((n - 2) as nat)\n    }\n}\n\nproof fn lemma_fib_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_fib(i) <= spec_fib(j),\n    decreases j - i,\n{\n    if (i < 2 && j < 2) || i == j {\n    } else if i == j - 1 {\n        reveal_with_fuel(spec_fib, 2);\n        lemma_fib_monotonic(i, (j - 1) as nat);\n    } else {\n        lemma_fib_monotonic(i, (j - 1) as nat);\n        lemma_fib_monotonic(i, (j - 2) as nat);\n    }\n}\n\nfn fib(n: u32) -> (ret: Option<u32>)\n    ensures\n        match ret {\n            None => spec_fib(n as nat) > u32::MAX,\n            Some(f) => f == spec_fib(n as nat),\n        },\n{\n    if n == 0 {\n        return Some(0);\n    }\n    if n == 1 {\n        return Some(1);\n    }\n    if n > 47 {\n        proof {\n            assert(spec_fib(48) > u32::MAX) by (compute_only);\n            lemma_fib_monotonic(48, n as nat);\n        }\n        return None;\n    }\n    let mut a: u32 = 0;\n    let mut b: u32 = 1;\n    let mut i: u32 = 2;\n\n    for i in 1..n\n        invariant\n            1 <= i as int <= n <= 47,\n            a as int == spec_fib((i - 1) as nat),\n            b as int == spec_fib(i as nat),\n    {\n        proof {\n            // Prove that that n1 + n2 won't overflow\n            assert(spec_fib(47) < u32::MAX) by (compute_only);\n            lemma_fib_monotonic(i as nat, 47);\n            lemma_fib_monotonic((i - 1) as nat, 47);\n            lemma_fib_monotonic((i + 1) as nat, 47);\n        }\n        let sum = a + b;\n        a = b;\n        b = sum;\n    }\n    Some(b)\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// O(n) non-recursive solution using same spec as 55a\n#[verifier::memoize]\nspec fn spec_fib(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        1\n    } else {\n        spec_fib((n - 1) as nat) + spec_fib((n - 2) as nat)\n    }\n}\n\nproof fn lemma_fib_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_fib(i) <= spec_fib(j),\n    decreases j - i,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// O(n) non-recursive solution using same spec as 55a\n#[verifier::memoize]\nspec fn spec_fib(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        1\n    } else {\n        spec_fib((n - 1) as nat) + spec_fib((n - 2) as nat)\n    }\n}\n\nproof fn lemma_fib_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_fib(i) <= spec_fib(j),\n    decreases j - i,\n{\n    if (i < 2 && j < 2) || i == j {\n    } else if i == j - 1 {\n        reveal_with_fuel(spec_fib, 2);\n        lemma_fib_monotonic(i, (j - 1) as nat);\n    } else {\n        lemma_fib_monotonic(i, (j - 1) as nat);\n        lemma_fib_monotonic(i, (j - 2) as nat);\n    }\n}\n\nfn fib(n: u32) -> (ret: Option<u32>)\n    ensures\n        match ret {\n            None => spec_fib(n as nat) > u32::MAX,\n            Some(f) => f == spec_fib(n as nat),\n        },\n{\n    if n == 0 {\n        return Some(0);\n    }\n    if n == 1 {\n        return Some(1);\n    }\n    if n > 47 {\n        proof {\n            assert(spec_fib(48) > u32::MAX) by (compute_only);\n            lemma_fib_monotonic(48, n as nat);\n        }\n        return None;\n    }\n    let mut a: u32 = 0;\n    let mut b: u32 = 1;\n    let mut i: u32 = 2;\n\n    for i in 1..n\n        invariant\n            1 <= i as int <= n <= 47,\n            a as int == spec_fib((i - 1) as nat),\n            b as int == spec_fib(i as nat),\n    {\n        proof {\n            // Prove that that n1 + n2 won't overflow\n            assert(spec_fib(47) < u32::MAX) by (compute_only);\n            lemma_fib_monotonic(i as nat, 47);\n            lemma_fib_monotonic((i - 1) as nat, 47);\n            lemma_fib_monotonic((i + 1) as nat, 47);\n        }\n        let sum = a + b;\n        a = b;\n        b = sum;\n    }\n    Some(b)\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// O(n) non-recursive solution using same spec as 55a\n#[verifier::memoize]\nspec fn spec_fib(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        1\n    } else {\n        spec_fib((n - 1) as nat) + spec_fib((n - 2) as nat)\n    }\n}\n\nproof fn lemma_fib_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_fib(i) <= spec_fib(j),\n    decreases j - i,\n{\n    if (i < 2 && j < 2) || i == j {\n    } else if i == j - 1 {\n        reveal_with_fuel(spec_fib, 2);\n        lemma_fib_monotonic(i, (j - 1) as nat);\n    } else {\n        lemma_fib_monotonic(i, (j - 1) as nat);\n        lemma_fib_monotonic(i, (j - 2) as nat);\n    }\n}\n\nfn fib(n: u32) -> (ret: Option<u32>)\n    ensures\n        match ret {\n            None => spec_fib(n as nat) > u32::MAX,\n            Some(f) => f == spec_fib(n as nat),\n        },\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::memoize]\nspec fn spec_fib(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        1\n    } else {\n        spec_fib((n - 1) as nat) + spec_fib((n - 2) as nat)\n    }\n}\n\nproof fn lemma_fib_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_fib(i) <= spec_fib(j),\n    decreases j - i,\n{\n    if (i < 2 && j < 2) || i == j {\n    } else if i == j - 1 {\n        reveal_with_fuel(spec_fib, 2);\n        lemma_fib_monotonic(i, (j - 1) as nat);\n    } else {\n        lemma_fib_monotonic(i, (j - 1) as nat);\n        lemma_fib_monotonic(i, (j - 2) as nat);\n    }\n}\n\nfn fib(n: u32) -> (ret: Option<u32>)\n    ensures\n        match ret {\n            None => spec_fib(n as nat) > u32::MAX,\n            Some(f) => f == spec_fib(n as nat),\n        },\n{\n    if n > 47 {\n        proof {\n            assert(spec_fib(48) > u32::MAX) by (compute_only);\n            lemma_fib_monotonic(48, n as nat);\n        }\n        return None;\n    }\n    match n {\n        0 => Some(0),\n        1 => Some(1),\n        _ => {\n            proof {\n                // Prove that the recursive calls below succeed,\n                // and that n1 + n2 won't overflow\n                assert(spec_fib(47) < u32::MAX) by (compute_only);\n                lemma_fib_monotonic(n as nat, 47);\n                lemma_fib_monotonic((n - 1) as nat, 47);\n                lemma_fib_monotonic((n - 2) as nat, 47);\n            }\n            let n1 = fib(n - 1)?;\n            let n2 = fib(n - 2)?;\n            Some(n1 + n2)\n        },\n    }\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::memoize]\nspec fn spec_fib(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        1\n    } else {\n        spec_fib((n - 1) as nat) + spec_fib((n - 2) as nat)\n    }\n}\n\nproof fn lemma_fib_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_fib(i) <= spec_fib(j),\n    decreases j - i,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::memoize]\nspec fn spec_fib(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        1\n    } else {\n        spec_fib((n - 1) as nat) + spec_fib((n - 2) as nat)\n    }\n}\n\nproof fn lemma_fib_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_fib(i) <= spec_fib(j),\n    decreases j - i,\n{\n    if (i < 2 && j < 2) || i == j {\n    } else if i == j - 1 {\n        reveal_with_fuel(spec_fib, 2);\n        lemma_fib_monotonic(i, (j - 1) as nat);\n    } else {\n        lemma_fib_monotonic(i, (j - 1) as nat);\n        lemma_fib_monotonic(i, (j - 2) as nat);\n    }\n}\n\nfn fib(n: u32) -> (ret: Option<u32>)\n    ensures\n        match ret {\n            None => spec_fib(n as nat) > u32::MAX,\n            Some(f) => f == spec_fib(n as nat),\n        },\n{\n    if n > 47 {\n        proof {\n            assert(spec_fib(48) > u32::MAX) by (compute_only);\n            lemma_fib_monotonic(48, n as nat);\n        }\n        return None;\n    }\n    match n {\n        0 => Some(0),\n        1 => Some(1),\n        _ => {\n            proof {\n                // Prove that the recursive calls below succeed,\n                // and that n1 + n2 won't overflow\n                assert(spec_fib(47) < u32::MAX) by (compute_only);\n                lemma_fib_monotonic(n as nat, 47);\n                lemma_fib_monotonic((n - 1) as nat, 47);\n                lemma_fib_monotonic((n - 2) as nat, 47);\n            }\n            let n1 = fib(n - 1)?;\n            let n2 = fib(n - 2)?;\n            Some(n1 + n2)\n        },\n    }\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::memoize]\nspec fn spec_fib(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        1\n    } else {\n        spec_fib((n - 1) as nat) + spec_fib((n - 2) as nat)\n    }\n}\n\nproof fn lemma_fib_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_fib(i) <= spec_fib(j),\n    decreases j - i,\n{\n    if (i < 2 && j < 2) || i == j {\n    } else if i == j - 1 {\n        reveal_with_fuel(spec_fib, 2);\n        lemma_fib_monotonic(i, (j - 1) as nat);\n    } else {\n        lemma_fib_monotonic(i, (j - 1) as nat);\n        lemma_fib_monotonic(i, (j - 2) as nat);\n    }\n}\n\nfn fib(n: u32) -> (ret: Option<u32>)\n    ensures\n        match ret {\n            None => spec_fib(n as nat) > u32::MAX,\n            Some(f) => f == spec_fib(n as nat),\n        },\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// say the return value is (x, b), x = number of '<' - number of '>', b = whether x ever dipped below 0\nspec fn spec_bracketing_helper(brackets: Seq<char>) -> (int, bool) {\n    brackets.fold_left(\n        (0, true),\n        |p: (int, bool), c|\n            {\n                let (x, b) = p;\n                match (c) {\n                    '<' => (x + 1, b),\n                    '>' => (x - 1, b && x - 1 >= 0),\n                    _ => (x, b),\n                }\n            },\n    )\n}\n\nspec fn spec_bracketing(brackets: Seq<char>) -> bool {\n    let p = spec_bracketing_helper(brackets);\n    p.1 && p.0 == 0\n}\n\nfn correct_bracketing(brackets: &str) -> (ret: bool)\n    requires\n        brackets@.len() <= i32::MAX,\n        -brackets@.len() >= i32::MIN,\n    ensures\n        ret <==> spec_bracketing(brackets@),\n{\n    let mut i = 0;\n    let mut b = true;\n    let mut stack_size: i32 = 0;\n\n    while i < brackets.unicode_len()\n        invariant\n            (stack_size as int, b) == spec_bracketing_helper(brackets@.subrange(0, i as int)),\n            stack_size <= i <= brackets@.len() <= i32::MAX,\n            stack_size >= -i >= -brackets@.len() >= i32::MIN,\n    {\n        let c = brackets.get_char(i);\n        let ghost prev = spec_bracketing_helper(brackets@.subrange(0, i as int));\n        if (c == '<') {\n            stack_size += 1;\n        } else if (c == '>') {\n            b = b && stack_size > 0;\n            stack_size -= 1;\n        }\n        assert(brackets@.subrange(0, i + 1 as int).drop_last() =~= brackets@.subrange(0, i as int));\n        i += 1;\n    }\n    assert(brackets@ =~= brackets@.subrange(0, i as int));\n    b && stack_size == 0\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// say the return value is (x, b), x = number of '<' - number of '>', b = whether x ever dipped below 0\nspec fn spec_bracketing_helper(brackets: Seq<char>) -> (int, bool) {\n    brackets.fold_left(\n        (0, true),\n        |p: (int, bool), c|\n            {\n                let (x, b) = p;\n                match (c) {\n                    '<' => (x + 1, b),\n                    '>' => (x - 1, b && x - 1 >= 0),\n                    _ => (x, b),\n                }\n            },\n    )\n}\n\nspec fn spec_bracketing(brackets: Seq<char>) -> bool {\n    let p = spec_bracketing_helper(brackets);\n    p.1 && p.0 == 0\n}\n\nfn correct_bracketing(brackets: &str) -> (ret: bool)\n    requires\n        brackets@.len() <= i32::MAX,\n        -brackets@.len() >= i32::MIN,\n    ensures\n        ret <==> spec_bracketing(brackets@),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn monotonic(l: Vec<i32>) -> (ret: bool)\n    ensures\n        ret <==> (forall|i: int, j: int| 0 <= i < j < l@.len() ==> l@.index(i) <= l@.index(j)) || (\n        forall|i: int, j: int| 0 <= i < j < l@.len() ==> l@.index(i) >= l@.index(j)),\n{\n    if l.len() == 0 || l.len() == 1 {\n        return true;\n    }\n    let mut increasing = true;\n    let mut decreasing = true;\n\n    let mut n = 0;\n    while n < l.len() - 1\n        invariant\n            l.len() > 1,\n            n <= l.len() - 1,\n            increasing <==> forall|i: int, j: int|\n                0 <= i < j < n + 1 ==> l@.index(i) <= l@.index(j),\n            decreasing <==> forall|i: int, j: int|\n                0 <= i < j < n + 1 ==> l@.index(i) >= l@.index(j),\n    {\n        if l[n] < l[n + 1] {\n            decreasing = false;\n        } else if l[n] > l[n + 1] {\n            increasing = false;\n        }\n        n += 1;\n    }\n    increasing || decreasing\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn monotonic(l: Vec<i32>) -> (ret: bool)\n    ensures\n        ret <==> (forall|i: int, j: int| 0 <= i < j < l@.len() ==> l@.index(i) <= l@.index(j)) || (\n        forall|i: int, j: int| 0 <= i < j < l@.len() ==> l@.index(i) >= l@.index(j)),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// Note that according to the canonical solution 1 is treated as a possible largest prime. We'll stick to this\nspec fn spec_prime_helper(num: int, limit: int) -> bool {\n    forall|j: int| 2 <= j < limit ==> (#[trigger] (num % j)) != 0\n}\n\nspec fn spec_prime(num: int) -> bool {\n    spec_prime_helper(num, num)\n}\n\nfn is_prime(num: u32) -> (result: bool)\n    requires\n        num >= 2,\n    ensures\n        result <==> spec_prime(num as int),\n{\n    let mut i = 2;\n    let mut result = true;\n    while i < num\n        invariant\n            2 <= i <= num,\n            result <==> spec_prime_helper(num as int, i as int),\n    {\n        if num % i == 0 {\n            result = false;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn largest_prime_factor(n: u32) -> (largest: u32)\n    requires\n        n >= 2,\n    ensures\n        1 <= largest <= n,\n        spec_prime(largest as int),\n        n % largest == 0,\n        forall|p| 0 <= p < n && spec_prime(p) && n as int % p == 0 ==> p <= largest,\n{\n    let mut largest = 1;\n    let mut j = 1;\n    while j < n\n        invariant\n            1 <= largest <= j <= n,\n            spec_prime(largest as int),\n            n % largest == 0,\n            forall|p| 0 <= p <= j && spec_prime(p) && n as int % p == 0 ==> p <= largest,\n    {\n        j += 1;\n        let flag = is_prime(j);\n        if n % j == 0 && flag {\n            largest =\n            if largest > j {\n                largest\n            } else {\n                j\n            };\n        }\n    }\n    largest\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// Note that according to the canonical solution 1 is treated as a possible largest prime. We'll stick to this\nspec fn spec_prime_helper(num: int, limit: int) -> bool {\n    forall|j: int| 2 <= j < limit ==> (#[trigger] (num % j)) != 0\n}\n\nspec fn spec_prime(num: int) -> bool {\n    spec_prime_helper(num, num)\n}\n\nfn is_prime(num: u32) -> (result: bool)\n    requires\n        num >= 2,\n    ensures\n        result <==> spec_prime(num as int),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// Note that according to the canonical solution 1 is treated as a possible largest prime. We'll stick to this\nspec fn spec_prime_helper(num: int, limit: int) -> bool {\n    forall|j: int| 2 <= j < limit ==> (#[trigger] (num % j)) != 0\n}\n\nspec fn spec_prime(num: int) -> bool {\n    spec_prime_helper(num, num)\n}\n\nfn is_prime(num: u32) -> (result: bool)\n    requires\n        num >= 2,\n    ensures\n        result <==> spec_prime(num as int),\n{\n    let mut i = 2;\n    let mut result = true;\n    while i < num\n        invariant\n            2 <= i <= num,\n            result <==> spec_prime_helper(num as int, i as int),\n    {\n        if num % i == 0 {\n            result = false;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn largest_prime_factor(n: u32) -> (largest: u32)\n    requires\n        n >= 2,\n    ensures\n        1 <= largest <= n,\n        spec_prime(largest as int),\n        n % largest == 0,\n        forall|p| 0 <= p < n && spec_prime(p) && n as int % p == 0 ==> p <= largest,\n{\n    let mut largest = 1;\n    let mut j = 1;\n    while j < n\n        invariant\n            1 <= largest <= j <= n,\n            spec_prime(largest as int),\n            n % largest == 0,\n            forall|p| 0 <= p <= j && spec_prime(p) && n as int % p == 0 ==> p <= largest,\n    {\n        j += 1;\n        let flag = is_prime(j);\n        if n % j == 0 && flag {\n            largest =\n            if largest > j {\n                largest\n            } else {\n                j\n            };\n        }\n    }\n    largest\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// Note that according to the canonical solution 1 is treated as a possible largest prime. We'll stick to this\nspec fn spec_prime_helper(num: int, limit: int) -> bool {\n    forall|j: int| 2 <= j < limit ==> (#[trigger] (num % j)) != 0\n}\n\nspec fn spec_prime(num: int) -> bool {\n    spec_prime_helper(num, num)\n}\n\nfn is_prime(num: u32) -> (result: bool)\n    requires\n        num >= 2,\n    ensures\n        result <==> spec_prime(num as int),\n{\n    let mut i = 2;\n    let mut result = true;\n    while i < num\n        invariant\n            2 <= i <= num,\n            result <==> spec_prime_helper(num as int, i as int),\n    {\n        if num % i == 0 {\n            result = false;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn largest_prime_factor(n: u32) -> (largest: u32)\n    requires\n        n >= 2,\n    ensures\n        1 <= largest <= n,\n        spec_prime(largest as int),\n        n % largest == 0,\n        forall|p| 0 <= p < n && spec_prime(p) && n as int % p == 0 ==> p <= largest,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_sum_to_n(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else {\n        n + spec_sum_to_n((n - 1) as nat)\n    }\n}\n\nproof fn lemma_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_sum_to_n(i) <= spec_sum_to_n(j),\n    decreases j - i,\n{\n    if (i == 0 && j == 0) || i == j {\n    } else if i == j - 1 {\n        lemma_sum_monotonic(i, (j - 1) as nat);\n    } else {\n        lemma_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nproof fn lemma_sum_to_n_closed_form(n: nat)\n    ensures\n        spec_sum_to_n(n) == (n * (n + 1)) / 2,\n    decreases n,\n{\n    if n == 0 {\n    } else {\n        assert(spec_sum_to_n((n - 1) as nat) == ((n - 1) * n) / 2) by {\n            lemma_sum_to_n_closed_form((n - 1) as nat);\n        }\n        assert(n + (((n - 1) * n) / 2) == (n * (n + 1)) / 2) by (nonlinear_arith);\n    }\n}\n\nfn sum_to_n(n: u32) -> (sum: Option<u32>)\n    ensures\n        match sum {\n            None => spec_sum_to_n(n as nat) > u32::MAX,\n            Some(f) => f == spec_sum_to_n(n as nat),\n        },\n{\n    if n >= 92682 {\n        proof {\n            lemma_sum_to_n_closed_form(92682);\n            lemma_sum_monotonic(92682, n as nat);\n        }\n        return None;\n    }\n    let mut res: u32 = 0;\n    let mut sum: u32 = 0;\n    let mut i: u32 = 0;\n    while i < n\n        invariant\n            i <= n < 92682,\n            res == spec_sum_to_n(i as nat),\n            res <= u32::MAX,\n    {\n        i += 1;\n        proof {\n            // Prove that that n1 + n2 won't overflow\n            lemma_sum_to_n_closed_form(92681);\n            lemma_sum_monotonic(i as nat, 92681);\n            lemma_sum_monotonic((i - 1) as nat, 92681);\n        }\n        res = i + res;\n    }\n    Some(res)\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_sum_to_n(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else {\n        n + spec_sum_to_n((n - 1) as nat)\n    }\n}\n\nproof fn lemma_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_sum_to_n(i) <= spec_sum_to_n(j),\n    decreases j - i,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_sum_to_n(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else {\n        n + spec_sum_to_n((n - 1) as nat)\n    }\n}\n\nproof fn lemma_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_sum_to_n(i) <= spec_sum_to_n(j),\n    decreases j - i,\n{\n    if (i == 0 && j == 0) || i == j {\n    } else if i == j - 1 {\n        lemma_sum_monotonic(i, (j - 1) as nat);\n    } else {\n        lemma_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nproof fn lemma_sum_to_n_closed_form(n: nat)\n    ensures\n        spec_sum_to_n(n) == (n * (n + 1)) / 2,\n    decreases n,\n{\n    if n == 0 {\n    } else {\n        assert(spec_sum_to_n((n - 1) as nat) == ((n - 1) * n) / 2) by {\n            lemma_sum_to_n_closed_form((n - 1) as nat);\n        }\n        assert(n + (((n - 1) * n) / 2) == (n * (n + 1)) / 2) by (nonlinear_arith);\n    }\n}\n\nfn sum_to_n(n: u32) -> (sum: Option<u32>)\n    ensures\n        match sum {\n            None => spec_sum_to_n(n as nat) > u32::MAX,\n            Some(f) => f == spec_sum_to_n(n as nat),\n        },\n{\n    if n >= 92682 {\n        proof {\n            lemma_sum_to_n_closed_form(92682);\n            lemma_sum_monotonic(92682, n as nat);\n        }\n        return None;\n    }\n    let mut res: u32 = 0;\n    let mut sum: u32 = 0;\n    let mut i: u32 = 0;\n    while i < n\n        invariant\n            i <= n < 92682,\n            res == spec_sum_to_n(i as nat),\n            res <= u32::MAX,\n    {\n        i += 1;\n        proof {\n            // Prove that that n1 + n2 won't overflow\n            lemma_sum_to_n_closed_form(92681);\n            lemma_sum_monotonic(i as nat, 92681);\n            lemma_sum_monotonic((i - 1) as nat, 92681);\n        }\n        res = i + res;\n    }\n    Some(res)\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_sum_to_n(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else {\n        n + spec_sum_to_n((n - 1) as nat)\n    }\n}\n\nproof fn lemma_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_sum_to_n(i) <= spec_sum_to_n(j),\n    decreases j - i,\n{\n    if (i == 0 && j == 0) || i == j {\n    } else if i == j - 1 {\n        lemma_sum_monotonic(i, (j - 1) as nat);\n    } else {\n        lemma_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nproof fn lemma_sum_to_n_closed_form(n: nat)\n    ensures\n        spec_sum_to_n(n) == (n * (n + 1)) / 2,\n    decreases n,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_sum_to_n(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else {\n        n + spec_sum_to_n((n - 1) as nat)\n    }\n}\n\nproof fn lemma_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_sum_to_n(i) <= spec_sum_to_n(j),\n    decreases j - i,\n{\n    if (i == 0 && j == 0) || i == j {\n    } else if i == j - 1 {\n        lemma_sum_monotonic(i, (j - 1) as nat);\n    } else {\n        lemma_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nproof fn lemma_sum_to_n_closed_form(n: nat)\n    ensures\n        spec_sum_to_n(n) == (n * (n + 1)) / 2,\n    decreases n,\n{\n    if n == 0 {\n    } else {\n        assert(spec_sum_to_n((n - 1) as nat) == ((n - 1) * n) / 2) by {\n            lemma_sum_to_n_closed_form((n - 1) as nat);\n        }\n        assert(n + (((n - 1) * n) / 2) == (n * (n + 1)) / 2) by (nonlinear_arith);\n    }\n}\n\nfn sum_to_n(n: u32) -> (sum: Option<u32>)\n    ensures\n        match sum {\n            None => spec_sum_to_n(n as nat) > u32::MAX,\n            Some(f) => f == spec_sum_to_n(n as nat),\n        },\n{\n    if n >= 92682 {\n        proof {\n            lemma_sum_to_n_closed_form(92682);\n            lemma_sum_monotonic(92682, n as nat);\n        }\n        return None;\n    }\n    let mut res: u32 = 0;\n    let mut sum: u32 = 0;\n    let mut i: u32 = 0;\n    while i < n\n        invariant\n            i <= n < 92682,\n            res == spec_sum_to_n(i as nat),\n            res <= u32::MAX,\n    {\n        i += 1;\n        proof {\n            // Prove that that n1 + n2 won't overflow\n            lemma_sum_to_n_closed_form(92681);\n            lemma_sum_monotonic(i as nat, 92681);\n            lemma_sum_monotonic((i - 1) as nat, 92681);\n        }\n        res = i + res;\n    }\n    Some(res)\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn spec_sum_to_n(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else {\n        n + spec_sum_to_n((n - 1) as nat)\n    }\n}\n\nproof fn lemma_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_sum_to_n(i) <= spec_sum_to_n(j),\n    decreases j - i,\n{\n    if (i == 0 && j == 0) || i == j {\n    } else if i == j - 1 {\n        lemma_sum_monotonic(i, (j - 1) as nat);\n    } else {\n        lemma_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nproof fn lemma_sum_to_n_closed_form(n: nat)\n    ensures\n        spec_sum_to_n(n) == (n * (n + 1)) / 2,\n    decreases n,\n{\n    if n == 0 {\n    } else {\n        assert(spec_sum_to_n((n - 1) as nat) == ((n - 1) * n) / 2) by {\n            lemma_sum_to_n_closed_form((n - 1) as nat);\n        }\n        assert(n + (((n - 1) * n) / 2) == (n * (n + 1)) / 2) by (nonlinear_arith);\n    }\n}\n\nfn sum_to_n(n: u32) -> (sum: Option<u32>)\n    ensures\n        match sum {\n            None => spec_sum_to_n(n as nat) > u32::MAX,\n            Some(f) => f == spec_sum_to_n(n as nat),\n        },\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n// say the return value is (x, b), x = number of '(' - number of ')', b = whether x ever dipped below 0\nspec fn spec_bracketing_helper(brackets: Seq<char>) -> (int, bool) {\n    brackets.fold_left(\n        (0, true),\n        |p: (int, bool), c|\n            {\n                let (x, b) = p;\n                match (c) {\n                    '(' => (x + 1, b),\n                    ')' => (x - 1, b && x - 1 >= 0),\n                    _ => (x, b),\n                }\n            },\n    )\n}\n\nspec fn spec_bracketing(brackets: Seq<char>) -> bool {\n    let p = spec_bracketing_helper(brackets);\n    p.1 && p.0 == 0\n}\n\nfn correct_bracketing(brackets: &str) -> (ret: bool)\n    requires\n        brackets@.len() <= i32::MAX,\n        -brackets@.len() >= i32::MIN,\n    ensures\n        ret <==> spec_bracketing(brackets@),\n{\n    let mut i = 0;\n    let mut b = true;\n    let mut stack_size: i32 = 0;\n\n    while i < brackets.unicode_len()\n        invariant\n            (stack_size as int, b) == spec_bracketing_helper(brackets@.subrange(0, i as int)),\n            stack_size <= i <= brackets@.len() <= i32::MAX,\n            stack_size >= -i >= -brackets@.len() >= i32::MIN,\n    {\n        let c = brackets.get_char(i);\n        let ghost prev = spec_bracketing_helper(brackets@.subrange(0, i as int));\n        if (c == '(') {\n            stack_size += 1;\n        } else if (c == ')') {\n            b = b && stack_size > 0;\n            stack_size -= 1;\n        }\n        assert(brackets@.subrange(0, i + 1 as int).drop_last() =~= brackets@.subrange(0, i as int));\n        i += 1;\n    }\n    assert(brackets@ =~= brackets@.subrange(0, i as int));\n    b && stack_size == 0\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n// say the return value is (x, b), x = number of '(' - number of ')', b = whether x ever dipped below 0\nspec fn spec_bracketing_helper(brackets: Seq<char>) -> (int, bool) {\n    brackets.fold_left(\n        (0, true),\n        |p: (int, bool), c|\n            {\n                let (x, b) = p;\n                match (c) {\n                    '(' => (x + 1, b),\n                    ')' => (x - 1, b && x - 1 >= 0),\n                    _ => (x, b),\n                }\n            },\n    )\n}\n\nspec fn spec_bracketing(brackets: Seq<char>) -> bool {\n    let p = spec_bracketing_helper(brackets);\n    p.1 && p.0 == 0\n}\n\nfn correct_bracketing(brackets: &str) -> (ret: bool)\n    requires\n        brackets@.len() <= i32::MAX,\n        -brackets@.len() >= i32::MIN,\n    ensures\n        ret <==> spec_bracketing(brackets@),\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn derivative(xs: &Vec<u32>) -> (ret: Vec<u64>)\n    requires\n        xs.len() <= u32::MAX,\n    ensures\n        if xs.len() == 0 {\n            ret.len() == 0\n        } else {\n            ret@.map_values(|x| x as int) =~= xs@.map(|i: int, x| i * x).skip(1)\n        },\n{\n    let mut ret = Vec::new();\n    if xs.len() == 0 {\n        return ret;\n    }\n    let mut i = 1;\n    while i < xs.len()\n        invariant\n            xs@.map(|i: int, x| i * x).subrange(1, i as int) =~= ret@.map_values(|x| x as int),\n            1 <= i <= xs.len() <= u32::MAX,\n    {\n        proof {\n            // Prove that the multiplication does not overflow\n            vstd::arithmetic::mul::lemma_mul_upper_bound(\n                xs[i as int] as int,\n                u32::MAX as int,\n                i as int,\n                u32::MAX as int,\n            );\n            assert(u32::MAX * u32::MAX <= u64::MAX);\n            assert((i as u64) * (xs[i as int] as u64) == i as int * xs[i as int]);\n        }\n        ret.push((i as u64) * (xs[i] as u64));\n\n        let ghost prods = xs@.map(|i: int, x| i * x);\n        assert(prods.subrange(1, i as int).push(prods.index(i as int)) =~= prods.subrange(\n            1,\n            i + 1 as int,\n        ));\n\n        i += 1;\n    }\n    assert(xs@.map(|i: int, x| i * x).subrange(1, i as int) =~= xs@.map(|i: int, x| i * x).skip(1));\n    ret\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn derivative(xs: &Vec<u32>) -> (ret: Vec<u64>)\n    requires\n        xs.len() <= u32::MAX,\n    ensures\n        if xs.len() == 0 {\n            ret.len() == 0\n        } else {\n            ret@.map_values(|x| x as int) =~= xs@.map(|i: int, x| i * x).skip(1)\n        },\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::memoize]\nspec fn spec_fibfib(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        0\n    } else if (n == 2) {\n        1\n    } else {\n        spec_fibfib((n - 1) as nat) + spec_fibfib((n - 2) as nat) + spec_fibfib((n - 3) as nat)\n    }\n}\n\nproof fn lemma_fibfib_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_fibfib(i) <= spec_fibfib(j),\n    decreases j - i,\n{\n    if (i < 3 && j < 3) || i == j {\n    } else if i == j - 1 {\n        reveal_with_fuel(spec_fibfib, 3);\n        lemma_fibfib_monotonic(i, (j - 1) as nat);\n    } else if i == j - 2 {\n        reveal_with_fuel(spec_fibfib, 3);\n        lemma_fibfib_monotonic(i, (j - 1) as nat);\n        lemma_fibfib_monotonic(i, (j - 2) as nat);\n    } else {\n        lemma_fibfib_monotonic(i, (j - 1) as nat);\n        lemma_fibfib_monotonic(i, (j - 2) as nat);\n        lemma_fibfib_monotonic(i, (j - 3) as nat);\n    }\n}\n\nfn fibfib(x: u32) -> (ret: Option<u32>)\n    ensures\n        match ret {\n            None => spec_fibfib(x as nat) > u32::MAX,\n            Some(f) => f == spec_fibfib(x as nat),\n        },\n{\n    if x > 39 {\n        proof {\n            assert(spec_fibfib(40) > u32::MAX) by (compute_only);\n            lemma_fibfib_monotonic(40, x as nat);\n        }\n        return None;\n    }\n    match (x) {\n        0 => Some(0),\n        1 => Some(0),\n        2 => Some(1),\n        _ => {\n            proof {\n                // Prove that the recursive calls below succeed,\n                // and that the additions won't overflow\n                assert(spec_fibfib(39) < u32::MAX) by (compute_only);\n                lemma_fibfib_monotonic(x as nat, 39);\n                lemma_fibfib_monotonic((x - 1) as nat, 39);\n                lemma_fibfib_monotonic((x - 2) as nat, 39);\n                lemma_fibfib_monotonic((x - 3) as nat, 39);\n            }\n            Some(fibfib(x - 1)? + fibfib(x - 2)? + fibfib(x - 3)?)\n        },\n    }\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::memoize]\nspec fn spec_fibfib(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        0\n    } else if (n == 2) {\n        1\n    } else {\n        spec_fibfib((n - 1) as nat) + spec_fibfib((n - 2) as nat) + spec_fibfib((n - 3) as nat)\n    }\n}\n\nproof fn lemma_fibfib_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_fibfib(i) <= spec_fibfib(j),\n    decreases j - i,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::memoize]\nspec fn spec_fibfib(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        0\n    } else if (n == 2) {\n        1\n    } else {\n        spec_fibfib((n - 1) as nat) + spec_fibfib((n - 2) as nat) + spec_fibfib((n - 3) as nat)\n    }\n}\n\nproof fn lemma_fibfib_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_fibfib(i) <= spec_fibfib(j),\n    decreases j - i,\n{\n    if (i < 3 && j < 3) || i == j {\n    } else if i == j - 1 {\n        reveal_with_fuel(spec_fibfib, 3);\n        lemma_fibfib_monotonic(i, (j - 1) as nat);\n    } else if i == j - 2 {\n        reveal_with_fuel(spec_fibfib, 3);\n        lemma_fibfib_monotonic(i, (j - 1) as nat);\n        lemma_fibfib_monotonic(i, (j - 2) as nat);\n    } else {\n        lemma_fibfib_monotonic(i, (j - 1) as nat);\n        lemma_fibfib_monotonic(i, (j - 2) as nat);\n        lemma_fibfib_monotonic(i, (j - 3) as nat);\n    }\n}\n\nfn fibfib(x: u32) -> (ret: Option<u32>)\n    ensures\n        match ret {\n            None => spec_fibfib(x as nat) > u32::MAX,\n            Some(f) => f == spec_fibfib(x as nat),\n        },\n{\n    if x > 39 {\n        proof {\n            assert(spec_fibfib(40) > u32::MAX) by (compute_only);\n            lemma_fibfib_monotonic(40, x as nat);\n        }\n        return None;\n    }\n    match (x) {\n        0 => Some(0),\n        1 => Some(0),\n        2 => Some(1),\n        _ => {\n            proof {\n                // Prove that the recursive calls below succeed,\n                // and that the additions won't overflow\n                assert(spec_fibfib(39) < u32::MAX) by (compute_only);\n                lemma_fibfib_monotonic(x as nat, 39);\n                lemma_fibfib_monotonic((x - 1) as nat, 39);\n                lemma_fibfib_monotonic((x - 2) as nat, 39);\n                lemma_fibfib_monotonic((x - 3) as nat, 39);\n            }\n            Some(fibfib(x - 1)? + fibfib(x - 2)? + fibfib(x - 3)?)\n        },\n    }\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::memoize]\nspec fn spec_fibfib(n: nat) -> nat\n    decreases n,\n{\n    if (n == 0) {\n        0\n    } else if (n == 1) {\n        0\n    } else if (n == 2) {\n        1\n    } else {\n        spec_fibfib((n - 1) as nat) + spec_fibfib((n - 2) as nat) + spec_fibfib((n - 3) as nat)\n    }\n}\n\nproof fn lemma_fibfib_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        spec_fibfib(i) <= spec_fibfib(j),\n    decreases j - i,\n{\n    if (i < 3 && j < 3) || i == j {\n    } else if i == j - 1 {\n        reveal_with_fuel(spec_fibfib, 3);\n        lemma_fibfib_monotonic(i, (j - 1) as nat);\n    } else if i == j - 2 {\n        reveal_with_fuel(spec_fibfib, 3);\n        lemma_fibfib_monotonic(i, (j - 1) as nat);\n        lemma_fibfib_monotonic(i, (j - 2) as nat);\n    } else {\n        lemma_fibfib_monotonic(i, (j - 1) as nat);\n        lemma_fibfib_monotonic(i, (j - 2) as nat);\n        lemma_fibfib_monotonic(i, (j - 3) as nat);\n    }\n}\n\nfn fibfib(x: u32) -> (ret: Option<u32>)\n    ensures\n        match ret {\n            None => spec_fibfib(x as nat) > u32::MAX,\n            Some(f) => f == spec_fibfib(x as nat),\n        },\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_vowel(c: char) -> bool {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\n        || c == 'O' || c == 'U'\n}\n\nspec fn vowels(s: Seq<char>) -> Seq<char> {\n    s.filter(|c| is_vowel(c))\n}\n\nfn vowels_count(s: &str) -> (ret: u32)\n    requires\n        s@.len() <= u32::MAX,\n    ensures\n        ret == vowels(s@).len() + if (s@.len() > 0 && (s@.last() == 'y' || s@.last() == 'Y')) {\n            1int  // add 1 if the last letter is 'y'\n\n        } else {\n            0int\n        },\n{\n    let mut ctr = 0;\n    let len = s.unicode_len();\n    if len == 0 {\n        return ctr;\n    }\n    assert(len > 0);\n    let mut i = 0;\n    for i in 0..len\n        invariant\n            ctr == vowels(s@.subrange(0, i as int)).len(),\n            ctr <= i <= s@.len() == len <= u32::MAX,\n            ctr < u32::MAX || is_vowel(s@.last()),\n    {\n        let c = s.get_char(i);\n        reveal_with_fuel(Seq::filter, 2);\n        assert(s@.subrange(0, i + 1 as int).drop_last() =~= s@.subrange(0, i as int));\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c\n            == 'I' || c == 'O' || c == 'U') {\n            ctr += 1;\n        }\n    }\n    assert(ctr == vowels(s@).len()) by {\n        assert(s@.subrange(0, len as int) =~= s@);\n    }\n    let c = s.get_char(len - 1);\n    if (c == 'y' || c == 'Y') {\n        ctr += 1\n    }\n    ctr\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_vowel(c: char) -> bool {\n    c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\n        || c == 'O' || c == 'U'\n}\n\nspec fn vowels(s: Seq<char>) -> Seq<char> {\n    s.filter(|c| is_vowel(c))\n}\n\nfn vowels_count(s: &str) -> (ret: u32)\n    requires\n        s@.len() <= u32::MAX,\n    ensures\n        ret == vowels(s@).len() + if (s@.len() > 0 && (s@.last() == 'y' || s@.last() == 'Y')) {\n            1int  // add 1 if the last letter is 'y'\n\n        } else {\n            0int\n        },\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_upper_case(c: char) -> bool {\n    c >= 'A' && c <= 'Z'\n}\n\n// This spec function computes uppercase character (i.e, ASCII code) sum.\nspec fn count_uppercase_sum(seq: Seq<char>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_uppercase_sum(seq.drop_last()) + if is_upper_case(seq.last()) {\n            seq.last() as int\n        } else {\n            0 as int\n        }\n    }\n}\n\n// This function takes a string as input and returns the sum of the upper characters only'\nfn digit_sum(text: &[char]) -> (sum: u128)\n    ensures\n        count_uppercase_sum(text@) == sum,\n{\n    let mut index = 0;\n    let mut sum = 0u128;\n\n    while index < text.len()\n        invariant\n            0 <= index <= text.len(),\n            count_uppercase_sum(text@.subrange(0, index as int)) == sum,\n            forall|j: int|\n                0 <= j <= index ==> (u64::MIN * index <= (count_uppercase_sum(\n                    #[trigger] text@.subrange(0, j),\n                )) <= u64::MAX * index),\n            u64::MIN * index <= sum <= u64::MAX * index,\n    {\n        if (text[index] >= 'A' && text[index] <= 'Z') {\n            assert(text@.subrange(0, index as int) =~= text@.subrange(\n                0,\n                (index + 1) as int,\n            ).drop_last());\n            sum = sum + text[index] as u128;\n        }\n        index += 1;\n        assert(text@.subrange(0, index - 1 as int) == text@.subrange(0, index as int).drop_last());\n\n    }\n    assert(index == text@.len());\n    assert(text@ == text@.subrange(0, index as int));\n    sum\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_upper_case(c: char) -> bool {\n    c >= 'A' && c <= 'Z'\n}\n\n// This spec function computes uppercase character (i.e, ASCII code) sum.\nspec fn count_uppercase_sum(seq: Seq<char>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_uppercase_sum(seq.drop_last()) + if is_upper_case(seq.last()) {\n            seq.last() as int\n        } else {\n            0 as int\n        }\n    }\n}\n\n// This function takes a string as input and returns the sum of the upper characters only'\nfn digit_sum(text: &[char]) -> (sum: u128)\n    ensures\n        count_uppercase_sum(text@) == sum,\n{"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_divisible(n: int, divisor: int) -> bool {\n    (n % divisor) == 0\n}\n\npub open spec fn is_prime(n: int) -> bool {\n    if n < 2 {\n        false\n    } else {\n        (forall|k: int| 2 <= k < n ==> !is_divisible(n as int, k))\n    }\n}\n\n// Implementation following the ground-truth\n// This function checks whether a given string length is prime\nfn prime_length(str: &[char]) -> (result: bool)\n    ensures\n        result == is_prime(str.len() as int),\n{\n    if str.len() < 2 {\n        return false;\n    }\n    for index in 2..str.len()\n        invariant\n            2 <= index <= str.len(),\n            forall|k: int| 2 <= k < index ==> !is_divisible(str.len() as int, k),\n    {\n        if ((str.len() % index) == 0) {\n            assert(is_divisible(str.len() as int, index as int));\n            return false;\n        }\n    }\n    true\n}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn is_divisible(n: int, divisor: int) -> bool {\n    (n % divisor) == 0\n}\n\npub open spec fn is_prime(n: int) -> bool {\n    if n < 2 {\n        false\n    } else {\n        (forall|k: int| 2 <= k < n ==> !is_divisible(n as int, k))\n    }\n}\n\n// Implementation following the ground-truth\n// This function checks whether a given string length is prime\nfn prime_length(str: &[char]) -> (result: bool)\n    ensures\n        result == is_prime(str.len() as int),\n{"}
{"y": "use vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        1\n    } else {\n        n * factorial((n - 1) as nat)\n    }\n}\n\npub closed spec fn brazilian_factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        factorial(1)\n    } else {\n        factorial(n) * brazilian_factorial((n - 1) as nat)\n    }\n}\n\nproof fn lemma_factorial_positive(n: nat)\n    ensures\n        factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n - 1) as nat);\n        assert(factorial(n) >= 1) by {\n            broadcast use lemma_mul_strictly_positive;\n\n        };\n    }\n}\n\nproof fn lemma_brazilian_factorial_positive(n: nat)\n    ensures\n        brazilian_factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n) as nat);\n        lemma_brazilian_factorial_positive((n - 1) as nat);\n        assert(brazilian_factorial(n) >= 1) by {\n            lemma_mul_strictly_positive(\n                factorial(n) as int,\n                brazilian_factorial((n - 1) as nat) as int,\n            )\n        };\n    }\n}\n\nproof fn lemma_brazilian_fib_monotonic(i: nat, j: nat)\n    requires\n        0 <= i <= j,\n    ensures\n        brazilian_factorial(i) <= brazilian_factorial(j),\n    decreases j - i,\n{\n    if (i == j) {\n    } else if (j == i + 1) {\n        assert(factorial(j) >= 1) by { lemma_factorial_positive(j) };\n        assert(brazilian_factorial(j) >= brazilian_factorial(i)) by {\n            broadcast use lemma_mul_increases;\n\n        };\n    } else {\n        lemma_brazilian_fib_monotonic(i, (j - 1) as nat);\n        lemma_brazilian_fib_monotonic((j - 1) as nat, j);\n    }\n}\n\npub fn brazilian_factorial_impl(n: u64) -> (ret: Option<u64>)\n    ensures\n        match ret {\n            None => brazilian_factorial(n as nat) > u64::MAX,\n            Some(bf) => bf == brazilian_factorial(n as nat),\n        },\n{\n    if n >= 9 {\n        assert(brazilian_factorial(9nat) > u64::MAX) by (compute_only);\n        assert(brazilian_factorial(n as nat) >= brazilian_factorial(9nat)) by {\n            lemma_brazilian_fib_monotonic(9nat, n as nat)\n        };\n        return None;\n    }\n    let mut start = 1u64;\n    let mut end = n + 1u64;\n    let mut fact_i = 1u64;\n    let mut special_fact = 1u64;\n\n    while start < end\n        invariant\n            brazilian_factorial((start - 1) as nat) == special_fact,\n            factorial((start - 1) as nat) == fact_i,\n            1 <= start <= end < 10,\n        decreases (end - start),\n    {\n        assert(brazilian_factorial(start as nat) <= brazilian_factorial(8nat)) by {\n            lemma_brazilian_fib_monotonic(start as nat, 8nat)\n        };\n        assert(brazilian_factorial(8nat) < u64::MAX) by (compute_only);\n\n        assert(brazilian_factorial((start - 1) as nat) >= 1) by {\n            lemma_brazilian_factorial_positive((start - 1) as nat)\n        };\n        assert(factorial(start as nat) <= brazilian_factorial(start as nat)) by {\n            broadcast use lemma_mul_ordering;\n\n        };\n\n        fact_i = start * fact_i;\n\n        special_fact = fact_i * special_fact;\n\n        start = start + 1;\n    }\n    return Some(special_fact);\n\n}\n\n} // verus!\nfn main() {\n    println!(\"{:?}\", brazilian_factorial_impl(4));\n    // > 288\n    println!(\"{:?}\", brazilian_factorial_impl(6));\n    // > 24883200\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nspecial_factorial\n*/\n\n/*\n### CANONICAL SOLUTION\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n\n*/\n\n/*\n### TEST\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n\n*/", "x": "use vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        1\n    } else {\n        n * factorial((n - 1) as nat)\n    }\n}\n\npub closed spec fn brazilian_factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        factorial(1)\n    } else {\n        factorial(n) * brazilian_factorial((n - 1) as nat)\n    }\n}\n\nproof fn lemma_factorial_positive(n: nat)\n    ensures\n        factorial(n) >= 1,\n    decreases n,\n{"}
{"y": "use vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        1\n    } else {\n        n * factorial((n - 1) as nat)\n    }\n}\n\npub closed spec fn brazilian_factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        factorial(1)\n    } else {\n        factorial(n) * brazilian_factorial((n - 1) as nat)\n    }\n}\n\nproof fn lemma_factorial_positive(n: nat)\n    ensures\n        factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n - 1) as nat);\n        assert(factorial(n) >= 1) by {\n            broadcast use lemma_mul_strictly_positive;\n\n        };\n    }\n}\n\nproof fn lemma_brazilian_factorial_positive(n: nat)\n    ensures\n        brazilian_factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n) as nat);\n        lemma_brazilian_factorial_positive((n - 1) as nat);\n        assert(brazilian_factorial(n) >= 1) by {\n            lemma_mul_strictly_positive(\n                factorial(n) as int,\n                brazilian_factorial((n - 1) as nat) as int,\n            )\n        };\n    }\n}\n\nproof fn lemma_brazilian_fib_monotonic(i: nat, j: nat)\n    requires\n        0 <= i <= j,\n    ensures\n        brazilian_factorial(i) <= brazilian_factorial(j),\n    decreases j - i,\n{\n    if (i == j) {\n    } else if (j == i + 1) {\n        assert(factorial(j) >= 1) by { lemma_factorial_positive(j) };\n        assert(brazilian_factorial(j) >= brazilian_factorial(i)) by {\n            broadcast use lemma_mul_increases;\n\n        };\n    } else {\n        lemma_brazilian_fib_monotonic(i, (j - 1) as nat);\n        lemma_brazilian_fib_monotonic((j - 1) as nat, j);\n    }\n}\n\npub fn brazilian_factorial_impl(n: u64) -> (ret: Option<u64>)\n    ensures\n        match ret {\n            None => brazilian_factorial(n as nat) > u64::MAX,\n            Some(bf) => bf == brazilian_factorial(n as nat),\n        },\n{\n    if n >= 9 {\n        assert(brazilian_factorial(9nat) > u64::MAX) by (compute_only);\n        assert(brazilian_factorial(n as nat) >= brazilian_factorial(9nat)) by {\n            lemma_brazilian_fib_monotonic(9nat, n as nat)\n        };\n        return None;\n    }\n    let mut start = 1u64;\n    let mut end = n + 1u64;\n    let mut fact_i = 1u64;\n    let mut special_fact = 1u64;\n\n    while start < end\n        invariant\n            brazilian_factorial((start - 1) as nat) == special_fact,\n            factorial((start - 1) as nat) == fact_i,\n            1 <= start <= end < 10,\n        decreases (end - start),\n    {\n        assert(brazilian_factorial(start as nat) <= brazilian_factorial(8nat)) by {\n            lemma_brazilian_fib_monotonic(start as nat, 8nat)\n        };\n        assert(brazilian_factorial(8nat) < u64::MAX) by (compute_only);\n\n        assert(brazilian_factorial((start - 1) as nat) >= 1) by {\n            lemma_brazilian_factorial_positive((start - 1) as nat)\n        };\n        assert(factorial(start as nat) <= brazilian_factorial(start as nat)) by {\n            broadcast use lemma_mul_ordering;\n\n        };\n\n        fact_i = start * fact_i;\n\n        special_fact = fact_i * special_fact;\n\n        start = start + 1;\n    }\n    return Some(special_fact);\n\n}\n\n} // verus!\nfn main() {\n    println!(\"{:?}\", brazilian_factorial_impl(4));\n    // > 288\n    println!(\"{:?}\", brazilian_factorial_impl(6));\n    // > 24883200\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nspecial_factorial\n*/\n\n/*\n### CANONICAL SOLUTION\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n\n*/\n\n/*\n### TEST\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n\n*/", "x": "use vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        1\n    } else {\n        n * factorial((n - 1) as nat)\n    }\n}\n\npub closed spec fn brazilian_factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        factorial(1)\n    } else {\n        factorial(n) * brazilian_factorial((n - 1) as nat)\n    }\n}\n\nproof fn lemma_factorial_positive(n: nat)\n    ensures\n        factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n - 1) as nat);\n        assert(factorial(n) >= 1) by {\n            broadcast use lemma_mul_strictly_positive;\n\n        };\n    }\n}\n\nproof fn lemma_brazilian_factorial_positive(n: nat)\n    ensures\n        brazilian_factorial(n) >= 1,\n    decreases n,\n{"}
{"y": "use vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        1\n    } else {\n        n * factorial((n - 1) as nat)\n    }\n}\n\npub closed spec fn brazilian_factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        factorial(1)\n    } else {\n        factorial(n) * brazilian_factorial((n - 1) as nat)\n    }\n}\n\nproof fn lemma_factorial_positive(n: nat)\n    ensures\n        factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n - 1) as nat);\n        assert(factorial(n) >= 1) by {\n            broadcast use lemma_mul_strictly_positive;\n\n        };\n    }\n}\n\nproof fn lemma_brazilian_factorial_positive(n: nat)\n    ensures\n        brazilian_factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n) as nat);\n        lemma_brazilian_factorial_positive((n - 1) as nat);\n        assert(brazilian_factorial(n) >= 1) by {\n            lemma_mul_strictly_positive(\n                factorial(n) as int,\n                brazilian_factorial((n - 1) as nat) as int,\n            )\n        };\n    }\n}\n\nproof fn lemma_brazilian_fib_monotonic(i: nat, j: nat)\n    requires\n        0 <= i <= j,\n    ensures\n        brazilian_factorial(i) <= brazilian_factorial(j),\n    decreases j - i,\n{\n    if (i == j) {\n    } else if (j == i + 1) {\n        assert(factorial(j) >= 1) by { lemma_factorial_positive(j) };\n        assert(brazilian_factorial(j) >= brazilian_factorial(i)) by {\n            broadcast use lemma_mul_increases;\n\n        };\n    } else {\n        lemma_brazilian_fib_monotonic(i, (j - 1) as nat);\n        lemma_brazilian_fib_monotonic((j - 1) as nat, j);\n    }\n}\n\npub fn brazilian_factorial_impl(n: u64) -> (ret: Option<u64>)\n    ensures\n        match ret {\n            None => brazilian_factorial(n as nat) > u64::MAX,\n            Some(bf) => bf == brazilian_factorial(n as nat),\n        },\n{\n    if n >= 9 {\n        assert(brazilian_factorial(9nat) > u64::MAX) by (compute_only);\n        assert(brazilian_factorial(n as nat) >= brazilian_factorial(9nat)) by {\n            lemma_brazilian_fib_monotonic(9nat, n as nat)\n        };\n        return None;\n    }\n    let mut start = 1u64;\n    let mut end = n + 1u64;\n    let mut fact_i = 1u64;\n    let mut special_fact = 1u64;\n\n    while start < end\n        invariant\n            brazilian_factorial((start - 1) as nat) == special_fact,\n            factorial((start - 1) as nat) == fact_i,\n            1 <= start <= end < 10,\n        decreases (end - start),\n    {\n        assert(brazilian_factorial(start as nat) <= brazilian_factorial(8nat)) by {\n            lemma_brazilian_fib_monotonic(start as nat, 8nat)\n        };\n        assert(brazilian_factorial(8nat) < u64::MAX) by (compute_only);\n\n        assert(brazilian_factorial((start - 1) as nat) >= 1) by {\n            lemma_brazilian_factorial_positive((start - 1) as nat)\n        };\n        assert(factorial(start as nat) <= brazilian_factorial(start as nat)) by {\n            broadcast use lemma_mul_ordering;\n\n        };\n\n        fact_i = start * fact_i;\n\n        special_fact = fact_i * special_fact;\n\n        start = start + 1;\n    }\n    return Some(special_fact);\n\n}\n\n} // verus!\nfn main() {\n    println!(\"{:?}\", brazilian_factorial_impl(4));\n    // > 288\n    println!(\"{:?}\", brazilian_factorial_impl(6));\n    // > 24883200\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nspecial_factorial\n*/\n\n/*\n### CANONICAL SOLUTION\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n\n*/\n\n/*\n### TEST\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n\n*/", "x": "use vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        1\n    } else {\n        n * factorial((n - 1) as nat)\n    }\n}\n\npub closed spec fn brazilian_factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        factorial(1)\n    } else {\n        factorial(n) * brazilian_factorial((n - 1) as nat)\n    }\n}\n\nproof fn lemma_factorial_positive(n: nat)\n    ensures\n        factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n - 1) as nat);\n        assert(factorial(n) >= 1) by {\n            broadcast use lemma_mul_strictly_positive;\n\n        };\n    }\n}\n\nproof fn lemma_brazilian_factorial_positive(n: nat)\n    ensures\n        brazilian_factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n) as nat);\n        lemma_brazilian_factorial_positive((n - 1) as nat);\n        assert(brazilian_factorial(n) >= 1) by {\n            lemma_mul_strictly_positive(\n                factorial(n) as int,\n                brazilian_factorial((n - 1) as nat) as int,\n            )\n        };\n    }\n}\n\nproof fn lemma_brazilian_fib_monotonic(i: nat, j: nat)\n    requires\n        0 <= i <= j,\n    ensures\n        brazilian_factorial(i) <= brazilian_factorial(j),\n    decreases j - i,\n{"}
{"y": "use vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        1\n    } else {\n        n * factorial((n - 1) as nat)\n    }\n}\n\npub closed spec fn brazilian_factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        factorial(1)\n    } else {\n        factorial(n) * brazilian_factorial((n - 1) as nat)\n    }\n}\n\nproof fn lemma_factorial_positive(n: nat)\n    ensures\n        factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n - 1) as nat);\n        assert(factorial(n) >= 1) by {\n            broadcast use lemma_mul_strictly_positive;\n\n        };\n    }\n}\n\nproof fn lemma_brazilian_factorial_positive(n: nat)\n    ensures\n        brazilian_factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n) as nat);\n        lemma_brazilian_factorial_positive((n - 1) as nat);\n        assert(brazilian_factorial(n) >= 1) by {\n            lemma_mul_strictly_positive(\n                factorial(n) as int,\n                brazilian_factorial((n - 1) as nat) as int,\n            )\n        };\n    }\n}\n\nproof fn lemma_brazilian_fib_monotonic(i: nat, j: nat)\n    requires\n        0 <= i <= j,\n    ensures\n        brazilian_factorial(i) <= brazilian_factorial(j),\n    decreases j - i,\n{\n    if (i == j) {\n    } else if (j == i + 1) {\n        assert(factorial(j) >= 1) by { lemma_factorial_positive(j) };\n        assert(brazilian_factorial(j) >= brazilian_factorial(i)) by {\n            broadcast use lemma_mul_increases;\n\n        };\n    } else {\n        lemma_brazilian_fib_monotonic(i, (j - 1) as nat);\n        lemma_brazilian_fib_monotonic((j - 1) as nat, j);\n    }\n}\n\npub fn brazilian_factorial_impl(n: u64) -> (ret: Option<u64>)\n    ensures\n        match ret {\n            None => brazilian_factorial(n as nat) > u64::MAX,\n            Some(bf) => bf == brazilian_factorial(n as nat),\n        },\n{\n    if n >= 9 {\n        assert(brazilian_factorial(9nat) > u64::MAX) by (compute_only);\n        assert(brazilian_factorial(n as nat) >= brazilian_factorial(9nat)) by {\n            lemma_brazilian_fib_monotonic(9nat, n as nat)\n        };\n        return None;\n    }\n    let mut start = 1u64;\n    let mut end = n + 1u64;\n    let mut fact_i = 1u64;\n    let mut special_fact = 1u64;\n\n    while start < end\n        invariant\n            brazilian_factorial((start - 1) as nat) == special_fact,\n            factorial((start - 1) as nat) == fact_i,\n            1 <= start <= end < 10,\n        decreases (end - start),\n    {\n        assert(brazilian_factorial(start as nat) <= brazilian_factorial(8nat)) by {\n            lemma_brazilian_fib_monotonic(start as nat, 8nat)\n        };\n        assert(brazilian_factorial(8nat) < u64::MAX) by (compute_only);\n\n        assert(brazilian_factorial((start - 1) as nat) >= 1) by {\n            lemma_brazilian_factorial_positive((start - 1) as nat)\n        };\n        assert(factorial(start as nat) <= brazilian_factorial(start as nat)) by {\n            broadcast use lemma_mul_ordering;\n\n        };\n\n        fact_i = start * fact_i;\n\n        special_fact = fact_i * special_fact;\n\n        start = start + 1;\n    }\n    return Some(special_fact);\n\n}\n\n} // verus!\nfn main() {\n    println!(\"{:?}\", brazilian_factorial_impl(4));\n    // > 288\n    println!(\"{:?}\", brazilian_factorial_impl(6));\n    // > 24883200\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nspecial_factorial\n*/\n\n/*\n### CANONICAL SOLUTION\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n\n*/\n\n/*\n### TEST\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n\n*/", "x": "use vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        1\n    } else {\n        n * factorial((n - 1) as nat)\n    }\n}\n\npub closed spec fn brazilian_factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        factorial(1)\n    } else {\n        factorial(n) * brazilian_factorial((n - 1) as nat)\n    }\n}\n\nproof fn lemma_factorial_positive(n: nat)\n    ensures\n        factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n - 1) as nat);\n        assert(factorial(n) >= 1) by {\n            broadcast use lemma_mul_strictly_positive;\n\n        };\n    }\n}\n\nproof fn lemma_brazilian_factorial_positive(n: nat)\n    ensures\n        brazilian_factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n) as nat);\n        lemma_brazilian_factorial_positive((n - 1) as nat);\n        assert(brazilian_factorial(n) >= 1) by {\n            lemma_mul_strictly_positive(\n                factorial(n) as int,\n                brazilian_factorial((n - 1) as nat) as int,\n            )\n        };\n    }\n}\n\nproof fn lemma_brazilian_fib_monotonic(i: nat, j: nat)\n    requires\n        0 <= i <= j,\n    ensures\n        brazilian_factorial(i) <= brazilian_factorial(j),\n    decreases j - i,\n{\n    if (i == j) {\n    } else if (j == i + 1) {\n        assert(factorial(j) >= 1) by { lemma_factorial_positive(j) };\n        assert(brazilian_factorial(j) >= brazilian_factorial(i)) by {\n            broadcast use lemma_mul_increases;\n\n        };\n    } else {\n        lemma_brazilian_fib_monotonic(i, (j - 1) as nat);\n        lemma_brazilian_fib_monotonic((j - 1) as nat, j);\n    }\n}\n\npub fn brazilian_factorial_impl(n: u64) -> (ret: Option<u64>)\n    ensures\n        match ret {\n            None => brazilian_factorial(n as nat) > u64::MAX,\n            Some(bf) => bf == brazilian_factorial(n as nat),\n        },\n{"}
{"y": "use vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        1\n    } else {\n        n * factorial((n - 1) as nat)\n    }\n}\n\npub closed spec fn brazilian_factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        factorial(1)\n    } else {\n        factorial(n) * brazilian_factorial((n - 1) as nat)\n    }\n}\n\nproof fn lemma_factorial_positive(n: nat)\n    ensures\n        factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n - 1) as nat);\n        assert(factorial(n) >= 1) by {\n            broadcast use lemma_mul_strictly_positive;\n\n        };\n    }\n}\n\nproof fn lemma_brazilian_factorial_positive(n: nat)\n    ensures\n        brazilian_factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n) as nat);\n        lemma_brazilian_factorial_positive((n - 1) as nat);\n        assert(brazilian_factorial(n) >= 1) by {\n            lemma_mul_strictly_positive(\n                factorial(n) as int,\n                brazilian_factorial((n - 1) as nat) as int,\n            )\n        };\n    }\n}\n\nproof fn lemma_brazilian_fib_monotonic(i: nat, j: nat)\n    requires\n        0 <= i <= j,\n    ensures\n        brazilian_factorial(i) <= brazilian_factorial(j),\n    decreases j - i,\n{\n    if (i == j) {\n    } else if (j == i + 1) {\n        assert(factorial(j) >= 1) by { lemma_factorial_positive(j) };\n        assert(brazilian_factorial(j) >= brazilian_factorial(i)) by {\n            broadcast use lemma_mul_increases;\n\n        };\n    } else {\n        lemma_brazilian_fib_monotonic(i, (j - 1) as nat);\n        lemma_brazilian_fib_monotonic((j - 1) as nat, j);\n    }\n}\n\npub fn brazilian_factorial_impl(n: u64) -> (ret: Option<u64>)\n    ensures\n        match ret {\n            None => brazilian_factorial(n as nat) > u64::MAX,\n            Some(bf) => bf == brazilian_factorial(n as nat),\n        },\n{\n    if n >= 9 {\n        assert(brazilian_factorial(9nat) > u64::MAX) by (compute_only);\n        assert(brazilian_factorial(n as nat) >= brazilian_factorial(9nat)) by {\n            lemma_brazilian_fib_monotonic(9nat, n as nat)\n        };\n        return None;\n    }\n    let mut start = 1u64;\n    let mut end = n + 1u64;\n    let mut fact_i = 1u64;\n    let mut special_fact = 1u64;\n\n    while start < end\n        invariant\n            brazilian_factorial((start - 1) as nat) == special_fact,\n            factorial((start - 1) as nat) == fact_i,\n            1 <= start <= end < 10,\n        decreases (end - start),\n    {\n        assert(brazilian_factorial(start as nat) <= brazilian_factorial(8nat)) by {\n            lemma_brazilian_fib_monotonic(start as nat, 8nat)\n        };\n        assert(brazilian_factorial(8nat) < u64::MAX) by (compute_only);\n\n        assert(brazilian_factorial((start - 1) as nat) >= 1) by {\n            lemma_brazilian_factorial_positive((start - 1) as nat)\n        };\n        assert(factorial(start as nat) <= brazilian_factorial(start as nat)) by {\n            broadcast use lemma_mul_ordering;\n\n        };\n\n        fact_i = start * fact_i;\n\n        special_fact = fact_i * special_fact;\n\n        start = start + 1;\n    }\n    return Some(special_fact);\n\n}\n\n} // verus!\nfn main() {\n    println!(\"{:?}\", brazilian_factorial_impl(4));\n    // > 288\n    println!(\"{:?}\", brazilian_factorial_impl(6));\n    // > 24883200\n}\n\n/*\n### VERUS END\n*/\n\n/*\n### PROMPT\n\ndef special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n\n*/\n\n/*\n### ENTRY POINT\nspecial_factorial\n*/\n\n/*\n### CANONICAL SOLUTION\n    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n\n*/\n\n/*\n### TEST\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n\n*/", "x": "use vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// specification\npub closed spec fn factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        1\n    } else {\n        n * factorial((n - 1) as nat)\n    }\n}\n\npub closed spec fn brazilian_factorial(n: nat) -> nat\n    decreases n,\n{\n    if n <= 1 {\n        factorial(1)\n    } else {\n        factorial(n) * brazilian_factorial((n - 1) as nat)\n    }\n}\n\nproof fn lemma_factorial_positive(n: nat)\n    ensures\n        factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n - 1) as nat);\n        assert(factorial(n) >= 1) by {\n            broadcast use lemma_mul_strictly_positive;\n\n        };\n    }\n}\n\nproof fn lemma_brazilian_factorial_positive(n: nat)\n    ensures\n        brazilian_factorial(n) >= 1,\n    decreases n,\n{\n    if (n == 0) {\n    } else {\n        lemma_factorial_positive((n) as nat);\n        lemma_brazilian_factorial_positive((n - 1) as nat);\n        assert(brazilian_factorial(n) >= 1) by {\n            lemma_mul_strictly_positive(\n                factorial(n) as int,\n                brazilian_factorial((n - 1) as nat) as int,\n            )\n        };\n    }\n}\n\nproof fn lemma_brazilian_fib_monotonic(i: nat, j: nat)\n    requires\n        0 <= i <= j,\n    ensures\n        brazilian_factorial(i) <= brazilian_factorial(j),\n    decreases j - i,\n{\n    if (i == j) {\n    } else if (j == i + 1) {\n        assert(factorial(j) >= 1) by { lemma_factorial_positive(j) };\n        assert(brazilian_factorial(j) >= brazilian_factorial(i)) by {\n            broadcast use lemma_mul_increases;\n\n        };\n    } else {\n        lemma_brazilian_fib_monotonic(i, (j - 1) as nat);\n        lemma_brazilian_fib_monotonic((j - 1) as nat, j);\n    }\n}\n\npub fn brazilian_factorial_impl(n: u64) -> (ret: Option<u64>)\n    ensures\n        match ret {\n            None => brazilian_factorial(n as nat) > u64::MAX,\n            Some(bf) => bf == brazilian_factorial(n as nat),\n        },\n{\n    if n >= 9 {\n        assert(brazilian_factorial(9nat) > u64::MAX) by (compute_only);\n        assert(brazilian_factorial(n as nat) >= brazilian_factorial(9nat)) by {\n            lemma_brazilian_fib_monotonic(9nat, n as nat)\n        };\n        return None;\n    }\n    let mut start = 1u64;\n    let mut end = n + 1u64;\n    let mut fact_i = 1u64;\n    let mut special_fact = 1u64;\n\n    while start < end\n        invariant\n            brazilian_factorial((start - 1) as nat) == special_fact,\n            factorial((start - 1) as nat) == fact_i,\n            1 <= start <= end < 10,\n        decreases (end - start),\n    {\n        assert(brazilian_factorial(start as nat) <= brazilian_factorial(8nat)) by {\n            lemma_brazilian_fib_monotonic(start as nat, 8nat)\n        };\n        assert(brazilian_factorial(8nat) < u64::MAX) by (compute_only);\n\n        assert(brazilian_factorial((start - 1) as nat) >= 1) by {\n            lemma_brazilian_factorial_positive((start - 1) as nat)\n        };\n        assert(factorial(start as nat) <= brazilian_factorial(start as nat)) by {\n            broadcast use lemma_mul_ordering;\n\n        };\n\n        fact_i = start * fact_i;\n\n        special_fact = fact_i * special_fact;\n\n        start = start + 1;\n    }\n    return Some(special_fact);\n\n}\n\n} // verus!\nf"}
