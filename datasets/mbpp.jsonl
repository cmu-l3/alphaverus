{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn is_greater(arr: &Vec<i32>, number: i32) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < arr.len() ==> number > arr[i]),\n{\n    let mut i = 0;\n    while i < arr.len()\n        invariant\n            0 <= i <= arr.len(),\n            forall|k: int| 0 <= k < i ==> number > arr[k],\n    {\n        if number <= arr[i] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn is_greater(arr: &Vec<i32>, number: i32) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < arr.len() ==> number > arr[i]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut i = 0;\n    while i < arr.len()\n        invariant\n            forall|m: int| 0 <= m < i ==> (arr[m] != key),\n    {\n        if (arr[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn intersection(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < result.len() ==> (arr1@.contains(#[trigger] result[i]) && arr2@.contains(\n                #[trigger] result[i],\n            )),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j],\n{\n    let mut output_arr = Vec::new();\n    let ghost mut out_arr_len: int = 0;\n\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            forall|i: int|\n                0 <= i < output_arr.len() ==> (arr1@.contains(#[trigger] output_arr[i])\n                    && arr2@.contains(#[trigger] output_arr[i])),\n            forall|m: int, n: int| 0 <= m < n < output_arr.len() ==> output_arr[m] != output_arr[n],\n    {\n        if (contains(arr2, arr1[index]) && !contains(&output_arr, arr1[index])) {\n            output_arr.push(arr1[index]);\n            proof {\n                out_arr_len = out_arr_len + 1;\n            }\n        }\n        index += 1;\n    }\n    output_arr\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut i = 0;\n    while i < arr.len()\n        invariant\n            forall|m: int| 0 <= m < i ==> (arr[m] != key),\n    {\n        if (arr[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn intersection(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < result.len() ==> (arr1@.contains(#[trigger] result[i]) && arr2@.contains(\n                #[trigger] result[i],\n            )),\n        forall|i: int, j: int| 0 <= i < j < result.len() ==> result[i] != result[j],\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn contains_z(text: &Vec<char>) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < text.len() && (text[i] == 'Z' || text[i] == 'z')),\n{\n    let mut index = 0;\n    while index < text.len()\n        invariant\n            0 <= index <= text.len(),\n            forall|k: int| 0 <= k < index ==> (text[k] != 'Z' && text[k] != 'z'),\n    {\n        if text[index] == 'Z' || text[index] == 'z' {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn contains_z(text: &Vec<char>) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < text.len() && (text[i] == 'Z' || text[i] == 'z')),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn is_smaller(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: bool)\n    requires\n        arr1.len() == arr2.len(),\n    ensures\n        result == (forall|i: int| 0 <= i < arr1.len() ==> arr1[i] > arr2[i]),\n{\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            0 <= index <= arr1.len(),\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            forall|k: int| 0 <= k < index ==> arr1[k] > arr2[k],\n    {\n        if arr1[index] <= arr2[index] {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn is_smaller(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: bool)\n    requires\n        arr1.len() == arr2.len(),\n    ensures\n        result == (forall|i: int| 0 <= i < arr1.len() ==> arr1[i] > arr2[i]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn extract_rear_chars(s: &Vec<Vec<char>>) -> (result: Vec<char>)\n    requires\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i].len() > 0,\n    ensures\n        s.len() == result.len(),\n        forall|i: int| 0 <= i < s.len() ==> result[i] == #[trigger] s[i][s[i].len() - 1],\n{\n    let mut rear_chars: Vec<char> = Vec::with_capacity(s.len());\n    let mut index = 0;\n    while index < s.len()\n        invariant\n            0 <= index <= s.len(),\n            rear_chars.len() == index,\n            forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i].len() > 0,\n            forall|k: int| 0 <= k < index ==> rear_chars[k] == #[trigger] s[k][s[k].len() - 1],\n    {\n        let seq = &s[index];\n        rear_chars.push(seq[seq.len() - 1]);\n        index += 1;\n    }\n    rear_chars\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn extract_rear_chars(s: &Vec<Vec<char>>) -> (result: Vec<char>)\n    requires\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] s[i].len() > 0,\n    ensures\n        s.len() == result.len(),\n        forall|i: int| 0 <= i < s.len() ==> result[i] == #[trigger] s[i][s[i].len() - 1],\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn is_odd_at_odd_index(arr: &Vec<usize>) -> (result: bool)\n    ensures\n        result == forall|i: int| 0 <= i < arr.len() ==> ((i % 2) == (arr[i] % 2)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            forall|i: int| 0 <= i < index ==> ((i % 2) == (arr[i] % 2)),\n    {\n        if ((index % 2) != (arr[index] % 2)) {\n            assert(((index as int) % 2) != (arr[index as int] % 2));\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn is_odd_at_odd_index(arr: &Vec<usize>) -> (result: bool)\n    ensures\n        result == forall|i: int| 0 <= i < arr.len() ==> ((i % 2) == (arr[i] % 2)),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn element_wise_module(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] % arr2[i]) <= i32::MAX),\n    ensures\n        result@.len() == arr1@.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] % arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n            forall|i: int|\n                (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] % arr2[i]) <= i32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] % arr2[k]),\n    {\n        output_arr.push((arr1[index] % arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn element_wise_module(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] % arr2[i]) <= i32::MAX),\n    ensures\n        result@.len() == arr1@.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] % arr2[i]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn contains_k(arr: &Vec<i32>, k: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == k)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            forall|m: int| 0 <= m < index ==> (arr[m] != k),\n    {\n        if (arr[index] == k) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn contains_k(arr: &Vec<i32>, k: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == k)),\n{", "dset": "MBPP"}
{"y": "#![verifier::loop_isolation(false)]\nuse vstd::math::*;\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn max_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        max(seq.last() as int, max_rcur(seq.drop_last()))\n    }\n}\n\nspec fn min_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        min(seq.last() as int, min_rcur(seq.drop_last()))\n    }\n}\n\nfn difference_max_min(arr: &Vec<i32>) -> (diff: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n    ensures\n        diff == max_rcur(arr@) - min_rcur(arr@),\n{\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let mut index = 1;\n\n    while index < arr.len()\n        invariant\n            1 <= index <= arr.len(),\n            i32::MIN / 2 < min_val < i32::MAX / 2,\n            i32::MIN / 2 < max_val < i32::MAX / 2,\n            max_val == max_rcur(arr@.subrange(0, index as int)),\n            min_val == min_rcur(arr@.subrange(0, index as int)),\n    {\n        if (arr[index] <= min_val) {\n            min_val = arr[index];\n        } else if (arr[index] > max_val) {\n            max_val = arr[index];\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    max_val - min_val\n}\n\nfn main() {}\n\n} // verus!\n", "x": "#![verifier::loop_isolation(false)]\nuse vstd::math::*;\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn max_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        max(seq.last() as int, max_rcur(seq.drop_last()))\n    }\n}\n\nspec fn min_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        min(seq.last() as int, min_rcur(seq.drop_last()))\n    }\n}\n\nfn difference_max_min(arr: &Vec<i32>) -> (diff: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n    ensures\n        diff == max_rcur(arr@) - min_rcur(arr@),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn max_length_list(seq: &Vec<Vec<i32>>) -> (max_list: &Vec<i32>)\n    requires\n        seq.len() > 0,\n    ensures\n        forall|k: int| 0 <= k < seq.len() ==> max_list.len() >= #[trigger] (seq[k]).len(),\n        exists|k: int| 0 <= k < seq.len() && max_list@ =~= #[trigger] (seq[k]@),\n{\n    let mut max_list = &seq[0];\n    assert(max_list@ =~= seq[0]@);\n    let mut index = 1;\n\n    while index < seq.len()\n        invariant\n            0 <= index <= seq.len(),\n            forall|k: int| 0 <= k < index ==> max_list.len() >= #[trigger] (seq[k]).len(),\n            exists|k: int| 0 <= k < index && max_list@ =~= #[trigger] (seq[k]@),\n    {\n        if ((seq[index]).len() > max_list.len()) {\n            max_list = &seq[index];\n        }\n        index += 1;\n    }\n    max_list\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn max_length_list(seq: &Vec<Vec<i32>>) -> (max_list: &Vec<i32>)\n    requires\n        seq.len() > 0,\n    ensures\n        forall|k: int| 0 <= k < seq.len() ==> max_list.len() >= #[trigger] (seq[k]).len(),\n        exists|k: int| 0 <= k < seq.len() && max_list@ =~= #[trigger] (seq[k]@),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn list_deep_clone(arr: &Vec<u64>) -> (copied: Vec<u64>)\n    ensures\n        arr@.len() == copied@.len(),\n        forall|i: int| (0 <= i < arr.len()) ==> arr[i] == copied[i],\n{\n    let mut copied_array = Vec::with_capacity(arr.len());\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            copied_array.len() == index,\n            forall|i: int| (0 <= i < index) ==> arr[i] == copied_array[i],\n    {\n        copied_array.push(arr[index]);\n        index += 1;\n    }\n    copied_array\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn list_deep_clone(arr: &Vec<u64>) -> (copied: Vec<u64>)\n    ensures\n        arr@.len() == copied@.len(),\n        forall|i: int| (0 <= i < arr.len()) ==> arr[i] == copied[i],\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn square_nums(nums: &Vec<i32>) -> (squared: Vec<i32>)\n    requires\n        forall|k: int|\n            0 <= k < nums.len() ==> (0 <= #[trigger] nums[k] * #[trigger] nums[k] < i32::MAX),\n    ensures\n        nums.len() == squared.len(),\n        forall|k: int| 0 <= k < nums.len() ==> (#[trigger] squared[k] == nums[k] * nums[k]),\n{\n    let mut result: Vec<i32> = Vec::new();\n    let mut index = 0;\n\n    while index < nums.len()\n        invariant\n            0 <= index <= nums.len(),\n            result@.len() == index,\n            forall|k: int|\n                0 <= k < nums.len() ==> (0 <= #[trigger] nums[k] * #[trigger] nums[k] < i32::MAX),\n            forall|k: int| 0 <= k < index ==> (#[trigger] result[k] == nums[k] * nums[k]),\n    {\n        result.push(nums[index] * nums[index]);\n        index += 1\n    }\n    result\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn square_nums(nums: &Vec<i32>) -> (squared: Vec<i32>)\n    requires\n        forall|k: int|\n            0 <= k < nums.len() ==> (0 <= #[trigger] nums[k] * #[trigger] nums[k] < i32::MAX),\n    ensures\n        nums.len() == squared.len(),\n        forall|k: int| 0 <= k < nums.len() ==> (#[trigger] squared[k] == nums[k] * nums[k]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn all_sequence_equal_length(seq: &Vec<Vec<i32>>) -> (result: bool)\n    requires\n        seq.len() > 0,\n    ensures\n        result == (forall|i: int, j: int|\n            (0 <= i < seq.len() && 0 <= j < seq.len()) ==> (#[trigger] seq[i].len()\n                == #[trigger] seq[j].len())),\n{\n    let mut index = 1;\n    while index < seq.len()\n        invariant\n            1 <= index <= seq.len(),\n            forall|k: int| 0 <= k < index ==> (#[trigger] seq[k].len() == (&seq[0]).len()),\n    {\n        if ((&seq[index]).len() != (&seq[0]).len()) {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn all_sequence_equal_length(seq: &Vec<Vec<i32>>) -> (result: bool)\n    requires\n        seq.len() > 0,\n    ensures\n        result == (forall|i: int, j: int|\n            (0 <= i < seq.len() && 0 <= j < seq.len()) ==> (#[trigger] seq[i].len()\n                == #[trigger] seq[j].len())),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn min_sublist(seq: &Vec<Vec<i32>>) -> (min_list: &Vec<i32>)\n    requires\n        seq.len() > 0,\n    ensures\n        forall|k: int| 0 <= k < seq.len() ==> min_list.len() <= #[trigger] (seq[k]).len(),\n        exists|k: int| 0 <= k < seq.len() && min_list@ =~= #[trigger] (seq[k]@),\n{\n    let mut min_list = &seq[0];\n    assert(min_list@ =~= seq[0]@);\n    let mut index = 1;\n\n    while index < seq.len()\n        invariant\n            0 <= index <= seq.len(),\n            forall|k: int| 0 <= k < index ==> min_list.len() <= #[trigger] (seq[k]).len(),\n            exists|k: int| 0 <= k < index && min_list@ =~= #[trigger] (seq[k]@),\n    {\n        if ((seq[index]).len() < min_list.len()) {\n            min_list = &seq[index];\n        }\n        index += 1;\n    }\n    min_list\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn min_sublist(seq: &Vec<Vec<i32>>) -> (min_list: &Vec<i32>)\n    requires\n        seq.len() > 0,\n    ensures\n        forall|k: int| 0 <= k < seq.len() ==> min_list.len() <= #[trigger] (seq[k]).len(),\n        exists|k: int| 0 <= k < seq.len() && min_list@ =~= #[trigger] (seq[k]@),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn element_wise_subtract(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] - arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int|\n                (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] - arr2[k]),\n    {\n        output_arr.push((arr1[index] - arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn element_wise_subtract(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] - arr2[i]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn all_elements_equals(arr: &Vec<i32>, element: i32) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < arr.len() ==> (arr[i] == element)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            forall|k: int| 0 <= k < index ==> (arr[k] == element),\n    {\n        if arr[index] != element {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn all_elements_equals(arr: &Vec<i32>, element: i32) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < arr.len() ==> (arr[i] == element)),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn add_list(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] + arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] + arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int|\n                (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] + arr2[i]) <= i32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] + arr2[k]),\n    {\n        output_arr.push((arr1[index] + arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn add_list(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] + arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] + arr2[i]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn filter_odd_numbers(arr: &Vec<u32>) -> (odd_list: Vec<u32>)\n    ensures\n        odd_list@ == arr@.filter(|x: u32| x % 2 != 0),\n{\n    let mut odd_list: Vec<u32> = Vec::new();\n    let input_len = arr.len();\n\n    assert(arr@.take(0int).filter(|x: u32| x % 2 != 0) == Seq::<u32>::empty());\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            odd_list@ == arr@.take(index as int).filter(|x: u32| x % 2 != 0),\n    {\n        if (arr[index] % 2 != 0) {\n            odd_list.push(arr[index]);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    odd_list\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn filter_odd_numbers(arr: &Vec<u32>) -> (odd_list: Vec<u32>)\n    ensures\n        odd_list@ == arr@.filter(|x: u32| x % 2 != 0),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn has_common_element(list1: &Vec<i32>, list2: &Vec<i32>) -> (result: bool)\n    ensures\n        result == (exists|i: int, j: int|\n            0 <= i < list1.len() && 0 <= j < list2.len() && (list1[i] == list2[j])),\n{\n    let mut i = 0;\n    while i < list1.len()\n        invariant\n            0 <= i <= list1.len(),\n            forall|k: int, j: int| 0 <= k < i && 0 <= j < list2.len() ==> (list1[k] != list2[j]),\n    {\n        let mut j = 0;\n        while j < list2.len()\n            invariant\n                0 <= i < list1.len(),\n                0 <= j <= list2.len(),\n                forall|k: int| 0 <= k < j ==> (list1[i as int] != list2[k]),\n        {\n            if list1[i] == list2[j] {\n                return true;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn has_common_element(list1: &Vec<i32>, list2: &Vec<i32>) -> (result: bool)\n    ensures\n        result == (exists|i: int, j: int|\n            0 <= i < list1.len() && 0 <= j < list2.len() && (list1[i] == list2[j])),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn has_only_one_distinct_element(arr: &Vec<i32>) -> (result: bool)\n    ensures\n        result == (forall|i: int| 1 <= i < arr@.len() ==> arr[0] == #[trigger] arr[i]),\n{\n    if arr.len() <= 1 {\n        return true;\n    }\n    let mut index = 1;\n    while index < arr.len()\n        invariant\n            1 <= index <= arr.len(),\n            forall|k: int| 0 <= k < index ==> arr[0] == #[trigger] arr[k],\n    {\n        if arr[0] != arr[index] {\n            assert(exists|i: int| 1 <= i < arr@.len() && arr[0] != #[trigger] arr[i]);\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn has_only_one_distinct_element(arr: &Vec<i32>) -> (result: bool)\n    ensures\n        result == (forall|i: int| 1 <= i < arr@.len() ==> arr[0] == #[trigger] arr[i]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_frequency_rcr(seq: Seq<char>, key: char) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_frequency_rcr(seq.drop_last(), key) + if (seq.last() == key) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_frequency(arr: &Vec<char>, key: char) -> (frequency: usize)\n    ensures\n        count_frequency_rcr(arr@, key) == frequency,\n{\n    let mut index = 0;\n    let mut counter = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            0 <= counter <= index,\n            count_frequency_rcr(arr@.subrange(0, index as int), key) == counter,\n    {\n        if (arr[index] == key) {\n            counter += 1;\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    counter\n}\n\nfn first_repeated_char(str1: &Vec<char>) -> (repeated_char: Option<(usize, char)>)\n    ensures\n        if let Some((idx, rp_char)) = repeated_char {\n            &&& str1@.take(idx as int) =~= str1@.take(idx as int).filter(\n                |x: char| count_frequency_rcr(str1@, x) <= 1,\n            )\n            &&& count_frequency_rcr(str1@, rp_char) > 1\n        } else {\n            forall|k: int|\n                0 <= k < str1.len() ==> count_frequency_rcr(str1@, #[trigger] str1[k]) <= 1\n        },\n{\n    let input_len = str1.len();\n    assert(str1@.take(0int).filter(|x: char| count_frequency_rcr(str1@, x) > 1) == Seq::<\n        char,\n    >::empty());\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1.len(),\n            str1@.take(index as int) =~= str1@.take(index as int).filter(\n                |x: char| count_frequency_rcr(str1@, x) <= 1,\n            ),\n    {\n        if count_frequency(&str1, str1[index]) > 1 {\n            return Some((index, str1[index]));\n        }\n        assert(str1@.take((index + 1) as int).drop_last() == str1@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(str1@ =~= str1@.take(input_len as int));\n    assert(forall|k: int|\n        0 <= k < str1.len() ==> count_frequency_rcr(str1@, #[trigger] str1[k]) <= 1);\n    None\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_frequency_rcr(seq: Seq<char>, key: char) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_frequency_rcr(seq.drop_last(), key) + if (seq.last() == key) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_frequency(arr: &Vec<char>, key: char) -> (frequency: usize)\n    ensures\n        count_frequency_rcr(arr@, key) == frequency,\n{\n    let mut index = 0;\n    let mut counter = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            0 <= counter <= index,\n            count_frequency_rcr(arr@.subrange(0, index as int), key) == counter,\n    {\n        if (arr[index] == key) {\n            counter += 1;\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    counter\n}\n\nfn first_repeated_char(str1: &Vec<char>) -> (repeated_char: Option<(usize, char)>)\n    ensures\n        if let Some((idx, rp_char)) = repeated_char {\n            &&& str1@.take(idx as int) =~= str1@.take(idx as int).filter(\n                |x: char| count_frequency_rcr(str1@, x) <= 1,\n            )\n            &&& count_frequency_rcr(str1@, rp_char) > 1\n        } else {\n            forall|k: int|\n                0 <= k < str1.len() ==> count_frequency_rcr(str1@, #[trigger] str1[k]) <= 1\n        },\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn max_difference(arr: &Vec<i32>) -> (diff: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n    ensures\n        forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() ==> arr[i] - arr[j] <= diff,\n{\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n\n    let mut index = 1;\n    while index < arr.len()\n        invariant\n            i32::MIN / 2 < min_val < i32::MAX / 2,\n            i32::MIN / 2 < max_val < i32::MAX / 2,\n            min_val <= max_val,\n            forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n            forall|k: int| 0 <= k < index ==> min_val <= arr[k] && arr[k] <= max_val,\n    {\n        if (arr[index] < min_val) {\n            min_val = arr[index];\n        } else if (arr[index] > max_val) {\n            max_val = arr[index];\n        }\n        index += 1;\n    }\n    max_val - min_val\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn max_difference(arr: &Vec<i32>) -> (diff: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n    ensures\n        forall|i: int, j: int| 0 <= i < arr.len() && 0 <= j < arr.len() ==> arr[i] - arr[j] <= diff,\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn find_even_numbers(arr: &Vec<u32>) -> (even_numbers: Vec<u32>)\n    ensures\n        even_numbers@ == arr@.filter(|x: u32| x % 2 == 0),\n{\n    let mut even_numbers: Vec<u32> = Vec::new();\n    let input_len = arr.len();\n\n    assert(arr@.take(0int).filter(|x: u32| x % 2 == 0) == Seq::<u32>::empty());\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            even_numbers@ == arr@.take(index as int).filter(|x: u32| x % 2 == 0),\n    {\n        if (arr[index] % 2 == 0) {\n            even_numbers.push(arr[index]);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    even_numbers\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn find_even_numbers(arr: &Vec<u32>) -> (even_numbers: Vec<u32>)\n    ensures\n        even_numbers@ == arr@.filter(|x: u32| x % 2 == 0),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn interleave(s1: &Vec<i32>, s2: &Vec<i32>, s3: &Vec<i32>) -> (res: Vec<i32>)\n    requires\n        s1@.len() == s2@.len() && s2@.len() == s3@.len(),\n        0 <= (s1@.len() * 3) <= i32::MAX,\n    ensures\n        res@.len() == s1@.len() * 3,\n        forall|i: int|\n            0 <= i < s1@.len() ==> (res[3 * i] == s1[i] && res[3 * i + 1] == s2[i] && res[3 * i + 2]\n                == s3[i]),\n{\n    let new_seq_len = s1.len() * 3;\n    let mut output_seq = Vec::with_capacity(new_seq_len);\n    let mut index = 0;\n\n    while index < s1.len()\n        invariant\n            0 <= index <= s1.len(),\n            output_seq@.len() == 3 * index,\n            s1@.len() == s2@.len() && s2@.len() == s3@.len(),\n            forall|k: int|\n                0 <= k < index ==> (output_seq[3 * k] == s1[k] && output_seq[3 * k + 1] == s2[k]\n                    && output_seq[3 * k + 2] == s3[k]),\n    {\n        output_seq.push(s1[index]);\n        output_seq.push(s2[index]);\n        output_seq.push(s3[index]);\n        index += 1;\n    }\n    output_seq\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn interleave(s1: &Vec<i32>, s2: &Vec<i32>, s3: &Vec<i32>) -> (res: Vec<i32>)\n    requires\n        s1@.len() == s2@.len() && s2@.len() == s3@.len(),\n        0 <= (s1@.len() * 3) <= i32::MAX,\n    ensures\n        res@.len() == s1@.len() * 3,\n        forall|i: int|\n            0 <= i < s1@.len() ==> (res[3 * i] == s1[i] && res[3 * i + 1] == s2[i] && res[3 * i + 2]\n                == s3[i]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn element_wise_multiplication(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] * arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] * arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int|\n                (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] * arr2[i]) <= i32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] * arr2[k]),\n    {\n        output_arr.push((arr1[index] * arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn element_wise_multiplication(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] * arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] * arr2[i]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_digit(c: char) -> bool {\n    (c as u8) >= 48 && (c as u8) <= 57\n}\n\nspec fn count_digits_recursively(seq: Seq<char>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_digits_recursively(seq.drop_last()) + if is_digit(seq.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_digits(text: &Vec<char>) -> (count: usize)\n    ensures\n        0 <= count <= text.len(),\n        count_digits_recursively(text@) == count,\n{\n    let mut count = 0;\n\n    let mut index = 0;\n    while index < text.len()\n        invariant\n            0 <= index <= text.len(),\n            0 <= count <= index,\n            count == count_digits_recursively(text@.subrange(0, index as int)),\n    {\n        if ((text[index] as u8) >= 48 && (text[index] as u8) <= 57) {\n            count += 1;\n        }\n        index += 1;\n        assert(text@.subrange(0, index - 1 as int) == text@.subrange(0, index as int).drop_last());\n    }\n    assert(text@ == text@.subrange(0, index as int));\n    count\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_digit(c: char) -> bool {\n    (c as u8) >= 48 && (c as u8) <= 57\n}\n\nspec fn count_digits_recursively(seq: Seq<char>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_digits_recursively(seq.drop_last()) + if is_digit(seq.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_digits(text: &Vec<char>) -> (count: usize)\n    ensures\n        0 <= count <= text.len(),\n        count_digits_recursively(text@) == count,\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\nverus! {\n\nspec fn is_upper_case(c: char) -> bool {\n    c >= 'A' && c <= 'Z'\n}\n\nspec fn shift32_spec(c: char) -> char {\n    ((c as u8) + 32) as char\n}\n\nspec fn is_lower_case(c: char) -> bool {\n    c >= 'a' && c <= 'z'\n}\n\nspec fn shift_minus_32_spec(c: char) -> char {\n    ((c as u8) - 32) as char\n}\n\nspec fn to_toggle_case_spec(s: char) -> char {\n    if is_lower_case(s) {\n        shift_minus_32_spec(s)\n    } else if is_upper_case(s) {\n        shift32_spec(s)\n    } else {\n        s\n    }\n}\n\nfn to_toggle_case(str1: &Vec<char>) -> (toggle_case: Vec<char>)\n    ensures\n        str1@.len() == toggle_case@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> toggle_case[i] == to_toggle_case_spec(#[trigger] str1[i]),\n{\n    let mut toggle_case = Vec::with_capacity(str1.len());\n\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1.len(),\n            toggle_case.len() == index,\n            forall|i: int|\n                0 <= i < index ==> toggle_case[i] == to_toggle_case_spec(#[trigger] str1[i]),\n    {\n        if (str1[index] >= 'a' && str1[index] <= 'z') {\n            toggle_case.push(((str1[index] as u8) - 32) as char);\n        } else if (str1[index] >= 'A' && str1[index] <= 'Z') {\n            toggle_case.push(((str1[index] as u8) + 32) as char);\n        } else {\n            toggle_case.push(str1[index]);\n        }\n        index += 1;\n\n    }\n    assert(forall|i: int|\n        0 <= i < str1.len() ==> toggle_case[i] == to_toggle_case_spec(#[trigger] str1[i]));\n    toggle_case\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\nverus! {\n\nspec fn is_upper_case(c: char) -> bool {\n    c >= 'A' && c <= 'Z'\n}\n\nspec fn shift32_spec(c: char) -> char {\n    ((c as u8) + 32) as char\n}\n\nspec fn is_lower_case(c: char) -> bool {\n    c >= 'a' && c <= 'z'\n}\n\nspec fn shift_minus_32_spec(c: char) -> char {\n    ((c as u8) - 32) as char\n}\n\nspec fn to_toggle_case_spec(s: char) -> char {\n    if is_lower_case(s) {\n        shift_minus_32_spec(s)\n    } else if is_upper_case(s) {\n        shift32_spec(s)\n    } else {\n        s\n    }\n}\n\nfn to_toggle_case(str1: &Vec<char>) -> (toggle_case: Vec<char>)\n    ensures\n        str1@.len() == toggle_case@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> toggle_case[i] == to_toggle_case_spec(#[trigger] str1[i]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn smallest_list_length(list: &Vec<Vec<i32>>) -> (min: usize)\n    requires\n        list.len() > 0,\n    ensures\n        min >= 0,\n        forall|i: int| 0 <= i < list.len() ==> min <= #[trigger] list[i].len(),\n        exists|i: int| 0 <= i < list.len() && min == #[trigger] list[i].len(),\n{\n    let mut min = list[0].len();\n\n    let mut index = 1;\n    while index < list.len()\n        invariant\n            0 <= index <= list.len(),\n            forall|k: int| 0 <= k < index ==> min <= #[trigger] list[k].len(),\n            exists|k: int| 0 <= k < index && min == #[trigger] list[k].len(),\n    {\n        if (&list[index]).len() < min {\n            min = (&list[index]).len();\n        }\n        index += 1;\n    }\n    min\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn smallest_list_length(list: &Vec<Vec<i32>>) -> (min: usize)\n    requires\n        list.len() > 0,\n    ensures\n        min >= 0,\n        forall|i: int| 0 <= i < list.len() ==> min <= #[trigger] list[i].len(),\n        exists|i: int| 0 <= i < list.len() && min == #[trigger] list[i].len(),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn smallest_num(nums: &Vec<i32>) -> (min: i32)\n    requires\n        nums.len() > 0,\n    ensures\n        forall|i: int| 0 <= i < nums.len() ==> min <= nums[i],\n        exists|i: int| 0 <= i < nums.len() && min == nums[i],\n{\n    let mut min = nums[0];\n    let mut index = 1;\n\n    while index < nums.len()\n        invariant\n            0 <= index <= nums.len(),\n            forall|k: int| 0 <= k < index ==> min <= nums[k],\n            exists|k: int| 0 <= k < index && min == nums[k],\n    {\n        if nums[index] < min {\n            min = nums[index];\n        }\n        index += 1;\n    }\n    min\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn smallest_num(nums: &Vec<i32>) -> (min: i32)\n    requires\n        nums.len() > 0,\n    ensures\n        forall|i: int| 0 <= i < nums.len() ==> min <= nums[i],\n        exists|i: int| 0 <= i < nums.len() && min == nums[i],\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn element_wise_division(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n        forall|m: int|\n            0 <= m < arr1.len() ==> (u32::MIN <= #[trigger] arr1[m] / #[trigger] arr2[m]\n                <= u32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] / arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n\n    let mut index = 0;\n\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n            forall|m: int|\n                0 <= m < arr1.len() ==> (u32::MIN <= #[trigger] arr1[m] / #[trigger] arr2[m]\n                    <= u32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] / arr2[k]),\n    {\n        output_arr.push((arr1[index] / arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn element_wise_division(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n        forall|m: int|\n            0 <= m < arr1.len() ==> (u32::MIN <= #[trigger] arr1[m] / #[trigger] arr2[m]\n                <= u32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] / arr2[i]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn min_second_value_first(arr: &Vec<Vec<i32>>) -> (first_of_min_second: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() >= 2,\n    ensures\n        exists|i: int|\n            0 <= i < arr.len() && first_of_min_second == #[trigger] arr[i][0] && (forall|j: int|\n                0 <= j < arr.len() ==> (arr[i][1] <= #[trigger] arr[j][1])),\n{\n    let mut min_second_index = 0;\n    let mut index = 0;\n\n    while index < arr.len()\n        invariant\n            0 <= min_second_index < arr.len(),\n            forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() >= 2,\n            forall|k: int|\n                0 <= k < index ==> (arr[min_second_index as int][1] <= #[trigger] arr[k][1]),\n    {\n        assert(arr[index as int].len() > 0);\n        assert(arr[min_second_index as int].len() > 0);\n\n        if arr[index][1] < arr[min_second_index][1] {\n            min_second_index = index;\n        }\n        index += 1;\n    }\n    assert(arr[min_second_index as int].len() > 0);\n    arr[min_second_index][0]\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn min_second_value_first(arr: &Vec<Vec<i32>>) -> (first_of_min_second: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() >= 2,\n    ensures\n        exists|i: int|\n            0 <= i < arr.len() && first_of_min_second == #[trigger] arr[i][0] && (forall|j: int|\n                0 <= j < arr.len() ==> (arr[i][1] <= #[trigger] arr[j][1])),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nproof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)\n    requires\n        l == vec.len(),\n    ensures\n        forall|k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],\n        vec.push(i).index(l as int) == i,\n{\n}\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            forall|m: int| 0 <= m < index ==> (arr[m] != key),\n    {\n        if (arr[index] == key) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn find_dissimilar(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                arr1[i],\n            )),\n        forall|i: int|\n            0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n                arr2[i],\n            )),\n        forall|i: int, j: int|\n            0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j],\n{\n    let mut result = Vec::new();\n    let ghost mut output_len: int = 0;\n\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            forall|i: int|\n                0 <= i < index ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                    arr1[i],\n                )),\n            forall|m: int, n: int|\n                0 <= m < n < result.len() ==> #[trigger] result[m] != #[trigger] result[n],\n    {\n        if (!contains(arr2, arr1[index]) && !contains(&result, arr1[index])) {\n            proof {\n                lemma_vec_push(result@, arr1[index as int], result.len());\n                output_len = output_len + 1;\n            }\n            result.push(arr1[index]);\n\n        }\n        index += 1;\n    }\n    let mut index = 0;\n    while index < arr2.len()\n        invariant\n            forall|i: int|\n                0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                    arr1[i],\n                )),\n            forall|i: int|\n                0 <= i < index ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n                    arr2[i],\n                )),\n            forall|m: int, n: int|\n                0 <= m < n < result.len() ==> #[trigger] result[m] != #[trigger] result[n],\n    {\n        if (!contains(arr1, arr2[index]) && !contains(&result, arr2[index])) {\n            proof {\n                lemma_vec_push(result@, arr2[index as int], result.len());\n                output_len = output_len + 1;\n            }\n            result.push(arr2[index]);\n        }\n        index += 1;\n    }\n    assert(forall|i: int|\n        0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n            arr1[i],\n        )));\n    assert(forall|i: int|\n        0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n            arr2[i],\n        )));\n    assert(forall|i: int, j: int|\n        0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j]);\n\n    result\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nproof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)\n    requires\n        l == vec.len(),\n    ensures\n        forall|k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],\n        vec.push(i).index(l as int) == i,\n{\n}\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            forall|m: int| 0 <= m < index ==> (arr[m] != key),\n    {\n        if (arr[index] == key) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn find_dissimilar(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                arr1[i],\n            )),\n        forall|i: int|\n            0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n                arr2[i],\n            )),\n        forall|i: int, j: int|\n            0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j],\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\nverus! {\n\nfn remove_kth_element(list: &Vec<i32>, k: usize) -> (new_list: Vec<i32>)\n    requires\n        list.len() > 0,\n        0 < k < list@.len(),\n    ensures\n        new_list@ == list@.subrange(0, k - 1 as int).add(\n            list@.subrange(k as int, list.len() as int),\n        ),\n{\n    let mut new_list = Vec::new();\n    let mut index = 0;\n    while index < (k - 1)\n        invariant\n            0 <= index <= k - 1,\n            0 < k < list@.len(),\n            new_list@ =~= list@.subrange(0, index as int),\n    {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    let mut index = k;\n    while index < list.len()\n        invariant\n            k <= index <= list.len(),\n            new_list@ =~= list@.subrange(0 as int, k - 1 as int).add(\n                list@.subrange(k as int, index as int),\n            ),\n    {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    assert(new_list@ == list@.subrange(0, k - 1 as int).add(\n        list@.subrange(k as int, list.len() as int),\n    ));\n    new_list\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\nverus! {\n\nfn remove_kth_element(list: &Vec<i32>, k: usize) -> (new_list: Vec<i32>)\n    requires\n        list.len() > 0,\n        0 < k < list@.len(),\n    ensures\n        new_list@ == list@.subrange(0, k - 1 as int).add(\n            list@.subrange(k as int, list.len() as int),\n        ),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_divisible(n: int, divisor: int) -> bool {\n    (n % divisor) == 0\n}\n\nfn prime_num(n: u64) -> (result: bool)\n    requires\n        n >= 2,\n    ensures\n        result == (forall|k: int| 2 <= k < n ==> !is_divisible(n as int, k)),\n{\n    if n <= 1 {\n        return false;\n    }\n    let mut index = 2;\n    while index < n\n        invariant\n            2 <= index <= n,\n            forall|k: int| 2 <= k < index ==> !is_divisible(n as int, k),\n    {\n        if ((n % index) == 0) {\n            assert(is_divisible(n as int, index as int));\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_divisible(n: int, divisor: int) -> bool {\n    (n % divisor) == 0\n}\n\nfn prime_num(n: u64) -> (result: bool)\n    requires\n        n >= 2,\n    ensures\n        result == (forall|k: int| 2 <= k < n ==> !is_divisible(n as int, k)),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn is_even_at_even_index(arr: &Vec<usize>) -> (result: bool)\n    ensures\n        result == forall|i: int| 0 <= i < arr.len() ==> ((i % 2) == (arr[i] % 2)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            forall|i: int| 0 <= i < index ==> ((i % 2) == (arr[i] % 2)),\n    {\n        if ((index % 2) != (arr[index] % 2)) {\n            assert(((index as int) % 2) != (arr[index as int] % 2));\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn is_even_at_even_index(arr: &Vec<usize>) -> (result: bool)\n    ensures\n        result == forall|i: int| 0 <= i < arr.len() ==> ((i % 2) == (arr[i] % 2)),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn find_negative_numbers(arr: &Vec<i32>) -> (negative_list: Vec<i32>)\n    ensures\n        negative_list@ == arr@.filter(|x: i32| x < 0),\n{\n    let mut negative_list: Vec<i32> = Vec::new();\n    let input_len = arr.len();\n\n    assert(arr@.take(0int).filter(|x: i32| x < 0) == Seq::<i32>::empty());\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            negative_list@ == arr@.take(index as int).filter(|x: i32| x < 0),\n    {\n        if (arr[index] < 0) {\n            negative_list.push(arr[index]);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    negative_list\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn find_negative_numbers(arr: &Vec<i32>) -> (negative_list: Vec<i32>)\n    ensures\n        negative_list@ == arr@.filter(|x: i32| x < 0),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn find_odd_numbers(arr: &Vec<u32>) -> (odd_numbers: Vec<u32>)\n    ensures\n        odd_numbers@ == arr@.filter(|x: u32| x % 2 != 0),\n{\n    let mut odd_numbers: Vec<u32> = Vec::new();\n    let input_len = arr.len();\n\n    assert(arr@.take(0int).filter(|x: u32| x % 2 != 0) == Seq::<u32>::empty());\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            odd_numbers@ == arr@.take(index as int).filter(|x: u32| x % 2 != 0),\n    {\n        if (arr[index] % 2 != 0) {\n            odd_numbers.push(arr[index]);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    odd_numbers\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn find_odd_numbers(arr: &Vec<u32>) -> (odd_numbers: Vec<u32>)\n    ensures\n        odd_numbers@ == arr@.filter(|x: u32| x % 2 != 0),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_identical(s1: Seq<i32>, s2: Seq<i32>, s3: Seq<i32>) -> int\n    decreases s1.len(), s2.len(), s3.len(),\n{\n    if s1.len() == 0 || s2.len() == 0 || s3.len() == 0 {\n        0\n    } else {\n        count_identical(s1.drop_last(), s2.drop_last(), s3.drop_last()) + if (s1.last() == s2.last()\n            && s2.last() == s3.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_identical_position(arr1: &Vec<i32>, arr2: &Vec<i32>, arr3: &Vec<i32>) -> (count: usize)\n    requires\n        arr1.len() == arr2.len() && arr2.len() == arr3.len(),\n    ensures\n        0 <= count <= arr1.len(),\n        count_identical(arr1@, arr2@, arr3@) == count,\n{\n    let mut count = 0;\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            0 <= index <= arr1.len(),\n            0 <= count <= index,\n            arr1.len() == arr2.len() && arr2.len() == arr3.len(),\n            count_identical(\n                arr1@.subrange(0, index as int),\n                arr2@.subrange(0, index as int),\n                arr3@.subrange(0, index as int),\n            ) == count,\n    {\n        if arr1[index] == arr2[index] && arr2[index] == arr3[index] {\n            count += 1;\n        }\n        index += 1;\n        assert(arr1@.subrange(0, index - 1 as int) == arr1@.subrange(0, index as int).drop_last());\n        assert(arr2@.subrange(0, index - 1 as int) == arr2@.subrange(0, index as int).drop_last());\n        assert(arr3@.subrange(0, index - 1 as int) == arr3@.subrange(0, index as int).drop_last());\n    }\n    assert(arr1@ == arr1@.subrange(0, index as int));\n    assert(arr2@ == arr2@.subrange(0, index as int));\n    assert(arr3@ == arr3@.subrange(0, index as int));\n    count\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_identical(s1: Seq<i32>, s2: Seq<i32>, s3: Seq<i32>) -> int\n    decreases s1.len(), s2.len(), s3.len(),\n{\n    if s1.len() == 0 || s2.len() == 0 || s3.len() == 0 {\n        0\n    } else {\n        count_identical(s1.drop_last(), s2.drop_last(), s3.drop_last()) + if (s1.last() == s2.last()\n            && s2.last() == s3.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_identical_position(arr1: &Vec<i32>, arr2: &Vec<i32>, arr3: &Vec<i32>) -> (count: usize)\n    requires\n        arr1.len() == arr2.len() && arr2.len() == arr3.len(),\n    ensures\n        0 <= count <= arr1.len(),\n        count_identical(arr1@, arr2@, arr3@) == count,\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn cube_element(nums: &Vec<i32>) -> (cubed: Vec<i32>)\n    requires\n        forall|k: int|\n            0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]\n                <= i32::MAX),\n        forall|k: int|\n            0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]\n                * #[trigger] nums[k] <= i32::MAX),\n    ensures\n        forall|i: int|\n            0 <= i < nums.len() ==> cubed[i] == #[trigger] nums[i] * #[trigger] nums[i]\n                * #[trigger] nums[i],\n{\n    let mut cubed_array: Vec<i32> = Vec::new();\n    let mut i = 0;\n    while i < nums.len()\n        invariant\n            cubed_array@.len() == i,\n            forall|k: int|\n                0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]\n                    <= i32::MAX),\n            forall|k: int|\n                0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]\n                    * #[trigger] nums[k] <= i32::MAX),\n            forall|k: int|\n                0 <= k < i ==> (#[trigger] cubed_array[k] == nums[k] * nums[k] * nums[k]),\n    {\n        cubed_array.push(nums[i] * nums[i] * nums[i]);\n        i += 1;\n    }\n    cubed_array\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn cube_element(nums: &Vec<i32>) -> (cubed: Vec<i32>)\n    requires\n        forall|k: int|\n            0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]\n                <= i32::MAX),\n        forall|k: int|\n            0 <= k < nums.len() ==> (i32::MIN <= #[trigger] nums[k] * #[trigger] nums[k]\n                * #[trigger] nums[k] <= i32::MAX),\n    ensures\n        forall|i: int|\n            0 <= i < nums.len() ==> cubed[i] == #[trigger] nums[i] * #[trigger] nums[i]\n                * #[trigger] nums[i],\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_negative_to(seq: Seq<i64>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        sum_negative_to(seq.drop_last()) + if (seq.last() < 0) {\n            seq.last() as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn sum_negatives(arr: &Vec<i64>) -> (sum_neg: i128)\n    ensures\n        sum_negative_to(arr@) == sum_neg,\n{\n    let mut index = 0;\n    let mut sum_neg = 0i128;\n\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            forall|j: int|\n                0 <= j <= index ==> (i64::MIN * index <= (sum_negative_to(\n                    #[trigger] arr@.subrange(0, j),\n                )) <= 0),\n            sum_negative_to(arr@.subrange(0, index as int)) == sum_neg,\n    {\n        if (arr[index] < 0) {\n            sum_neg = sum_neg + (arr[index] as i128);\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    sum_neg\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_negative_to(seq: Seq<i64>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        sum_negative_to(seq.drop_last()) + if (seq.last() < 0) {\n            seq.last() as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn sum_negatives(arr: &Vec<i64>) -> (sum_neg: i128)\n    ensures\n        sum_negative_to(arr@) == sum_neg,\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\nverus! {\n\nfn split_array(list: &Vec<i32>, l: usize) -> (new_list: (Vec<i32>, Vec<i32>))\n    requires\n        list@.len() > 0,\n        0 < l < list@.len(),\n    ensures\n        new_list.0@ == list@.subrange(0, l as int),\n        new_list.1@ == list@.subrange(l as int, list.len() as int),\n{\n    let mut part1: Vec<i32> = Vec::new();\n    let mut index = 0;\n    while index < l\n        invariant\n            0 < l < list@.len(),\n            0 <= index <= l,\n            part1@ =~= list@.subrange(0, index as int),\n    {\n        part1.push(list[index]);\n        index += 1;\n    }\n    let mut part2: Vec<i32> = Vec::new();\n    index = l;\n    while index < list.len()\n        invariant\n            l <= index <= list.len(),\n            part2@ =~= list@.subrange(l as int, index as int),\n    {\n        part2.push(list[index]);\n        index += 1;\n    }\n\n    (part1, part2)\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\nverus! {\n\nfn split_array(list: &Vec<i32>, l: usize) -> (new_list: (Vec<i32>, Vec<i32>))\n    requires\n        list@.len() > 0,\n        0 < l < list@.len(),\n    ensures\n        new_list.0@ == list@.subrange(0, l as int),\n        new_list.1@ == list@.subrange(l as int, list.len() as int),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn element_wise_subtract(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] - arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int|\n                (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] - arr2[k]),\n    {\n        output_arr.push((arr1[index] - arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn element_wise_subtract(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] - arr2[i]) <= i32::MAX),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] - arr2[i]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_to(arr: Seq<i64>) -> int\n    decreases arr.len(),\n{\n    if arr.len() == 0 {\n        0\n    } else {\n        sum_to(arr.drop_last()) + arr.last()\n    }\n}\n\nfn sum(arr: &Vec<i64>) -> (sum: i128)\n    ensures\n        sum_to(arr@) == sum,\n{\n    let mut index = 0;\n    let mut sum = 0i128;\n\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            sum == sum_to(arr@.subrange(0, index as int)),\n            forall|j: int|\n                0 <= j <= index ==> (i64::MIN * index <= (sum_to(#[trigger] arr@.subrange(0, j)))\n                    <= i64::MAX * index),\n    {\n        assert(arr@.subrange(0, index as int) =~= arr@.subrange(0, (index + 1) as int).drop_last());\n        sum = sum + arr[index] as i128;\n        index += 1;\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    sum\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_to(arr: Seq<i64>) -> int\n    decreases arr.len(),\n{\n    if arr.len() == 0 {\n        0\n    } else {\n        sum_to(arr.drop_last()) + arr.last()\n    }\n}\n\nfn sum(arr: &Vec<i64>) -> (sum: i128)\n    ensures\n        sum_to(arr@) == sum,\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_lower_case(c: char) -> bool {\n    (c as u32) >= 97 && (c as u32) <= 122\n}\n\nspec fn is_upper_case(c: char) -> bool {\n    (c as u32) >= 65 && (c as u32) <= 90\n}\n\nspec fn count_uppercase_recursively(seq: Seq<char>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_uppercase_recursively(seq.drop_last()) + if is_upper_case(seq.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_uppercase(text: &Vec<char>) -> (count: u64)\n    ensures\n        0 <= count <= text.len(),\n        count_uppercase_recursively(text@) == count,\n{\n    let mut index = 0;\n    let mut count = 0;\n\n    while index < text.len()\n        invariant\n            0 <= index <= text.len(),\n            0 <= count <= index,\n            count_uppercase_recursively(text@.subrange(0, index as int)) == count,\n    {\n        if ((text[index] as u32) >= 65 && (text[index] as u32) <= 90) {\n            count += 1;\n        }\n        index += 1;\n        assert(text@.subrange(0, index - 1 as int) == text@.subrange(0, index as int).drop_last());\n\n    }\n    assert(text@ == text@.subrange(0, index as int));\n    count\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_lower_case(c: char) -> bool {\n    (c as u32) >= 97 && (c as u32) <= 122\n}\n\nspec fn is_upper_case(c: char) -> bool {\n    (c as u32) >= 65 && (c as u32) <= 90\n}\n\nspec fn count_uppercase_recursively(seq: Seq<char>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_uppercase_recursively(seq.drop_last()) + if is_upper_case(seq.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_uppercase(text: &Vec<char>) -> (count: u64)\n    ensures\n        0 <= count <= text.len(),\n        count_uppercase_recursively(text@) == count,\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn is_sub_list_at_index(main: &Vec<i32>, sub: &Vec<i32>, idx: usize) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n        0 <= idx <= (main.len() - sub.len()),\n    ensures\n        result == (main@.subrange(idx as int, (idx + sub@.len())) =~= sub@),\n{\n    let mut i = 0;\n    while i < sub.len()\n        invariant\n            0 <= idx <= (main.len() - sub.len()),\n            0 <= i <= sub.len(),\n            0 <= idx + i <= main.len(),\n            forall|k: int| 0 <= k < i ==> main[idx + k] == sub[k],\n            forall|k: int|\n                0 <= k < i ==> (main@.subrange(idx as int, (idx + k)) =~= sub@.subrange(0, k)),\n    {\n        if (main[idx + i] != sub[i]) {\n            assert(exists|k: int| 0 <= k < i ==> main[idx + k] != sub[k]);\n            assert(main@.subrange(idx as int, (idx + sub@.len())) != sub@);\n            return false;\n        }\n        i += 1;\n    }\n    assert(main@.subrange(idx as int, (idx + sub@.len())) == sub@);\n    true\n}\n\nfn is_sub_list(main: &Vec<i32>, sub: &Vec<i32>) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n    ensures\n        result == (exists|k: int, l: int|\n            0 <= k <= (main.len() - sub.len()) && l == k + sub.len() && (#[trigger] (main@.subrange(\n                k,\n                l,\n            ))) =~= sub@),\n{\n    if sub.len() > main.len() {\n        return false;\n    }\n    let mut index = 0;\n    while index <= (main.len() - sub.len())\n        invariant\n            sub.len() <= main.len(),\n            0 <= index <= (main.len() - sub.len()) + 1,\n            forall|k: int, l: int|\n                (0 <= k < index) && l == k + sub.len() ==> (#[trigger] (main@.subrange(k, l))\n                    != sub@),\n    {\n        if (is_sub_list_at_index(&main, &sub, index)) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn is_sub_list_at_index(main: &Vec<i32>, sub: &Vec<i32>, idx: usize) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n        0 <= idx <= (main.len() - sub.len()),\n    ensures\n        result == (main@.subrange(idx as int, (idx + sub@.len())) =~= sub@),\n{\n    let mut i = 0;\n    while i < sub.len()\n        invariant\n            0 <= idx <= (main.len() - sub.len()),\n            0 <= i <= sub.len(),\n            0 <= idx + i <= main.len(),\n            forall|k: int| 0 <= k < i ==> main[idx + k] == sub[k],\n            forall|k: int|\n                0 <= k < i ==> (main@.subrange(idx as int, (idx + k)) =~= sub@.subrange(0, k)),\n    {\n        if (main[idx + i] != sub[i]) {\n            assert(exists|k: int| 0 <= k < i ==> main[idx + k] != sub[k]);\n            assert(main@.subrange(idx as int, (idx + sub@.len())) != sub@);\n            return false;\n        }\n        i += 1;\n    }\n    assert(main@.subrange(idx as int, (idx + sub@.len())) == sub@);\n    true\n}\n\nfn is_sub_list(main: &Vec<i32>, sub: &Vec<i32>) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n    ensures\n        result == (exists|k: int, l: int|\n            0 <= k <= (main.len() - sub.len()) && l == k + sub.len() && (#[trigger] (main@.subrange(\n                k,\n                l,\n            ))) =~= sub@),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\nverus! {\n\nspec fn is_even(n: u32) -> bool {\n    (n % 2) == 0\n}\n\nfn is_product_even(arr: &Vec<u32>) -> (result: bool)\n    ensures\n        result <==> (exists|k: int| 0 <= k < arr.len() && is_even(#[trigger] arr[k])),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            forall|k: int| 0 <= k < index ==> !(is_even(#[trigger] arr[k])),\n    {\n        if (arr[index] % 2 == 0) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\nverus! {\n\nspec fn is_even(n: u32) -> bool {\n    (n % 2) == 0\n}\n\nfn is_product_even(arr: &Vec<u32>) -> (result: bool)\n    ensures\n        result <==> (exists|k: int| 0 <= k < arr.len() && is_even(#[trigger] arr[k])),\n{", "dset": "MBPP"}
{"y": "#![verifier::loop_isolation(false)]\nuse vstd::math::*;\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn max_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        max(seq.last() as int, max_rcur(seq.drop_last()))\n    }\n}\n\nspec fn min_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        min(seq.last() as int, min_rcur(seq.drop_last()))\n    }\n}\n\nfn sum_min_max(arr: &Vec<i32>) -> (sum: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n    ensures\n        sum == max_rcur(arr@) + min_rcur(arr@),\n{\n    let mut min_val = arr[0];\n    let mut max_val = arr[0];\n    let mut index = 1;\n\n    while index < arr.len()\n        invariant\n            1 <= index <= arr.len(),\n            i32::MIN / 2 < min_val < i32::MAX / 2,\n            i32::MIN / 2 < max_val < i32::MAX / 2,\n            max_val == max_rcur(arr@.subrange(0, index as int)),\n            min_val == min_rcur(arr@.subrange(0, index as int)),\n    {\n        if (arr[index] <= min_val) {\n            min_val = arr[index];\n        } else if (arr[index] > max_val) {\n            max_val = arr[index];\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    max_val + min_val\n}\n\nfn main() {}\n\n} // verus!\n", "x": "#![verifier::loop_isolation(false)]\nuse vstd::math::*;\nuse vstd::prelude::*;\n\nverus! {\n\nspec fn max_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        max(seq.last() as int, max_rcur(seq.drop_last()))\n    }\n}\n\nspec fn min_rcur(seq: Seq<i32>) -> int\n    decreases seq.len(),\n{\n    if seq.len() <= 1 {\n        seq.first() as int\n    } else {\n        min(seq.last() as int, min_rcur(seq.drop_last()))\n    }\n}\n\nfn sum_min_max(arr: &Vec<i32>) -> (sum: i32)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> i32::MIN / 2 < #[trigger] arr[i] < i32::MAX / 2,\n    ensures\n        sum == max_rcur(arr@) + min_rcur(arr@),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn bit_wise_xor(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> result[i] == #[trigger] arr1[i] ^ #[trigger] arr2[i],\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|k: int|\n                0 <= k < index ==> output_arr[k] == #[trigger] arr1[k] ^ #[trigger] arr2[k],\n    {\n        output_arr.push((arr1[index] ^ arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn bit_wise_xor(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    requires\n        arr1.len() == arr2.len(),\n    ensures\n        result.len() == arr1.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> result[i] == #[trigger] arr1[i] ^ #[trigger] arr2[i],\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_upper_case(c: char) -> bool {\n    c >= 'A' && c <= 'Z'\n}\n\nspec fn shift32_spec(c: char) -> char {\n    ((c as u8) + 32) as char\n}\n\nfn to_lowercase(str1: &Vec<char>) -> (result: Vec<char>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> result[i] == (if is_upper_case(#[trigger] str1[i]) {\n                shift32_spec(str1[i])\n            } else {\n                str1[i]\n            }),\n{\n    let mut lower_case: Vec<char> = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1.len(),\n            lower_case.len() == index,\n            forall|i: int|\n                0 <= i < index ==> lower_case[i] == (if is_upper_case(#[trigger] str1[i]) {\n                    shift32_spec(str1[i])\n                } else {\n                    str1[i]\n                }),\n    {\n        if (str1[index] >= 'A' && str1[index] <= 'Z') {\n            lower_case.push(((str1[index] as u8) + 32) as char);\n\n        } else {\n            lower_case.push(str1[index]);\n        }\n        assert(lower_case[index as int] == (if is_upper_case(str1[index as int]) {\n            shift32_spec(str1[index as int])\n        } else {\n            str1[index as int]\n        }));\n        index += 1;\n    }\n    assert(forall|i: int|\n        0 <= i < str1.len() ==> lower_case[i] == (if is_upper_case(#[trigger] str1[i]) {\n            shift32_spec(str1[i])\n        } else {\n            str1[i]\n        }));\n    lower_case\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_upper_case(c: char) -> bool {\n    c >= 'A' && c <= 'Z'\n}\n\nspec fn shift32_spec(c: char) -> char {\n    ((c as u8) + 32) as char\n}\n\nfn to_lowercase(str1: &Vec<char>) -> (result: Vec<char>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> result[i] == (if is_upper_case(#[trigger] str1[i]) {\n                shift32_spec(str1[i])\n            } else {\n                str1[i]\n            }),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\nverus! {\n\nfn reverse_to_k(list: &Vec<i32>, n: usize) -> (reversed_list: Vec<i32>)\n    requires\n        list@.len() > 0,\n        0 < n < list@.len(),\n    ensures\n        reversed_list@ == list@.subrange(0, n as int).reverse().add(\n            list@.subrange(n as int, list.len() as int),\n        ),\n{\n    let mut reversed_list = Vec::new();\n    let mut index = 0;\n    while index < n\n        invariant\n            0 < n < list@.len(),\n            0 <= index <= n,\n            reversed_list.len() == index,\n            forall|k: int| 0 <= k < index ==> reversed_list[k] == list[n - 1 - k],\n    {\n        reversed_list.push(list[n - 1 - index]);\n        index += 1;\n    }\n    index = n;\n    while index < list.len()\n        invariant\n            n <= index <= list.len(),\n            reversed_list@ =~= list@.subrange(0, n as int).reverse().add(\n                list@.subrange(n as int, index as int),\n            ),\n    {\n        reversed_list.push(list[index]);\n        index += 1;\n    }\n    reversed_list\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\nverus! {\n\nfn reverse_to_k(list: &Vec<i32>, n: usize) -> (reversed_list: Vec<i32>)\n    requires\n        list@.len() > 0,\n        0 < n < list@.len(),\n    ensures\n        reversed_list@ == list@.subrange(0, n as int).reverse().add(\n            list@.subrange(n as int, list.len() as int),\n        ),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn get_first_elements(arr: &Vec<Vec<i32>>) -> (result: Vec<i32>)\n    requires\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() > 0,\n    ensures\n        arr.len() == result.len(),\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] result[i] == #[trigger] arr[i][0],\n{\n    let mut first_elem_arr: Vec<i32> = Vec::new();\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            first_elem_arr.len() == index,\n            forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() > 0,\n            forall|k: int| 0 <= k < index ==> #[trigger] first_elem_arr[k] == #[trigger] arr[k][0],\n    {\n        let seq = &arr[index];\n        assert(seq.len() > 0);\n        first_elem_arr.push(seq[0]);\n        index += 1;\n    }\n    first_elem_arr\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn get_first_elements(arr: &Vec<Vec<i32>>) -> (result: Vec<i32>)\n    requires\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] arr[i].len() > 0,\n    ensures\n        arr.len() == result.len(),\n        forall|i: int| 0 <= i < arr.len() ==> #[trigger] result[i] == #[trigger] arr[i][0],\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nproof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)\n    requires\n        l == vec.len(),\n    ensures\n        forall|k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],\n        vec.push(i).index(l as int) == i,\n{\n}\n\nfn contains(str: &Vec<char>, key: char) -> (result: bool)\n    ensures\n        result <==> (exists|i: int| 0 <= i < str.len() && (str[i] == key)),\n{\n    let mut i = 0;\n    while i < str.len()\n        invariant\n            forall|m: int| 0 <= m < i ==> (str[m] != key),\n    {\n        if (str[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn remove_chars(str1: &Vec<char>, str2: &Vec<char>) -> (result: Vec<char>)\n    ensures\n        forall|i: int|\n            0 <= i < result.len() ==> (str1@.contains(#[trigger] result[i]) && !str2@.contains(\n                #[trigger] result[i],\n            )),\n        forall|i: int|\n            0 <= i < str1.len() ==> (str2@.contains(#[trigger] str1[i]) || result@.contains(\n                #[trigger] str1[i],\n            )),\n{\n    let mut output_str = Vec::new();\n    let mut index: usize = 0;\n    let ghost mut output_len: int = 0;\n\n    while index < str1.len()\n        invariant\n            forall|k: int|\n                0 <= k < output_str.len() ==> (str1@.contains(#[trigger] output_str[k])\n                    && !str2@.contains(#[trigger] output_str[k])),\n            forall|k: int|\n                0 <= k < index ==> (str2@.contains(#[trigger] str1[k]) || output_str@.contains(\n                    #[trigger] str1[k],\n                )),\n    {\n        if (!contains(str2, str1[index])) {\n            proof {\n                lemma_vec_push(output_str@, str1[index as int], output_str.len());\n                output_len = output_len + 1;\n            }\n            output_str.push(str1[index]);\n        }\n        index += 1;\n    }\n    output_str\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nproof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)\n    requires\n        l == vec.len(),\n    ensures\n        forall|k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],\n        vec.push(i).index(l as int) == i,\n{\n}\n\nfn contains(str: &Vec<char>, key: char) -> (result: bool)\n    ensures\n        result <==> (exists|i: int| 0 <= i < str.len() && (str[i] == key)),\n{\n    let mut i = 0;\n    while i < str.len()\n        invariant\n            forall|m: int| 0 <= m < i ==> (str[m] != key),\n    {\n        if (str[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn remove_chars(str1: &Vec<char>, str2: &Vec<char>) -> (result: Vec<char>)\n    ensures\n        forall|i: int|\n            0 <= i < result.len() ==> (str1@.contains(#[trigger] result[i]) && !str2@.contains(\n                #[trigger] result[i],\n            )),\n        forall|i: int|\n            0 <= i < str1.len() ==> (str2@.contains(#[trigger] str1[i]) || result@.contains(\n                #[trigger] str1[i],\n            )),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn all_characters_same(char_arr: &Vec<char>) -> (result: bool)\n    ensures\n        result == (forall|i: int|\n            1 <= i < char_arr@.len() ==> char_arr[0] == #[trigger] char_arr[i]),\n{\n    if char_arr.len() <= 1 {\n        return true;\n    }\n    let mut index = 1;\n    while index < char_arr.len()\n        invariant\n            1 <= index <= char_arr.len(),\n            forall|k: int| 0 <= k < index ==> char_arr[0] == #[trigger] char_arr[k],\n    {\n        if char_arr[0] != char_arr[index] {\n            assert(exists|i: int|\n                1 <= i < char_arr@.len() && char_arr[0] != #[trigger] char_arr[i]);\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn all_characters_same(char_arr: &Vec<char>) -> (result: bool)\n    ensures\n        result == (forall|i: int|\n            1 <= i < char_arr@.len() ==> char_arr[0] == #[trigger] char_arr[i]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_frequency_rcr(seq: Seq<i32>, key: i32) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_frequency_rcr(seq.drop_last(), key) + if (seq.last() == key) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_frequency(arr: &Vec<i32>, key: i32) -> (frequency: usize)\n    ensures\n        count_frequency_rcr(arr@, key) == frequency,\n{\n    let mut index = 0;\n    let mut counter = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            0 <= counter <= index,\n            count_frequency_rcr(arr@.subrange(0, index as int), key) == counter,\n    {\n        if (arr[index] == key) {\n            counter += 1;\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    counter\n}\n\nfn remove_duplicates(arr: &Vec<i32>) -> (unique_arr: Vec<i32>)\n    ensures\n        unique_arr@ == arr@.filter(|x: i32| count_frequency_rcr(arr@, x) == 1),\n{\n    let mut unique_arr: Vec<i32> = Vec::new();\n    let input_len = arr.len();\n\n    assert(arr@.take(0int).filter(|x: i32| count_frequency_rcr(arr@, x) == 1) == Seq::<\n        i32,\n    >::empty());\n\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            unique_arr@ == arr@.take(index as int).filter(\n                |x: i32| count_frequency_rcr(arr@, x) == 1,\n            ),\n    {\n        if count_frequency(&arr, arr[index]) == 1 {\n            unique_arr.push(arr[index]);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    unique_arr\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\npub open spec fn count_frequency_rcr(seq: Seq<i32>, key: i32) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_frequency_rcr(seq.drop_last(), key) + if (seq.last() == key) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_frequency(arr: &Vec<i32>, key: i32) -> (frequency: usize)\n    ensures\n        count_frequency_rcr(arr@, key) == frequency,\n{\n    let mut index = 0;\n    let mut counter = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            0 <= counter <= index,\n            count_frequency_rcr(arr@.subrange(0, index as int), key) == counter,\n    {\n        if (arr[index] == key) {\n            counter += 1;\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    counter\n}\n\nfn remove_duplicates(arr: &Vec<i32>) -> (unique_arr: Vec<i32>)\n    ensures\n        unique_arr@ == arr@.filter(|x: i32| count_frequency_rcr(arr@, x) == 1),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn find_first_occurrence(arr: &Vec<i32>, target: i32) -> (index: Option<usize>)\n    requires\n        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j],\n    ensures\n        if let Some(idx) = index {\n            &&& 0 <= idx < arr.len()\n            &&& forall|k: int| 0 <= k < idx ==> arr[k] != target\n            &&& arr[idx as int] == target\n        } else {\n            forall|k: int| 0 <= k < arr.len() ==> arr[k] != target\n        },\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            forall|k: int| 0 <= k < index ==> arr[k] != target,\n    {\n        if arr[index] == target {\n            return Some(index);\n        }\n        index += 1;\n    }\n    None\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn find_first_occurrence(arr: &Vec<i32>, target: i32) -> (index: Option<usize>)\n    requires\n        forall|i: int, j: int| 0 <= i < j < arr.len() ==> arr[i] <= arr[j],\n    ensures\n        if let Some(idx) = index {\n            &&& 0 <= idx < arr.len()\n            &&& forall|k: int| 0 <= k < idx ==> arr[k] != target\n            &&& arr[idx as int] == target\n        } else {\n            forall|k: int| 0 <= k < arr.len() ==> arr[k] != target\n        },\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn remove_odds(arr: &Vec<u32>) -> (even_list: Vec<u32>)\n    ensures\n        even_list@ == arr@.filter(|x: u32| x % 2 == 0),\n{\n    let mut even_list: Vec<u32> = Vec::new();\n    let input_len = arr.len();\n\n    assert(arr@.take(0int).filter(|x: u32| x % 2 == 0) == Seq::<u32>::empty());\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            even_list@ == arr@.take(index as int).filter(|x: u32| x % 2 == 0),\n    {\n        if (arr[index] % 2 == 0) {\n            even_list.push(arr[index]);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    even_list\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn remove_odds(arr: &Vec<u32>) -> (even_list: Vec<u32>)\n    ensures\n        even_list@ == arr@.filter(|x: u32| x % 2 == 0),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\nverus! {\n\nspec fn rotation_split(len: usize, n: usize) -> int {\n    len - (n % len)\n}\n\nfn rotate_right(list: &Vec<u32>, n: usize) -> (new_list: Vec<u32>)\n    requires\n        list.len() > 0,\n    ensures\n        new_list.len() == list.len(),\n        new_list@ == list@.subrange(rotation_split(list.len(), n) as int, list@.len() as int).add(\n            list@.subrange(0, rotation_split(list.len(), n) as int),\n        ),\n{\n    let rotation = n % list.len();\n    let split_index = list.len() - rotation;\n\n    let mut new_list = Vec::with_capacity(list.len());\n\n    let mut index = split_index;\n\n    while index < list.len()\n        invariant\n            split_index <= index <= list.len(),\n            list@.subrange(split_index as int, index as int) =~= new_list@,\n    {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    index = 0;\n    while index < split_index\n        invariant\n            0 <= split_index <= list@.len(),\n            0 <= index <= split_index,\n            new_list@ =~= list@.subrange(split_index as int, list@.len() as int).add(\n                list@.subrange(0, index as int),\n            ),\n    {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    assert(new_list@ =~= list@.subrange(split_index as int, list@.len() as int).add(\n        list@.subrange(0, split_index as int),\n    ));\n    new_list\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\nverus! {\n\nspec fn rotation_split(len: usize, n: usize) -> int {\n    len - (n % len)\n}\n\nfn rotate_right(list: &Vec<u32>, n: usize) -> (new_list: Vec<u32>)\n    requires\n        list.len() > 0,\n    ensures\n        new_list.len() == list.len(),\n        new_list@ == list@.subrange(rotation_split(list.len(), n) as int, list@.len() as int).add(\n            list@.subrange(0, rotation_split(list.len(), n) as int),\n        ),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn is_sorted(arr: &Vec<i32>) -> (is_sorted: bool)\n    requires\n        arr.len() > 0,\n    ensures\n        is_sorted == (forall|i: int, j: int| 0 <= i < j < arr.len() ==> (arr[i] <= arr[j])),\n{\n    let mut index = 0;\n    while index < arr.len() - 1\n        invariant\n            0 <= index <= arr.len() - 1,\n            forall|k: int, l: int| 0 <= k < l <= index ==> arr[k] <= arr[l],\n    {\n        if arr[index] > arr[index + 1] {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn is_sorted(arr: &Vec<i32>) -> (is_sorted: bool)\n    requires\n        arr.len() > 0,\n    ensures\n        is_sorted == (forall|i: int, j: int| 0 <= i < j < arr.len() ==> (arr[i] <= arr[j])),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn find_first_odd(arr: &Vec<u32>) -> (index: Option<usize>)\n    ensures\n        if let Some(idx) = index {\n            &&& arr@.take(idx as int) == arr@.take(idx as int).filter(|x: u32| x % 2 == 0)\n            &&& arr[idx as int] % 2 != 0\n        } else {\n            forall|k: int| 0 <= k < arr.len() ==> (arr[k] % 2 == 0)\n        },\n{\n    let input_len = arr.len();\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            arr@.take(index as int) =~= arr@.take(index as int).filter(|x: u32| x % 2 == 0),\n    {\n        if (arr[index] % 2 != 0) {\n            return Some(index);\n        }\n        assert(arr@.take((index + 1) as int).drop_last() == arr@.take(index as int));\n        reveal(Seq::filter);\n        index += 1;\n    }\n    assert(arr@ == arr@.take(input_len as int));\n    None\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn find_first_odd(arr: &Vec<u32>) -> (index: Option<usize>)\n    ensures\n        if let Some(idx) = index {\n            &&& arr@.take(idx as int) == arr@.take(idx as int).filter(|x: u32| x % 2 == 0)\n            &&& arr[idx as int] % 2 != 0\n        } else {\n            forall|k: int| 0 <= k < arr.len() ==> (arr[k] % 2 == 0)\n        },\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_to(arr: Seq<i64>) -> int\n    decreases arr.len(),\n{\n    if arr.len() == 0 {\n        0\n    } else {\n        sum_to(arr.drop_last()) + arr.last()\n    }\n}\n\nfn sum_range_list(arr: &Vec<i64>, start: usize, end: usize) -> (sum: i128)\n    requires\n        0 <= start <= end,\n        start <= end < arr.len(),\n    ensures\n        sum_to(arr@.subrange(start as int, end + 1 as int)) == sum,\n{\n    let mut index = start;\n    let mut sum = 0i128;\n    let _end = end + 1;\n\n    while index < _end\n        invariant\n            start <= _end <= arr.len(),\n            start <= index <= _end,\n            sum == sum_to(arr@.subrange(start as int, index as int)),\n            forall|j: int|\n                start <= j <= index ==> (i64::MIN * index <= (sum_to(\n                    #[trigger] arr@.subrange(start as int, j),\n                )) <= i64::MAX * index),\n    {\n        assert(arr@.subrange(start as int, index as int) =~= arr@.subrange(\n            start as int,\n            (index + 1) as int,\n        ).drop_last());\n        sum = sum + arr[index] as i128;\n        index += 1;\n    }\n    sum\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn sum_to(arr: Seq<i64>) -> int\n    decreases arr.len(),\n{\n    if arr.len() == 0 {\n        0\n    } else {\n        sum_to(arr.drop_last()) + arr.last()\n    }\n}\n\nfn sum_range_list(arr: &Vec<i64>, start: usize, end: usize) -> (sum: i128)\n    requires\n        0 <= start <= end,\n        start <= end < arr.len(),\n    ensures\n        sum_to(arr@.subrange(start as int, end + 1 as int)) == sum,\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn replace_chars(str1: &Vec<char>, old_char: char, new_char: char) -> (result: Vec<char>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> result[i] == (if str1[i] == old_char {\n                new_char\n            } else {\n                str1[i]\n            }),\n{\n    let mut result_str = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1@.len(),\n            result_str@.len() == index,\n            forall|k: int|\n                0 <= k < index ==> result_str[k] == (if str1[k] == old_char {\n                    new_char\n                } else {\n                    str1[k]\n                }),\n    {\n        if str1[index] == old_char {\n            result_str.push(new_char);\n        } else {\n            result_str.push(str1[index]);\n        }\n        index += 1;\n    }\n    result_str\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn replace_chars(str1: &Vec<char>, old_char: char, new_char: char) -> (result: Vec<char>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> result[i] == (if str1[i] == old_char {\n                new_char\n            } else {\n                str1[i]\n            }),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn element_wise_divide(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] / arr2[i]) <= i32::MAX),\n    ensures\n        result@.len() == arr1@.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] / arr2[i]),\n{\n    let mut output_arr = Vec::with_capacity(arr1.len());\n\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            arr1.len() == arr2.len(),\n            0 <= index <= arr2.len(),\n            output_arr.len() == index,\n            forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n            forall|i: int|\n                (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] / arr2[i]) <= i32::MAX),\n            forall|k: int|\n                0 <= k < index ==> #[trigger] output_arr[k] == #[trigger] (arr1[k] / arr2[k]),\n    {\n        output_arr.push((arr1[index] / arr2[index]));\n        index += 1;\n    }\n    output_arr\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn element_wise_divide(arr1: &Vec<u32>, arr2: &Vec<u32>) -> (result: Vec<u32>)\n    requires\n        arr1.len() == arr2.len(),\n        forall|i: int| 0 <= i < arr2.len() ==> arr2[i] != 0,\n        forall|i: int|\n            (0 <= i < arr1.len()) ==> (i32::MIN <= #[trigger] (arr1[i] / arr2[i]) <= i32::MAX),\n    ensures\n        result@.len() == arr1@.len(),\n        forall|i: int|\n            0 <= i < result.len() ==> #[trigger] result[i] == #[trigger] (arr1[i] / arr2[i]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\nverus! {\n\nspec fn min_spec(seq: Seq<i32>) -> int\n    recommends\n        0 < seq.len(),\n    decreases seq.len(),\n{\n    if seq.len() == 1 {\n        seq[0] as int\n    } else if seq.len() == 0 {\n        0\n    } else {\n        let later_min = min_spec(seq.drop_first());\n        if seq[0] <= later_min {\n            seq[0] as int\n        } else {\n            later_min as int\n        }\n    }\n}\n\n// change the signatue to return -> (min_index, second_min_index)\nfn second_smallest(numbers: &Vec<i32>) -> (indices: (\n    usize,\n    usize,\n))  //(min_index, second_min_index)\n    requires\n        numbers.len()\n            >= 2,  // There must be at least 2 different values, a minimum and another one\n\n    ensures\n        forall|k: int|\n            0 <= k < numbers.len() && k != indices.0 && numbers[indices.0 as int] == min_spec(\n                numbers@,\n            ) ==> (#[trigger] numbers[k] >= numbers[indices.1 as int]),\n        exists|k: int|\n            0 <= k < numbers.len() && k != indices.0 && (#[trigger] numbers[k]\n                == numbers[indices.1 as int]),\n{\n    let mut min_index: usize = 0;\n    let mut second_min_index: usize = 1;\n\n    if numbers[1] < numbers[0] {\n        min_index = 1;\n        second_min_index = 0;\n    }\n    let mut index = 2;\n    while index < numbers.len()\n        invariant\n            0 <= index <= numbers.len(),\n            0 <= min_index < index,\n            0 <= second_min_index < index,\n            min_index != second_min_index,\n            forall|k: int| 0 <= k < index ==> numbers[k] >= numbers[min_index as int],\n            forall|k: int|\n                0 <= k < index && k != min_index ==> numbers[k] >= numbers[second_min_index as int],\n    {\n        if numbers[index] < numbers[min_index] {\n            second_min_index = min_index;\n            min_index = index;\n        } else if numbers[index] < numbers[second_min_index] {\n            second_min_index = index;\n        }\n        index += 1;\n        assert(forall|k: int|\n            0 <= k < index && k != min_index ==> numbers[k] >= numbers[second_min_index as int]);\n    }\n    assert(forall|k: int|\n        0 <= k < index && k != min_index ==> numbers[k] >= numbers[second_min_index as int]);\n    assert(forall|k: int|\n        0 <= k < numbers.len() && k != min_index && numbers[min_index as int] == min_spec(numbers@)\n            ==> (numbers[k] >= numbers[second_min_index as int]));\n    (min_index, second_min_index)\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\nverus! {\n\nspec fn min_spec(seq: Seq<i32>) -> int\n    recommends\n        0 < seq.len(),\n    decreases seq.len(),\n{\n    if seq.len() == 1 {\n        seq[0] as int\n    } else if seq.len() == 0 {\n        0\n    } else {\n        let later_min = min_spec(seq.drop_first());\n        if seq[0] <= later_min {\n            seq[0] as int\n        } else {\n            later_min as int\n        }\n    }\n}\n\n// change the signatue to return -> (min_index, second_min_index)\nfn second_smallest(numbers: &Vec<i32>) -> (indices: (\n    usize,\n    usize,\n))  //(min_index, second_min_index)\n    requires\n        numbers.len()\n            >= 2,  // There must be at least 2 different values, a minimum and another one\n\n    ensures\n        forall|k: int|\n            0 <= k < numbers.len() && k != indices.0 && numbers[indices.0 as int] == min_spec(\n                numbers@,\n            ) ==> (#[trigger] numbers[k] >= numbers[indices.1 as int]),\n        exists|k: int|\n            0 <= k < numbers.len() && k != indices.0 && (#[trigger] numbers[k]\n                == numbers[indices.1 as int]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn insert_before_each(arr: &Vec<i32>, elem: i32) -> (result: Vec<i32>)\n    ensures\n        result@.len() == (2 * arr.len()),\n        forall|k: int| 0 <= k < arr.len() ==> #[trigger] result[2 * k] == elem,\n        forall|k: int| 0 <= k < arr.len() ==> #[trigger] result[2 * k + 1] == arr[k],\n{\n    let mut result: Vec<i32> = Vec::new();\n    let mut index = 0;\n\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            result@.len() == index * 2,\n            forall|k: int| 0 <= k < index ==> #[trigger] result[2 * k] == elem,\n            forall|k: int| 0 <= k < index ==> #[trigger] result[2 * k + 1] == arr[k],\n    {\n        result.push(elem);\n        result.push(arr[index]);\n        index += 1;\n    }\n    result\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn insert_before_each(arr: &Vec<i32>, elem: i32) -> (result: Vec<i32>)\n    ensures\n        result@.len() == (2 * arr.len()),\n        forall|k: int| 0 <= k < arr.len() ==> #[trigger] result[2 * k] == elem,\n        forall|k: int| 0 <= k < arr.len() ==> #[trigger] result[2 * k + 1] == arr[k],\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\nverus! {\n\nfn split_and_append(list: &Vec<i32>, n: usize) -> (new_list: Vec<i32>)\n    requires\n        list@.len() > 0,\n        0 < n < list@.len(),\n    ensures\n        new_list@ == list@.subrange(n as int, list@.len() as int).add(list@.subrange(0, n as int)),\n{\n    let mut new_list = Vec::new();\n    let mut index = n;\n    while index < list.len()\n        invariant\n            n <= index <= list.len(),\n            list@.subrange(n as int, index as int) =~= new_list@,\n    {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    let mut index = 0;\n    while index < n\n        invariant\n            0 < n < list@.len(),\n            0 <= index <= n,\n            new_list@ =~= list@.subrange(n as int, list@.len() as int).add(\n                list@.subrange(0, index as int),\n            ),\n    {\n        new_list.push(list[index]);\n        index += 1;\n    }\n    new_list\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\nverus! {\n\nfn split_and_append(list: &Vec<i32>, n: usize) -> (new_list: Vec<i32>)\n    requires\n        list@.len() > 0,\n        0 < n < list@.len(),\n    ensures\n        new_list@ == list@.subrange(n as int, list@.len() as int).add(list@.subrange(0, n as int)),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_space_comma_dot_spec(c: char) -> bool {\n    (c == ' ') || (c == ',') || (c == '.')\n}\n\nfn replace_with_colon(str1: &Vec<char>) -> (result: Vec<char>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|k: int|\n            0 <= k < result.len() ==> #[trigger] result[k] == (if is_space_comma_dot_spec(str1[k]) {\n                ':'\n            } else {\n                str1[k]\n            }),\n{\n    let mut result: Vec<char> = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1.len(),\n            result@.len() == index,\n            forall|k: int|\n                0 <= k < index ==> #[trigger] result[k] == (if is_space_comma_dot_spec(str1[k]) {\n                    ':'\n                } else {\n                    str1[k]\n                }),\n    {\n        if ((str1[index] == ' ') || (str1[index] == ',') || (str1[index] == '.')) {\n            result.push(':');\n        } else {\n            result.push(str1[index]);\n        }\n        index += 1;\n    }\n    result\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_space_comma_dot_spec(c: char) -> bool {\n    (c == ' ') || (c == ',') || (c == '.')\n}\n\nfn replace_with_colon(str1: &Vec<char>) -> (result: Vec<char>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|k: int|\n            0 <= k < result.len() ==> #[trigger] result[k] == (if is_space_comma_dot_spec(str1[k]) {\n                ':'\n            } else {\n                str1[k]\n            }),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nproof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)\n    requires\n        l == vec.len(),\n    ensures\n        forall|k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],\n        vec.push(i).index(l as int) == i,\n{\n}\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            forall|m: int| 0 <= m < index ==> (arr[m] != key),\n    {\n        if (arr[index] == key) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn difference(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                arr1[i],\n            )),\n        forall|i: int|\n            0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n                arr2[i],\n            )),\n        forall|i: int, j: int|\n            0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j],\n{\n    let mut result = Vec::new();\n    let ghost mut output_len: int = 0;\n\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            forall|i: int|\n                0 <= i < index ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                    arr1[i],\n                )),\n            forall|m: int, n: int|\n                0 <= m < n < result.len() ==> #[trigger] result[m] != #[trigger] result[n],\n    {\n        if (!contains(arr2, arr1[index]) && !contains(&result, arr1[index])) {\n            proof {\n                lemma_vec_push(result@, arr1[index as int], result.len());\n                output_len = output_len + 1;\n            }\n            result.push(arr1[index]);\n        }\n        index += 1;\n    }\n    index = 0;\n    while index < arr2.len()\n        invariant\n            forall|i: int|\n                0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                    arr1[i],\n                )),\n            forall|i: int|\n                0 <= i < index ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n                    arr2[i],\n                )),\n            forall|m: int, n: int|\n                0 <= m < n < result.len() ==> #[trigger] result[m] != #[trigger] result[n],\n    {\n        if (!contains(arr1, arr2[index]) && !contains(&result, arr2[index])) {\n            proof {\n                lemma_vec_push(result@, arr2[index as int], result.len());\n                output_len = output_len + 1;\n            }\n            result.push(arr2[index]);\n        }\n        index += 1;\n    }\n    assert(forall|i: int|\n        0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n            arr1[i],\n        )));\n    assert(forall|i: int|\n        0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n            arr2[i],\n        )));\n    assert(forall|i: int, j: int|\n        0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j]);\n    result\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nproof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)\n    requires\n        l == vec.len(),\n    ensures\n        forall|k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],\n        vec.push(i).index(l as int) == i,\n{\n}\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut index = 0;\n    while index < arr.len()\n        invariant\n            forall|m: int| 0 <= m < index ==> (arr[m] != key),\n    {\n        if (arr[index] == key) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn difference(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < arr1.len() ==> (!arr2@.contains(#[trigger] arr1[i]) ==> result@.contains(\n                arr1[i],\n            )),\n        forall|i: int|\n            0 <= i < arr2.len() ==> (!arr1@.contains(#[trigger] arr2[i]) ==> result@.contains(\n                arr2[i],\n            )),\n        forall|i: int, j: int|\n            0 <= i < j < result.len() ==> #[trigger] result[i] != #[trigger] result[j],\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_digit_sepc(c: char) -> bool {\n    (c as u32) >= 48 && (c as u32) <= 57\n}\n\nfn is_digit(c: char) -> (res: bool)\n    ensures\n        res == is_digit_sepc(c),\n{\n    (c as u32) >= 48 && (c as u32) <= 57\n}\n\nfn is_integer(text: &Vec<char>) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < text.len() ==> (#[trigger] is_digit_sepc(text[i]))),\n{\n    let mut index = 0;\n    while index < text.len()\n        invariant\n            0 <= index <= text.len(),\n            forall|i: int| 0 <= i < index ==> (#[trigger] is_digit_sepc(text[i])),\n    {\n        if (!is_digit(text[index])) {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_digit_sepc(c: char) -> bool {\n    (c as u32) >= 48 && (c as u32) <= 57\n}\n\nfn is_digit(c: char) -> (res: bool)\n    ensures\n        res == is_digit_sepc(c),\n{\n    (c as u32) >= 48 && (c as u32) <= 57\n}\n\nfn is_integer(text: &Vec<char>) -> (result: bool)\n    ensures\n        result == (forall|i: int| 0 <= i < text.len() ==> (#[trigger] is_digit_sepc(text[i]))),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_lower_case(c: char) -> bool {\n    c >= 'a' && c <= 'z'\n}\n\nspec fn shift_minus_32_spec(c: char) -> char {\n    ((c as u8) - 32) as char\n}\n\nfn to_uppercase(str1: &Vec<char>) -> (result: Vec<char>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> (result[i] == (if is_lower_case(#[trigger] str1[i]) {\n                shift_minus_32_spec(str1[i])\n            } else {\n                str1[i]\n            })),\n{\n    let mut upper_case: Vec<char> = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1.len(),\n            upper_case.len() == index,\n            forall|i: int|\n                0 <= i < index ==> (upper_case[i] == (if is_lower_case(#[trigger] str1[i]) {\n                    shift_minus_32_spec(str1[i])\n                } else {\n                    str1[i]\n                })),\n    {\n        if (str1[index] >= 'a' && str1[index] <= 'z') {\n            upper_case.push(((str1[index] as u8) - 32) as char);\n        } else {\n            upper_case.push(str1[index]);\n        }\n        assert(upper_case[index as int] == (if is_lower_case(str1[index as int]) {\n            shift_minus_32_spec(str1[index as int])\n        } else {\n            str1[index as int]\n        }));\n        index += 1;\n    }\n    assert(forall|i: int|\n        0 <= i < str1.len() ==> upper_case[i] == (if is_lower_case(#[trigger] str1[i]) {\n            shift_minus_32_spec(str1[i])\n        } else {\n            str1[i]\n        }));\n    upper_case\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_lower_case(c: char) -> bool {\n    c >= 'a' && c <= 'z'\n}\n\nspec fn shift_minus_32_spec(c: char) -> char {\n    ((c as u8) - 32) as char\n}\n\nfn to_uppercase(str1: &Vec<char>) -> (result: Vec<char>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> (result[i] == (if is_lower_case(#[trigger] str1[i]) {\n                shift_minus_32_spec(str1[i])\n            } else {\n                str1[i]\n            })),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_boolean(seq: Seq<bool>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_boolean(seq.drop_last()) + if (seq.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_true(arr: &Vec<bool>) -> (count: u64)\n    ensures\n        0 <= count <= arr.len(),\n        count_boolean(arr@) == count,\n{\n    let mut index = 0;\n    let mut counter = 0;\n\n    while index < arr.len()\n        invariant\n            0 <= index <= arr.len(),\n            0 <= counter <= index,\n            count_boolean(arr@.subrange(0, index as int)) == counter,\n    {\n        if (arr[index]) {\n            counter += 1;\n        }\n        index += 1;\n        assert(arr@.subrange(0, index - 1 as int) == arr@.subrange(0, index as int).drop_last());\n\n    }\n    assert(arr@ == arr@.subrange(0, index as int));\n    counter\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn count_boolean(seq: Seq<bool>) -> int\n    decreases seq.len(),\n{\n    if seq.len() == 0 {\n        0\n    } else {\n        count_boolean(seq.drop_last()) + if (seq.last()) {\n            1 as int\n        } else {\n            0 as int\n        }\n    }\n}\n\nfn count_true(arr: &Vec<bool>) -> (count: u64)\n    ensures\n        0 <= count <= arr.len(),\n        count_boolean(arr@) == count,\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut i = 0;\n    while i < arr.len()\n        invariant\n            0 <= i <= arr.len(),\n            forall|m: int| 0 <= m < i ==> (arr[m] != key),\n    {\n        if (arr[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn any_value_exists(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: bool)\n    ensures\n        result == exists|k: int| 0 <= k < arr1.len() && arr2@.contains(#[trigger] arr1[k]),\n{\n    let mut index = 0;\n    while index < arr1.len()\n        invariant\n            0 <= index <= arr1.len(),\n            forall|k: int| 0 <= k < index ==> !arr2@.contains(#[trigger] arr1[k]),\n    {\n        if (contains(arr2, arr1[index])) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut i = 0;\n    while i < arr.len()\n        invariant\n            0 <= i <= arr.len(),\n            forall|m: int| 0 <= m < i ==> (arr[m] != key),\n    {\n        if (arr[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn any_value_exists(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: bool)\n    ensures\n        result == exists|k: int| 0 <= k < arr1.len() && arr2@.contains(#[trigger] arr1[k]),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn sub_array_at_index(main: &Vec<i32>, sub: &Vec<i32>, idx: usize) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n        0 <= idx <= (main.len() - sub.len()),\n    ensures\n        result == (main@.subrange(idx as int, (idx + sub@.len())) =~= sub@),\n{\n    let mut i = 0;\n    while i < sub.len()\n        invariant\n            0 <= idx <= (main.len() - sub.len()),\n            0 <= i <= sub.len(),\n            0 <= idx + i <= main.len(),\n            forall|k: int| 0 <= k < i ==> main[idx + k] == sub[k],\n            forall|k: int|\n                0 <= k < i ==> (main@.subrange(idx as int, (idx + k)) =~= sub@.subrange(0, k)),\n    {\n        if (main[idx + i] != sub[i]) {\n            assert(exists|k: int| 0 <= k < i ==> main[idx + k] != sub[k]);\n            assert(main@.subrange(idx as int, (idx + sub@.len())) != sub@);\n            return false;\n\n        }\n        i += 1;\n    }\n    assert(main@.subrange(idx as int, (idx + sub@.len())) == sub@);\n    true\n}\n\nfn is_sub_array(main: &Vec<i32>, sub: &Vec<i32>) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n    ensures\n        result == (exists|k: int, l: int|\n            0 <= k <= (main.len() - sub.len()) && l == k + sub.len() && (#[trigger] (main@.subrange(\n                k,\n                l,\n            ))) =~= sub@),\n{\n    if sub.len() > main.len() {\n        return false;\n    }\n    let mut index = 0;\n    while index <= (main.len() - sub.len())\n        invariant\n            sub.len() <= main.len(),\n            0 <= index <= (main.len() - sub.len()) + 1,\n            forall|k: int, l: int|\n                (0 <= k < index) && l == k + sub.len() ==> (#[trigger] (main@.subrange(k, l))\n                    != sub@),\n    {\n        if (sub_array_at_index(&main, &sub, index)) {\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn sub_array_at_index(main: &Vec<i32>, sub: &Vec<i32>, idx: usize) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n        0 <= idx <= (main.len() - sub.len()),\n    ensures\n        result == (main@.subrange(idx as int, (idx + sub@.len())) =~= sub@),\n{\n    let mut i = 0;\n    while i < sub.len()\n        invariant\n            0 <= idx <= (main.len() - sub.len()),\n            0 <= i <= sub.len(),\n            0 <= idx + i <= main.len(),\n            forall|k: int| 0 <= k < i ==> main[idx + k] == sub[k],\n            forall|k: int|\n                0 <= k < i ==> (main@.subrange(idx as int, (idx + k)) =~= sub@.subrange(0, k)),\n    {\n        if (main[idx + i] != sub[i]) {\n            assert(exists|k: int| 0 <= k < i ==> main[idx + k] != sub[k]);\n            assert(main@.subrange(idx as int, (idx + sub@.len())) != sub@);\n            return false;\n\n        }\n        i += 1;\n    }\n    assert(main@.subrange(idx as int, (idx + sub@.len())) == sub@);\n    true\n}\n\nfn is_sub_array(main: &Vec<i32>, sub: &Vec<i32>) -> (result: bool)\n    requires\n        sub.len() <= main.len(),\n    ensures\n        result == (exists|k: int, l: int|\n            0 <= k <= (main.len() - sub.len()) && l == k + sub.len() && (#[trigger] (main@.subrange(\n                k,\n                l,\n            ))) =~= sub@),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_divisible(n: int, divisor: int) -> bool {\n    (n % divisor) == 0\n}\n\nfn is_non_prime(n: u64) -> (result: bool)\n    requires\n        n >= 2,\n    ensures\n        result == (exists|k: int| 2 <= k < n && is_divisible(n as int, k)),\n{\n    if n <= 1 {\n        return true;\n    }\n    let mut index = 2;\n    while index < n\n        invariant\n            2 <= index,\n            forall|k: int| 2 <= k < index ==> !is_divisible(n as int, k),\n    {\n        if ((n % index) == 0) {\n            assert(is_divisible(n as int, index as int));\n            return true;\n        }\n        index += 1;\n    }\n    false\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nspec fn is_divisible(n: int, divisor: int) -> bool {\n    (n % divisor) == 0\n}\n\nfn is_non_prime(n: u64) -> (result: bool)\n    requires\n        n >= 2,\n    ensures\n        result == (exists|k: int| 2 <= k < n && is_divisible(n as int, k)),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn replace_blanks_with_chars(str1: &Vec<char>, ch: char) -> (result: Vec<char>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> result[i] == (if str1[i] == 32 {\n                ch\n            } else {\n                str1[i]\n            }),\n{\n    let mut out_str: Vec<char> = Vec::with_capacity(str1.len());\n    let mut index = 0;\n    while index < str1.len()\n        invariant\n            0 <= index <= str1.len(),\n            out_str@.len() == index,\n            forall|k: int|\n                0 <= k < index ==> out_str[k] == (if str1[k] == ' ' {\n                    ch\n                } else {\n                    str1[k]\n                }),\n    {\n        if (str1[index] == ' ') {\n            out_str.push(ch);\n        } else {\n            out_str.push(str1[index]);\n        }\n        index += 1;\n    }\n    out_str\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn replace_blanks_with_chars(str1: &Vec<char>, ch: char) -> (result: Vec<char>)\n    ensures\n        str1@.len() == result@.len(),\n        forall|i: int|\n            0 <= i < str1.len() ==> result[i] == (if str1[i] == 32 {\n                ch\n            } else {\n                str1[i]\n            }),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nproof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)\n    requires\n        l == vec.len(),\n    ensures\n        forall|k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],\n        vec.push(i).index(l as int) == i,\n{\n}\n\nfn contains(str: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result <==> (exists|i: int| 0 <= i < str.len() && (str[i] == key)),\n{\n    let mut i = 0;\n    while i < str.len()\n        invariant\n            forall|m: int| 0 <= m < i ==> (str[m] != key),\n    {\n        if (str[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn remove_elements(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < result.len() ==> (arr1@.contains(#[trigger] result[i]) && !arr2@.contains(\n                #[trigger] result[i],\n            )),\n        forall|i: int|\n            0 <= i < arr1.len() ==> (arr2@.contains(#[trigger] arr1[i]) || result@.contains(\n                #[trigger] arr1[i],\n            )),\n{\n    let mut output_str = Vec::new();\n    let mut index: usize = 0;\n    let ghost mut output_len: int = 0;\n\n    while index < arr1.len()\n        invariant\n            forall|k: int|\n                0 <= k < output_str.len() ==> (arr1@.contains(#[trigger] output_str[k])\n                    && !arr2@.contains(#[trigger] output_str[k])),\n            forall|k: int|\n                0 <= k < index ==> (arr2@.contains(#[trigger] arr1[k]) || output_str@.contains(\n                    #[trigger] arr1[k],\n                )),\n    {\n        if (!contains(arr2, arr1[index])) {\n            proof {\n                lemma_vec_push(output_str@, arr1[index as int], output_str.len());\n                output_len = output_len + 1;\n            }\n            output_str.push(arr1[index]);\n        }\n        index += 1;\n    }\n    output_str\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nproof fn lemma_vec_push<T>(vec: Seq<T>, i: T, l: usize)\n    requires\n        l == vec.len(),\n    ensures\n        forall|k: int| 0 <= k < vec.len() ==> #[trigger] vec[k] == vec.push(i)[k],\n        vec.push(i).index(l as int) == i,\n{\n}\n\nfn contains(str: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result <==> (exists|i: int| 0 <= i < str.len() && (str[i] == key)),\n{\n    let mut i = 0;\n    while i < str.len()\n        invariant\n            forall|m: int| 0 <= m < i ==> (str[m] != key),\n    {\n        if (str[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn remove_elements(arr1: &Vec<i32>, arr2: &Vec<i32>) -> (result: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < result.len() ==> (arr1@.contains(#[trigger] result[i]) && !arr2@.contains(\n                #[trigger] result[i],\n            )),\n        forall|i: int|\n            0 <= i < arr1.len() ==> (arr2@.contains(#[trigger] arr1[i]) || result@.contains(\n                #[trigger] arr1[i],\n            )),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut i = 0;\n    while i < arr.len()\n        invariant\n            forall|m: int| 0 <= m < i ==> (arr[m] != key),\n    {\n        if (arr[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn shared_elements(list1: &Vec<i32>, list2: &Vec<i32>) -> (shared: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < shared.len() ==> (list1@.contains(#[trigger] shared[i]) && list2@.contains(\n                #[trigger] shared[i],\n            )),\n        forall|i: int, j: int| 0 <= i < j < shared.len() ==> shared[i] != shared[j],\n{\n    let mut shared = Vec::new();\n    let ghost mut shared_arr_len: int = 0;\n\n    let mut index = 0;\n    while index < list1.len()\n        invariant\n            forall|i: int|\n                0 <= i < shared.len() ==> (list1@.contains(#[trigger] shared[i]) && list2@.contains(\n                    #[trigger] shared[i],\n                )),\n            forall|m: int, n: int| 0 <= m < n < shared.len() ==> shared[m] != shared[n],\n    {\n        if (contains(list2, list1[index]) && !contains(&shared, list1[index])) {\n            shared.push(list1[index]);\n            proof {\n                shared_arr_len = shared_arr_len + 1;\n            }\n        }\n        index += 1\n    }\n    shared\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn contains(arr: &Vec<i32>, key: i32) -> (result: bool)\n    ensures\n        result == (exists|i: int| 0 <= i < arr.len() && (arr[i] == key)),\n{\n    let mut i = 0;\n    while i < arr.len()\n        invariant\n            forall|m: int| 0 <= m < i ==> (arr[m] != key),\n    {\n        if (arr[i] == key) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn shared_elements(list1: &Vec<i32>, list2: &Vec<i32>) -> (shared: Vec<i32>)\n    ensures\n        forall|i: int|\n            0 <= i < shared.len() ==> (list1@.contains(#[trigger] shared[i]) && list2@.contains(\n                #[trigger] shared[i],\n            )),\n        forall|i: int, j: int| 0 <= i < j < shared.len() ==> shared[i] != shared[j],\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn replace_last_element(first: &Vec<i32>, second: &Vec<i32>) -> (replaced_list: Vec<i32>)\n    requires\n        first.len() > 0,\n    ensures\n        replaced_list@ == first@.subrange(0, first.len() - 1).add(second@),\n{\n    let mut replaced_list = Vec::new();\n    let first_end = first.len() - 1;\n    let mut index = 0;\n\n    while index < first_end\n        invariant\n            first_end == first.len() - 1,\n            0 <= index <= first_end,\n            replaced_list@ =~= first@.subrange(0, index as int),\n    {\n        replaced_list.push(first[index]);\n        index += 1;\n    }\n    index = 0;\n    while index < second.len()\n        invariant\n            0 <= index <= second.len(),\n            replaced_list@ =~= first@.subrange(0, first.len() - 1).add(\n                second@.subrange(0, index as int),\n            ),\n    {\n        replaced_list.push(second[index]);\n        index += 1;\n    }\n    assert(replaced_list@ =~= first@.subrange(0, first.len() - 1).add(second@));\n    replaced_list\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn replace_last_element(first: &Vec<i32>, second: &Vec<i32>) -> (replaced_list: Vec<i32>)\n    requires\n        first.len() > 0,\n    ensures\n        replaced_list@ == first@.subrange(0, first.len() - 1).add(second@),\n{", "dset": "MBPP"}
{"y": "use vstd::prelude::*;\n\nverus! {\n\nfn contains_consecutive_numbers(arr: &Vec<i32>) -> (is_consecutive: bool)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> (0 <= #[trigger] arr[i] + 1 < i32::MAX),\n    ensures\n        is_consecutive == (forall|i: int, j: int|\n            0 <= i < j < arr.len() && j == i + 1 ==> (arr[i] + 1 == arr[j])),\n{\n    let mut index = 0;\n    while (index < arr.len() - 1)\n        invariant\n            0 <= index <= arr.len() - 1,\n            forall|k: int| 0 <= k < arr.len() ==> (0 <= #[trigger] arr[k] + 1 < i32::MAX),\n            forall|k: int, l: int| (0 <= k < l <= index && l == k + 1) ==> (arr[k] + 1 == arr[l]),\n    {\n        if (arr[index] + 1 != arr[index + 1]) {\n            return false;\n        }\n        index += 1;\n    }\n    true\n}\n\nfn main() {}\n\n} // verus!\n", "x": "use vstd::prelude::*;\n\nverus! {\n\nfn contains_consecutive_numbers(arr: &Vec<i32>) -> (is_consecutive: bool)\n    requires\n        arr.len() > 0,\n        forall|i: int| 0 <= i < arr.len() ==> (0 <= #[trigger] arr[i] + 1 < i32::MAX),\n    ensures\n        is_consecutive == (forall|i: int, j: int|\n            0 <= i < j < arr.len() && j == i + 1 ==> (arr[i] + 1 == arr[j])),\n{", "dset": "MBPP"}